# Compute the coefficient :math:`K` for correcting the difference between
colour.adaptation.cie1994.K_coefficient

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.cie1994.MATRIX_RGB_TO_XYZ_CIE1994

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.cie1994.MATRIX_XYZ_TO_RGB_CIE1994

# Convert from cone responses to *CIE XYZ* tristimulus values.
colour.adaptation.cie1994.RGB_to_XYZ_CIE1994

# Convert from *CIE XYZ* tristimulus values to cone responses.
colour.adaptation.cie1994.XYZ_to_RGB_CIE1994

# Compute the exponent :math:`\beta_1` for the middle and long-wavelength
colour.adaptation.cie1994.beta_1

# Compute the exponent :math:`\beta_2` for the short-wavelength sensitive
colour.adaptation.cie1994.beta_2

# Adapt given stimulus *CIE XYZ_1* tristimulus values from test viewing
colour.adaptation.cie1994.chromatic_adaptation_CIE1994

# Compute the corresponding colour cone responses of given test sample cone
colour.adaptation.cie1994.corresponding_colour

# Derive the effective adapting responses in the fundamental primary system
colour.adaptation.cie1994.effective_adapting_responses

# Return the chromatic adaptation exponential factors :math:`\beta_1(R_o)`,
colour.adaptation.cie1994.exponential_factors

# Return the intermediate values :math:`\xi`, :math:`\eta`,
colour.adaptation.cie1994.intermediate_values

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.cmccat2000.CAT_INVERSE_CMCCAT2000

# *CMCCAT2000* chromatic adaptation model induction factors.
colour.adaptation.cmccat2000.InductionFactors_CMCCAT2000

# Reference *CMCCAT2000* chromatic adaptation model viewing conditions.
colour.adaptation.cmccat2000.VIEWING_CONDITIONS_CMCCAT2000

# Adapt given stimulus *CIE XYZ* tristimulus values using given viewing
colour.adaptation.cmccat2000.chromatic_adaptation_CMCCAT2000

# Adapt given stimulus *CIE XYZ* tristimulus values from test viewing
colour.adaptation.cmccat2000.chromatic_adaptation_forward_CMCCAT2000

# Adapt given stimulus corresponding colour *CIE XYZ* tristimulus values
colour.adaptation.cmccat2000.chromatic_adaptation_inverse_CMCCAT2000

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_BIANCO2010

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_BRADFORD

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_CAT02

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_CAT02_BRILL2008

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_CAT16

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_CMCCAT2000

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_CMCCAT97

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_FAIRCHILD

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_PC_BIANCO2010

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_SHARP

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_VON_KRIES

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.datasets.cat.CAT_XYZ_SCALING

# Chromatic adaptation transforms.
colour.adaptation.datasets.cat.CHROMATIC_ADAPTATION_TRANSFORMS

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.fairchild1990.MATRIX_RGB_TO_XYZ_FAIRCHILD1990

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.fairchild1990.MATRIX_XYZ_TO_RGB_FAIRCHILD1990

# Convert from cone responses to *CIE XYZ* tristimulus values.
colour.adaptation.fairchild1990.RGB_to_XYZ_Fairchild1990

# Convert from *CIE XYZ* tristimulus values to cone responses.
colour.adaptation.fairchild1990.XYZ_to_RGB_Fairchild1990

# Adapt given stimulus *CIE XYZ_1* tristimulus values from test viewing
colour.adaptation.fairchild1990.chromatic_adaptation_Fairchild1990

# Compute the degrees of adaptation :math:`p_L`, :math:`p_M` and
colour.adaptation.fairchild1990.degrees_of_adaptation

# Conditions for the *Von Kries 2020* (*vK20*) degree of adaptation coefficients.
colour.adaptation.fairchild2020.CONDITIONS_DEGREE_OF_ADAPTATION_VK20

# *Von Kries 2020* (*vK20*) degree of adaptation coefficients.
colour.adaptation.fairchild2020.Coefficients_DegreeOfAdaptation_vK20

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.adaptation.fairchild2020.TVS_XYZ_R_VK20

# Adapt given stimulus from previous viewing conditions to adapting viewing
colour.adaptation.fairchild2020.chromatic_adaptation_vK20

# Compute the *chromatic adaptation* matrix from previous viewing conditions
colour.adaptation.fairchild2020.matrix_chromatic_adaptation_vk20

# Adapt given stimulus from test viewing conditions to reference viewing
colour.adaptation.vonkries.chromatic_adaptation_VonKries

# Compute the *chromatic adaptation* matrix from test viewing conditions
colour.adaptation.vonkries.matrix_chromatic_adaptation_VonKries

# Adapt given sample colour :math:`XYZ_{\beta}` tristimulus values from
colour.adaptation.zhai2018.chromatic_adaptation_Zhai2018

# Return the eigen-values :math:`w` and eigen-vectors :math:`v` of given
colour.algebra.common.eigen_decomposition

# Return the *Euclidean* distance between point array :math:`a` and point
colour.algebra.common.euclidean_distance

# Return *Colour* safe division mode.
colour.algebra.common.get_sdiv_mode

# Return whether :math:`a` array is an identity matrix.
colour.algebra.common.is_identity

# Return whether *Colour* safe / symmetrical power function is enabled.
colour.algebra.common.is_spow_enabled

# Perform a simple linear interpolation between given array :math:`a` and
colour.algebra.common.lerp

# Perform a simple linear conversion of given array :math:`a` between the
colour.algebra.common.linear_conversion

# Perform a simple linear interpolation between given array :math:`a` and
colour.algebra.common.linstep_function

# Return the *Manhattan* (or *City-Block*) distance between point array
colour.algebra.common.manhattan_distance

# Normalise given array :math:`a` values by :math:`a` maximum value and
colour.algebra.common.normalise_maximum

# Normalise given vector :math:`a`.
colour.algebra.common.normalise_vector

# Divide given array :math:`b` with array :math:`b` while handling
colour.algebra.common.sdiv

# Define a context manager and decorator temporarily setting *Colour* safe
colour.algebra.common.sdiv_mode

# Set *Colour* safe division function mode.
colour.algebra.common.set_sdiv_mode

# Set *Colour* safe / symmetrical power function enabled state.
colour.algebra.common.set_spow_enable

# Evaluate the *smoothstep* sigmoid-like function on array :math:`x`.
colour.algebra.common.smooth

# Evaluate the *smoothstep* sigmoid-like function on array :math:`x`.
colour.algebra.common.smoothstep_function

# Raise given array :math:`a` to the power :math:`p` as follows:
colour.algebra.common.spow

# Define a context manager and decorator temporarily setting *Colour* safe /
colour.algebra.common.spow_enable

# Perform the batched multiplication between the matrix array :math:`m` and
colour.algebra.common.vecmul

# Transform given cartesian coordinates array :math:`xyz` to cylindrical
colour.algebra.coordinates.transformations.cartesian_to_cylindrical

# Transform given cartesian coordinates array :math:`xy` to polar
colour.algebra.coordinates.transformations.cartesian_to_polar

# Transform given cartesian coordinates array :math:`xyz` to spherical
colour.algebra.coordinates.transformations.cartesian_to_spherical

# Transform given cylindrical coordinates array :math:`\rho\phi z`
colour.algebra.coordinates.transformations.cylindrical_to_cartesian

# Transform given polar coordinates array :math:`\rho\phi` (radial
colour.algebra.coordinates.transformations.polar_to_cartesian

# Transform given spherical coordinates array :math:`\rho\theta\phi`
colour.algebra.coordinates.transformations.spherical_to_cartesian

# Extrapolate the 1-D function of given interpolator.
colour.algebra.extrapolation.Extrapolator

# Interpolate a 1-D function using cubic spline interpolation.
colour.algebra.interpolation.CubicSplineInterpolator

# Kernel based interpolation of a 1-D function.
colour.algebra.interpolation.KernelInterpolator

# Interpolate linearly a 1-D function.
colour.algebra.interpolation.LinearInterpolator

# A nearest-neighbour interpolator.
colour.algebra.interpolation.NearestNeighbourInterpolator

# Perform 1-D function null interpolation, i.e., a call within given
colour.algebra.interpolation.NullInterpolator

# Interpolate a 1-D function using Piecewise Cubic Hermite Interpolating
colour.algebra.interpolation.PchipInterpolator

# Construct a fifth-order polynomial that passes through :math:`y` dependent
colour.algebra.interpolation.SpragueInterpolator

# Supported table interpolation methods.
colour.algebra.interpolation.TABLE_INTERPOLATION_METHODS

# Return the *cardinal spline* kernel evaluated at given samples.
colour.algebra.interpolation.kernel_cardinal_spline

# Return the *lanczos* kernel evaluated at given samples.
colour.algebra.interpolation.kernel_lanczos

# Return the *linear* kernel evaluated at given samples.
colour.algebra.interpolation.kernel_linear

# Return the *nearest-neighbour* kernel evaluated at given samples.
colour.algebra.interpolation.kernel_nearest_neighbour

# Return the *sinc* kernel evaluated at given samples.
colour.algebra.interpolation.kernel_sinc

# Compute the *Lagrange Coefficients* at given point :math:`r` for degree
colour.algebra.interpolation.lagrange_coefficients

# Perform interpolation of given :math:`V_{xyz}` values using given
colour.algebra.interpolation.table_interpolation

# Perform the tetrahedral interpolation of given :math:`V_{xyz}` values using
colour.algebra.interpolation.table_interpolation_tetrahedral

# Perform the trilinear interpolation of given :math:`V_{xyz}` values using
colour.algebra.interpolation.table_interpolation_trilinear

# Compute the vertices coordinates and indexes relative :math:`V_{xyzr}`
colour.algebra.interpolation.vertices_and_relative_coordinates

# RandomState(seed=None)
colour.algebra.prng.RANDOM_STATE

# Return a generator yielding random triplets.
colour.algebra.prng.random_triplet_generator

# Compute the *least-squares* mapping from dependent variable :math:`y` to
colour.algebra.regression.least_square_mapping_MoorePenrose

# Define the *ATD (1995)* colour vision model reference specification.
colour.appearance.atd95.CAM_ReferenceSpecification_ATD95

# Define the *ATD (1995)* colour vision model specification.
colour.appearance.atd95.CAM_Specification_ATD95

# Compute the *ATD (1995)* colour vision model correlates.
colour.appearance.atd95.XYZ_to_ATD95

# Convert from *CIE XYZ* tristimulus values to *LMS* cone responses.
colour.appearance.atd95.XYZ_to_LMS_ATD95

# Return the final response of given opponent colour dimension.
colour.appearance.atd95.final_response

# Convert from luminance in :math:`cd/m^2` to retinal illuminance in
colour.appearance.atd95.luminance_to_retinal_illuminance

# Return opponent colour dimensions from given post adaptation cone signals.
colour.appearance.atd95.opponent_colour_dimensions

# Convert from *CAM16* specification to *CIE XYZ* tristimulus values.
colour.appearance.cam16.CAM16_to_XYZ

# Define the *CAM16* colour appearance model specification.
colour.appearance.cam16.CAM_Specification_CAM16

# *CAM16* colour appearance model induction factors.
colour.appearance.cam16.InductionFactors_CAM16

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.cam16.MATRIX_16

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.cam16.MATRIX_INVERSE_16

# Reference *CAM16* colour appearance model viewing conditions.
colour.appearance.cam16.VIEWING_CONDITIONS_CAM16

# Compute the *CAM16* colour appearance model correlates from given
colour.appearance.cam16.XYZ_to_CAM16

# dict() -> new empty dictionary
colour.appearance.ciecam02.CAM_KWARGS_CIECAM02_sRGB

# Define the *CIECAM02* colour appearance model specification.
colour.appearance.ciecam02.CAM_Specification_CIECAM02

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.ciecam02.CAT_INVERSE_CAT02

# Convert from *CIECAM02* specification to *CIE XYZ* tristimulus values.
colour.appearance.ciecam02.CIECAM02_to_XYZ

# dict() -> new empty dictionary
colour.appearance.ciecam02.HUE_DATA_FOR_HUE_QUADRATURE

# *CIECAM02* colour appearance model induction factors.
colour.appearance.ciecam02.InductionFactors_CIECAM02

# Return the points :math:`P_1`, :math:`P_2` and :math:`P_3`.
colour.appearance.ciecam02.P

# Convert given *RGB* array to *Hunt-Pointer-Estevez*
colour.appearance.ciecam02.RGB_to_rgb

# Reference *CIECAM02* colour appearance model viewing conditions.
colour.appearance.ciecam02.VIEWING_CONDITIONS_CIECAM02

# Compute the *CIECAM02* colour appearance model correlates from given
colour.appearance.ciecam02.XYZ_to_CIECAM02

# Return the achromatic response :math:`A` from given compressed
colour.appearance.ciecam02.achromatic_response_forward

# Return the achromatic response :math:`A` from given achromatic response
colour.appearance.ciecam02.achromatic_response_inverse

# Return the base exponential non-linearity :math:`n`.
colour.appearance.ciecam02.base_exponential_non_linearity

# Return the *brightness* correlate :math:`Q`.
colour.appearance.ciecam02.brightness_correlate

# Return the *chroma* correlate :math:`C`.
colour.appearance.ciecam02.chroma_correlate

# Return the chromatic induction factors :math:`N_{bb}` and :math:`N_{cb}`.
colour.appearance.ciecam02.chromatic_induction_factors

# Return the *colourfulness* correlate :math:`M`.
colour.appearance.ciecam02.colourfulness_correlate

# Return the degree of adaptation :math:`D` from given surround maximum
colour.appearance.ciecam02.degree_of_adaptation

# Return the eccentricity factor :math:`e_t` from given hue :math:`h` angle
colour.appearance.ciecam02.eccentricity_factor

# Apply full chromatic adaptation to given *CMCCAT2000* transform sharpened
colour.appearance.ciecam02.full_chromatic_adaptation_forward

# Revert full chromatic adaptation of given *CMCCAT2000* transform sharpened
colour.appearance.ciecam02.full_chromatic_adaptation_inverse

# Return the *hue* angle :math:`h` in degrees.
colour.appearance.ciecam02.hue_angle

# Return the hue quadrature from given hue :math:`h` angle in degrees.
colour.appearance.ciecam02.hue_quadrature

# Return the *Lightness* correlate :math:`J`.
colour.appearance.ciecam02.lightness_correlate

# Apply the post-adaptation non-linear-response compression matrix.
colour.appearance.ciecam02.matrix_post_adaptation_non_linear_response_compression

# Return opponent colour dimensions from given compressed *CMCCAT2000*
colour.appearance.ciecam02.opponent_colour_dimensions_forward

# Return opponent colour dimensions from given points :math:`P_n` and hue
colour.appearance.ciecam02.opponent_colour_dimensions_inverse

# Return given *CMCCAT2000* transform sharpened *RGB* array with post
colour.appearance.ciecam02.post_adaptation_non_linear_response_compression_forward

# Return given *CMCCAT2000* transform sharpened *RGB* array without post
colour.appearance.ciecam02.post_adaptation_non_linear_response_compression_inverse

# Convert given *Hunt-Pointer-Estevez* :math:`\rho\gamma\beta`
colour.appearance.ciecam02.rgb_to_RGB

# Return the *saturation* correlate :math:`s`.
colour.appearance.ciecam02.saturation_correlate

# Return the temporary magnitude quantity :math:`t`. for forward *CIECAM02*
colour.appearance.ciecam02.temporary_magnitude_quantity_forward

# Return the temporary magnitude quantity :math:`t`. for inverse *CIECAM02*
colour.appearance.ciecam02.temporary_magnitude_quantity_inverse

# Return the viewing condition dependent parameters.
colour.appearance.ciecam02.viewing_conditions_dependent_parameters

# Define the *CIECAM16* colour appearance model specification.
colour.appearance.ciecam16.CAM_Specification_CIECAM16

# Convert from *CIECAM16* specification to *CIE XYZ* tristimulus values.
colour.appearance.ciecam16.CIECAM16_to_XYZ

# *CIECAM16* colour appearance model induction factors.
colour.appearance.ciecam16.InductionFactors_CIECAM16

# Reference *CIECAM16* colour appearance model viewing conditions.
colour.appearance.ciecam16.VIEWING_CONDITIONS_CIECAM16

# Compute the *CIECAM16* colour appearance model correlates from given
colour.appearance.ciecam16.XYZ_to_CIECAM16

# Define the :math:`f'(q)` function derivative.
colour.appearance.ciecam16.d_f_q

# Compute the post-adaptation cone responses.
colour.appearance.ciecam16.f_e_forward

# Compute the modified cone-like responses.
colour.appearance.ciecam16.f_e_inverse

# Define the :math:`f(q)` function.
colour.appearance.ciecam16.f_q

# Define the *Hellwig and Fairchild (2022)* colour appearance model
colour.appearance.hellwig2022.CAM_Specification_Hellwig2022

# Convert from *Hellwig and Fairchild (2022)* specification to *CIE XYZ*
colour.appearance.hellwig2022.Hellwig2022_to_XYZ

# *Hellwig and Fairchild (2022)* colour appearance model induction factors.
colour.appearance.hellwig2022.InductionFactors_Hellwig2022

# Return the points :math:`P'_1` and :math:`P'_2`.
colour.appearance.hellwig2022.P_p

# Reference *Hellwig and Fairchild (2022)* colour appearance model viewing
colour.appearance.hellwig2022.VIEWING_CONDITIONS_HELLWIG2022

# Compute the *Hellwig and Fairchild (2022)* colour appearance model
colour.appearance.hellwig2022.XYZ_to_Hellwig2022

# Return the achromatic response :math:`A` from given compressed
colour.appearance.hellwig2022.achromatic_response_forward

# Return the *brightness* correlate :math:`Q`.
colour.appearance.hellwig2022.brightness_correlate

# Return the *chroma* correlate :math:`C`.
colour.appearance.hellwig2022.chroma_correlate

# Return the *colourfulness* correlate :math:`M`.
colour.appearance.hellwig2022.colourfulness_correlate

# Return the eccentricity factor :math:`e_t` from given hue :math:`h` angle
colour.appearance.hellwig2022.eccentricity_factor

# Compute the hue angle dependency of the *Helmholtz-Kohlrausch* effect.
colour.appearance.hellwig2022.hue_angle_dependency_Hellwig2022

# Return opponent colour dimensions from given point :math:`P'_1`, hue
colour.appearance.hellwig2022.opponent_colour_dimensions_inverse

# Return the *saturation* correlate :math:`s`.
colour.appearance.hellwig2022.saturation_correlate

# Return the viewing condition dependent parameters.
colour.appearance.hellwig2022.viewing_conditions_dependent_parameters

# *Nayatani (1997)* *HKE* computation methods, choice between variable achromatic
colour.appearance.hke.HKE_NAYATANI1997_METHODS

# Return the *HKE* factor for luminous colours using *Nayatani (1997)* method.
colour.appearance.hke.HelmholtzKohlrausch_effect_luminous_Nayatani1997

# Return the *HKE* value for object colours using *Nayatani (1997)* method.
colour.appearance.hke.HelmholtzKohlrausch_effect_object_Nayatani1997

# Return the :math:`K_{Br}` coefficient for *Nayatani (1997)* *HKE*
colour.appearance.hke.coefficient_K_Br_Nayatani1997

# Return the :math:`q(\theta)` coefficient for *Nayatani (1997)* *HKE*
colour.appearance.hke.coefficient_q_Nayatani1997

# Define the *Hunt* colour appearance model reference specification.
colour.appearance.hunt.CAM_ReferenceSpecification_Hunt

# Define the *Hunt* colour appearance model specification.
colour.appearance.hunt.CAM_Specification_Hunt

# dict() -> new empty dictionary
colour.appearance.hunt.HUE_DATA_FOR_HUE_QUADRATURE

# *Hunt* colour appearance model induction factors.
colour.appearance.hunt.InductionFactors_Hunt

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.hunt.MATRIX_HPE_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.hunt.MATRIX_XYZ_TO_HPE

# Reference *Hunt* colour appearance model viewing conditions.
colour.appearance.hunt.VIEWING_CONDITIONS_HUNT

# Compute the *Hunt* colour appearance model correlates.
colour.appearance.hunt.XYZ_to_Hunt

# Convert from *CIE XYZ* tristimulus values to *Hunt-Pointer-Estevez*
colour.appearance.hunt.XYZ_to_rgb

# Return the achromatic post adaptation signal :math:`A` from given
colour.appearance.hunt.achromatic_post_adaptation_signal

# Return the achromatic signal :math:`A`.
colour.appearance.hunt.achromatic_signal

# Adjust the white point for simultaneous chromatic contrast.
colour.appearance.hunt.adjusted_reference_white_signals

# Return the *brightness* correlate :math:`Q`.
colour.appearance.hunt.brightness_correlate

# Return the *chroma* correlate :math:`C_94`.
colour.appearance.hunt.chroma_correlate

# Apply chromatic adaptation to given *CIE XYZ* tristimulus values.
colour.appearance.hunt.chromatic_adaptation

# Return the colour difference signals :math:`C_1`, :math:`C_2` and
colour.appearance.hunt.colour_difference_signals

# Return the *colourfulness* correlate :math:`M_94`.
colour.appearance.hunt.colourfulness_correlate

# Return eccentricity factor :math:`e_s` from given hue angle :math:`h`
colour.appearance.hunt.eccentricity_factor

# Define the nonlinear response function of the *Hunt* colour appearance
colour.appearance.hunt.f_n

# Return the *hue* angle :math:`h` in degrees from given colour difference
colour.appearance.hunt.hue_angle

# Return the approximate scotopic luminance :math:`L_{AS}` of the
colour.appearance.hunt.illuminant_scotopic_luminance

# Return the *Lightness* correlate :math:`J`.
colour.appearance.hunt.lightness_correlate

# Return the low luminance tritanopia factor :math:`F_t` from given adapting
colour.appearance.hunt.low_luminance_tritanopia_factor

# Return the *luminance* level adaptation factor :math:`F_L`.
colour.appearance.hunt.luminance_level_adaptation_factor

# Return the overall chromatic response :math:`M`.
colour.appearance.hunt.overall_chromatic_response

# Return the redness / greenness response :math:`M_{yb}`.
colour.appearance.hunt.redness_greenness_response

# Return the *saturation* correlate :math:`s`.
colour.appearance.hunt.saturation_correlate

# Return the yellowness / blueness response :math:`M_{yb}`.
colour.appearance.hunt.yellowness_blueness_response

# Define the *Kim, Weyrich and Kautz (2009)* colour appearance model
colour.appearance.kim2009.CAM_Specification_Kim2009

# *Kim, Weyrich and Kautz (2009)* colour appearance model induction factors.
colour.appearance.kim2009.InductionFactors_Kim2009

# Convert from *Kim, Weyrich and Kautz (2009)* specification to *CIE XYZ*
colour.appearance.kim2009.Kim2009_to_XYZ

# Reference *Kim, Weyrich and Kautz (2009)* colour appearance model media
colour.appearance.kim2009.MEDIA_PARAMETERS_KIM2009

# *Kim, Weyrich and Kautz (2009)* colour appearance model media parameters.
colour.appearance.kim2009.MediaParameters_Kim2009

# Reference *Kim, Weyrich and Kautz (2009)* colour appearance model viewing
colour.appearance.kim2009.VIEWING_CONDITIONS_KIM2009

# Compute the *Kim, Weyrich and Kautz (2009)* colour appearance model
colour.appearance.kim2009.XYZ_to_Kim2009

# Define the *:math:`LLAB(l:c)`* colour appearance model reference
colour.appearance.llab.CAM_ReferenceSpecification_LLAB

# Define the *:math:`LLAB(l:c)`* colour appearance model specification.
colour.appearance.llab.CAM_Specification_LLAB

# *:math:`LLAB(l:c)`* colour appearance model induction factors.
colour.appearance.llab.InductionFactors_LLAB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.llab.MATRIX_RGB_TO_XYZ_LLAB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.llab.MATRIX_XYZ_TO_RGB_LLAB

# Reference :math:`LLAB(l:c)` colour appearance model viewing conditions.
colour.appearance.llab.VIEWING_CONDITIONS_LLAB

# Compute the *:math:`LLAB(l:c)`* colour appearance model correlates.
colour.appearance.llab.XYZ_to_LLAB

# Convert from *CIE XYZ* tristimulus values to normalised cone responses.
colour.appearance.llab.XYZ_to_RGB_LLAB

# Return the correlate of *chroma* :math:`Ch_L`.
colour.appearance.llab.chroma_correlate

# Apply chromatic adaptation to given *RGB* normalised cone responses
colour.appearance.llab.chromatic_adaptation

# Return the correlate of *colourfulness* :math:`C_L`.
colour.appearance.llab.colourfulness_correlate

# Define the nonlinear response function of the *:math:`LLAB(l:c)`* colour
colour.appearance.llab.f

# Return the final opponent signals :math:`A_L` and :math:`B_L`.
colour.appearance.llab.final_opponent_signals

# Return the *hue* angle :math:`h_L` in degrees.
colour.appearance.llab.hue_angle

# Return opponent colour dimensions from given adapted *CIE XYZ* tristimulus
colour.appearance.llab.opponent_colour_dimensions

# Return the correlate of *saturation* :math:`S_L`.
colour.appearance.llab.saturation_correlate

# Define the *Nayatani (1995)* colour appearance model reference
colour.appearance.nayatani95.CAM_ReferenceSpecification_Nayatani95

# Define the *Nayatani (1995)* colour appearance model specification.
colour.appearance.nayatani95.CAM_Specification_Nayatani95

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.nayatani95.MATRIX_XYZ_TO_RGB_NAYATANI95

# Compute the *Nayatani (1995)* colour appearance model correlates.
colour.appearance.nayatani95.XYZ_to_Nayatani95

# Convert from *CIE XYZ* tristimulus values to cone responses.
colour.appearance.nayatani95.XYZ_to_RGB_Nayatani95

# Return the *achromatic Lightness* correlate :math:`L_p^\star`.
colour.appearance.nayatani95.achromatic_lightness_correlate

# Return the achromatic response :math:`Q` from given stimulus cone
colour.appearance.nayatani95.achromatic_response

# Return the *brightness* correlate :math:`B_r`.
colour.appearance.nayatani95.brightness_correlate

# Return the *chroma* components :math:`C_{RG}` and :math:`C_{YB}`.
colour.appearance.nayatani95.chroma_components

# Return the correlate of *chroma* :math:`C`.
colour.appearance.nayatani95.chroma_correlate

# Define the chromatic strength function :math:`E_s(\theta)` used to
colour.appearance.nayatani95.chromatic_strength_function

# Return the *colourfulness* components :math:`M_{RG}` and :math:`M_{YB}`.
colour.appearance.nayatani95.colourfulness_components

# Return the correlate of *colourfulness* :math:`M`.
colour.appearance.nayatani95.colourfulness_correlate

# Return the *hue* angle :math:`h` in degrees.
colour.appearance.nayatani95.hue_angle

# Return the ideal white *brightness* correlate :math:`B_{rw}`.
colour.appearance.nayatani95.ideal_white_brightness_correlate

# Convert given *illuminance* :math:`E` value in lux to *luminance* in
colour.appearance.nayatani95.illuminance_to_luminance

# Return the *normalised achromatic Lightness* correlate :math:`L_n^\star`.
colour.appearance.nayatani95.normalised_achromatic_lightness_correlate

# Return the protanopic response :math:`p` from given stimulus cone
colour.appearance.nayatani95.protanopic_response

# Return the *saturation* components :math:`S_{RG}` and :math:`S_{YB}`.
colour.appearance.nayatani95.saturation_components

# Return the correlate of *saturation* :math:`S`.
colour.appearance.nayatani95.saturation_correlate

# Return the scaling coefficient :math:`e(R)` or :math:`e(G)`.
colour.appearance.nayatani95.scaling_coefficient

# Return the tritanopic response :math:`t` from given stimulus cone
colour.appearance.nayatani95.tritanopic_response

# Define the *RLAB* colour appearance model reference specification.
colour.appearance.rlab.CAM_ReferenceSpecification_RLAB

# Define the *RLAB* colour appearance model specification.
colour.appearance.rlab.CAM_Specification_RLAB

# *RLAB* colour appearance model *Discounting-the-Illuminant* factor values.
colour.appearance.rlab.D_FACTOR_RLAB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.appearance.rlab.MATRIX_R

# Reference *RLAB* colour appearance model viewing conditions.
colour.appearance.rlab.VIEWING_CONDITIONS_RLAB

# Compute the *RLAB* model color appearance correlates.
colour.appearance.rlab.XYZ_to_RLAB

# Define the *ZCAM* colour appearance model specification.
colour.appearance.zcam.CAM_Specification_ZCAM

# *ZCAM* colour appearance model induction factors.
colour.appearance.zcam.InductionFactors_ZCAM

# Reference *ZCAM* colour appearance model viewing conditions.
colour.appearance.zcam.VIEWING_CONDITIONS_ZCAM

# Compute the *ZCAM* colour appearance model correlates from given *CIE XYZ*
colour.appearance.zcam.XYZ_to_ZCAM

# Convert from *ZCAM* specification to *CIE XYZ* tristimulus values.
colour.appearance.zcam.ZCAM_to_XYZ

# Supported *Michaelis-Menten* kinetics reaction rate equation computation
colour.biochemistry.michaelis_menten.REACTION_RATE_MICHAELISMENTEN_METHODS

# Supported *Michaelis-Menten* kinetics substrate concentration equation
colour.biochemistry.michaelis_menten.SUBSTRATE_CONCENTRATION_MICHAELISMENTEN_METHODS

# Describe the rate of enzymatic reactions, by relating reaction rate
colour.biochemistry.michaelis_menten.reaction_rate_MichaelisMenten

# Describe the rate of enzymatic reactions, by relating reaction rate
colour.biochemistry.michaelis_menten.reaction_rate_MichaelisMenten_Abebe2017

# Describe the rate of enzymatic reactions, by relating reaction rate
colour.biochemistry.michaelis_menten.reaction_rate_MichaelisMenten_Michaelis1913

# Describe the rate of enzymatic reactions, by relating concentration of a
colour.biochemistry.michaelis_menten.substrate_concentration_MichaelisMenten

# Describe the rate of enzymatic reactions, by relating concentration of a
colour.biochemistry.michaelis_menten.substrate_concentration_MichaelisMenten_Abebe2017

# Describe the rate of enzymatic reactions, by relating concentration of a
colour.biochemistry.michaelis_menten.substrate_concentration_MichaelisMenten_Michaelis1913

# Machado (2010) Simulation matrices :math:`\Phi_{CVD}`.
colour.blindness.datasets.machado2010.CVD_MATRICES_MACHADO2010

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.blindness.machado2009.MATRIX_LMS_TO_WSYBRG

# Compute the matrix transforming from *RGB* colourspace to opponent-colour
colour.blindness.machado2009.matrix_RGB_to_WSYBRG

# Compute the *Machado et al. (2009)* *CVD* matrix for given *LMS* cone
colour.blindness.machado2009.matrix_anomalous_trichromacy_Machado2009

# Compute *Machado et al. (2009)* *CVD* matrix for given deficiency and
colour.blindness.machado2009.matrix_cvd_Machado2009

# Shift given *LMS* cone fundamentals colour matching functions with given
colour.blindness.machado2009.msds_cmfs_anomalous_trichromacy_Machado2009

# Convert a string or number to a floating-point number, if possible.
colour.characterisation.aces_it.FLARE_PERCENTAGE

# str(object='') -> str
colour.characterisation.aces_it.ROOT_RESOURCES_RAWTOACES

# Define the base object for spectral distribution shape.
colour.characterisation.aces_it.SPECTRAL_SHAPE_RAWTOACES

# Convert a string or number to a floating-point number, if possible.
colour.characterisation.aces_it.S_FLARE_FACTOR

# Select the best illuminant for given *RGB* white balance multipliers, and
colour.characterisation.aces_it.best_illuminant

# Convert given camera *RGB* colourspace array to *ACES2065-1* colourspace
colour.characterisation.aces_it.camera_RGB_to_ACES2065_1

# Generate a series of illuminants according to *RAW to ACES* v1:
colour.characterisation.aces_it.generate_illuminants_rawtoaces_v1

# Compute an *Input Device Transform* (IDT) matrix for given camera *RGB*
colour.characterisation.aces_it.matrix_idt

# Normalise given illuminant with given camera *RGB* spectral sensitivities.
colour.characterisation.aces_it.normalise_illuminant

# Produce the objective function and *CIE XYZ* colourspace to optimisation
colour.characterisation.aces_it.optimisation_factory_Jzazbz

# Produce the objective function and *CIE XYZ* colourspace to optimisation
colour.characterisation.aces_it.optimisation_factory_Oklab_15

# Produce the objective function and *CIE XYZ* colourspace to optimisation
colour.characterisation.aces_it.optimisation_factory_rawtoaces_v1

# Read the *RAW to ACES* v1 190 patches.
colour.characterisation.aces_it.read_training_data_rawtoaces_v1

# Convert given spectral distribution to *ACES2065-1* colourspace relative
colour.characterisation.aces_it.sd_to_ACES2065_1

# Convert given spectral distribution to *ACES2065-1* colourspace relative
colour.characterisation.aces_it.sd_to_aces_relative_exposure_values

# Convert given training data to *RGB* tristimulus values using given
colour.characterisation.aces_it.training_data_sds_to_RGB

# Convert given training data to *CIE XYZ* tristimulus values using given
colour.characterisation.aces_it.training_data_sds_to_XYZ

# Compute the *RGB* white balance multipliers for given camera *RGB*
colour.characterisation.aces_it.white_balance_multipliers

# Normalise given matrix :math:`M` to preserve given white point
colour.characterisation.aces_it.whitepoint_preserving_matrix

# Implement support for a camera *RGB* sensitivities.
colour.characterisation.cameras.RGB_CameraSensitivities

# Supported methods to apply a colour correction matrix.
colour.characterisation.correction.APPLY_MATRIX_COLOUR_CORRECTION_METHODS

# Supported colour correction methods.
colour.characterisation.correction.COLOUR_CORRECTION_METHODS

# Supported colour correction matrix methods.
colour.characterisation.correction.MATRIX_COLOUR_CORRECTION_METHODS

# Supported polynomial expansion methods.
colour.characterisation.correction.POLYNOMIAL_EXPANSION_METHODS

# Apply given colour correction matrix :math:`CCM` to given *RGB* colourspace
colour.characterisation.correction.apply_matrix_colour_correction

# Apply given colour correction matrix :math:`CCM` computed using
colour.characterisation.correction.apply_matrix_colour_correction_Cheung2004

# Apply given colour correction matrix :math:`CCM` computed using
colour.characterisation.correction.apply_matrix_colour_correction_Finlayson2015

# Apply given colour correction matrix :math:`CCM` computed using
colour.characterisation.correction.apply_matrix_colour_correction_Vandermonde

# Perform colour correction of given *RGB* colourspace array using the
colour.characterisation.correction.colour_correction

# Perform colour correction of given *RGB* colourspace array using the
colour.characterisation.correction.colour_correction_Cheung2004

# Perform colour correction of given *RGB* colourspace array using the
colour.characterisation.correction.colour_correction_Finlayson2015

# Perform colour correction of given *RGB* colourspace array using the
colour.characterisation.correction.colour_correction_Vandermonde

# Perform polynomial expansion of given *RGB* colourspace array using
colour.characterisation.correction.matrix_augmented_Cheung2004

# Compute a colour correction matrix from given :math:`M_T` colour array to
colour.characterisation.correction.matrix_colour_correction

# Compute a colour correction matrix from given :math:`M_T` colour array to
colour.characterisation.correction.matrix_colour_correction_Cheung2004

# Compute a colour correction matrix from given :math:`M_T` colour array to
colour.characterisation.correction.matrix_colour_correction_Finlayson2015

# Compute a colour correction matrix from given :math:`M_T` colour array to
colour.characterisation.correction.matrix_colour_correction_Vandermonde

# Perform polynomial expansion of given :math:`a` array.
colour.characterisation.correction.polynomial_expansion

# Perform polynomial expansion of given *RGB* colourspace array using
colour.characterisation.correction.polynomial_expansion_Finlayson2015

# Perform polynomial expansion of given :math:`a` array using *Vandermonde*
colour.characterisation.correction.polynomial_expansion_Vandermonde

# dict() -> new empty dictionary
colour.characterisation.datasets.aces_it.DATA_ACES_RICD

# Implement support for a camera *RGB* sensitivities.
colour.characterisation.datasets.aces_it.MSDS_ACES_RICD

# dict() -> new empty dictionary
colour.characterisation.datasets.cameras.dslr.sensitivities.DATA_CAMERA_SENSITIVITIES_DSLR

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.characterisation.datasets.cameras.dslr.sensitivities.MSDS_CAMERA_SENSITIVITIES_DSLR

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_BABELCOLOR_AVERAGE

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLORCHECKER1976

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLORCHECKER2005

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLORCHECKER24_AFTER_NOV2014

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLORCHECKER24_BEFORE_NOV2014

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLORCHECKERSG_AFTER_NOV2014

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLORCHECKERSG_BEFORE_NOV2014

# Chromaticity coordinates of the colour checkers.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_COLOURCHECKERS

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_BABELCOLOR_AVERAGE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_COLORCHECKER1976

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_COLORCHECKER2005

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_COLORCHECKER24_AFTER_NOV2014

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_COLORCHECKER24_BEFORE_NOV2014

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_COLORCHECKERSG_AFTER_NOV2014

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_COLORCHECKERSG_BEFORE_NOV2014

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_ILLUMINANT_TE226_V2

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.CCS_TE226_V2

# *Colour Checker* data.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.ColourChecker

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_BABELCOLOR_AVERAGE

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKER1976

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKER2005

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKER24_AFTER_NOV2014

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKER24_AFTER_NOV2014_CIE_LAB

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKER24_BEFORE_NOV2014

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKER24_BEFORE_NOV2014_CIE_LAB

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKERSG_AFTER_NOV2014

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKERSG_AFTER_NOV2014_CIE_LAB

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKERSG_BEFORE_NOV2014

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_COLORCHECKERSG_BEFORE_NOV2014_CIE_LAB

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_TE226_V2

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.DATA_TE226_V2_CIE_XYZ

# Built-in immutable sequence.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.SAMPLE_LABELS_COLORCHECKER_CLASSIC

# Built-in immutable sequence.
colour.characterisation.datasets.colour_checkers.chromaticity_coordinates.SAMPLE_LABELS_COLORCHECKER_SG

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.sds.DATA_BABELCOLOR_AVERAGE

# dict() -> new empty dictionary
colour.characterisation.datasets.colour_checkers.sds.DATA_COLORCHECKER_N_OHTA

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.characterisation.datasets.colour_checkers.sds.SDS_BABELCOLOR_AVERAGE

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.characterisation.datasets.colour_checkers.sds.SDS_COLORCHECKER_N_OHTA

# Spectral distributions of the colour checkers.
colour.characterisation.datasets.colour_checkers.sds.SDS_COLOURCHECKERS

# dict() -> new empty dictionary
colour.characterisation.datasets.displays.crt.primaries.DATA_DISPLAY_PRIMARIES_CRT

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.characterisation.datasets.displays.crt.primaries.MSDS_DISPLAY_PRIMARIES_CRT

# dict() -> new empty dictionary
colour.characterisation.datasets.displays.lcd.primaries.DATA_DISPLAY_PRIMARIES_LCD

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.characterisation.datasets.displays.lcd.primaries.MSDS_DISPLAY_PRIMARIES_LCD

# dict() -> new empty dictionary
colour.characterisation.datasets.filters.sds.DATA_FILTERS_ISO

# Spectral distributions of filters.
colour.characterisation.datasets.filters.sds.SDS_FILTERS

# Spectral distributions of *ISO* filters.
colour.characterisation.datasets.filters.sds.SDS_FILTERS_ISO

# dict() -> new empty dictionary
colour.characterisation.datasets.lenses.sds.DATA_LENSES_ISO

# Spectral distributions of lenses.
colour.characterisation.datasets.lenses.sds.SDS_LENSES

# Spectral distributions of *ISO* lenses.
colour.characterisation.datasets.lenses.sds.SDS_LENSES_ISO

# Implement support for a *RGB* display (such as a *CRT* or *LCD*)
colour.characterisation.displays.RGB_DisplayPrimaries

# Convert a string or number to a floating-point number, if possible.
colour.colorimetry.blackbody.CONSTANT_C1

# Convert a string or number to a floating-point number, if possible.
colour.colorimetry.blackbody.CONSTANT_C2

# int([x]) -> integer
colour.colorimetry.blackbody.CONSTANT_N

# Return the spectral radiance of a blackbody as a function of wavelength at
colour.colorimetry.blackbody.blackbody_spectral_radiance

# Return the spectral radiance of a blackbody as a function of wavelength at
colour.colorimetry.blackbody.planck_law

# Return the approximation of the spectral radiance of a blackbody as a
colour.colorimetry.blackbody.rayleigh_jeans_law

# Return the spectral distribution of the planckian radiator for given
colour.colorimetry.blackbody.sd_blackbody

# Return the spectral distribution of the planckian radiator for given
colour.colorimetry.blackbody.sd_rayleigh_jeans

# Implement support for the Stockman and Sharpe *LMS* cone fundamentals
colour.colorimetry.cmfs.LMS_ConeFundamentals

# Implement support for the *CIE RGB* colour matching functions.
colour.colorimetry.cmfs.RGB_ColourMatchingFunctions

# Implement support for the *CIE* Standard Observers *XYZ* colour matching
colour.colorimetry.cmfs.XYZ_ColourMatchingFunctions

# Supported spectral bandpass dependence correction methods.
colour.colorimetry.correction.BANDPASS_CORRECTION_METHODS

# Implement spectral bandpass dependence correction on given spectral
colour.colorimetry.correction.bandpass_correction

# Implement spectral bandpass dependence correction on given spectral
colour.colorimetry.correction.bandpass_correction_Stearns1988

# dict() -> new empty dictionary
colour.colorimetry.datasets.cmfs.DATA_CMFS_LMS

# dict() -> new empty dictionary
colour.colorimetry.datasets.cmfs.DATA_CMFS_RGB

# dict() -> new empty dictionary
colour.colorimetry.datasets.cmfs.DATA_CMFS_STANDARD_OBSERVER

# Multi-spectral distributions of the colour matching functions.
colour.colorimetry.datasets.cmfs.MSDS_CMFS

# Multi-spectral distributions of the *LMS* colour matching functions.
colour.colorimetry.datasets.cmfs.MSDS_CMFS_LMS

# Multi-spectral distributions of the *RGB* colour matching functions.
colour.colorimetry.datasets.cmfs.MSDS_CMFS_RGB

# Multi-spectral distributions of the *CIE* Standard Observer colour matching
colour.colorimetry.datasets.cmfs.MSDS_CMFS_STANDARD_OBSERVER

# Chromaticity coordinates of the illuminants.
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_ACES_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_BLACKMAGIC_DESIGN_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_CIE_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_CIE_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_DCI_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_ICC_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_ISO_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_ISO_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.chromaticity_coordinates.CCS_ILLUMINANTS_PLASA_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Built-in immutable sequence.
colour.colorimetry.datasets.illuminants.hunterlab.DATA_ILLUMINANTS_HUNTERLAB_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Built-in immutable sequence.
colour.colorimetry.datasets.illuminants.hunterlab.DATA_ILLUMINANTS_HUNTERLAB_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Illuminant_Specification_HunterLab(name, XYZ_n, K_ab)
colour.colorimetry.datasets.illuminants.hunterlab.Illuminant_Specification_HunterLab

# *CIE XYZ* tristimulus values of the *HunterLab* illuminants.
colour.colorimetry.datasets.illuminants.hunterlab.TVS_ILLUMINANTS_HUNTERLAB

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.hunterlab.TVS_ILLUMINANTS_HUNTERLAB_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.hunterlab.TVS_ILLUMINANTS_HUNTERLAB_STANDARD_OBSERVER_2_DEGREE_CIE1931

# dict() -> new empty dictionary
colour.colorimetry.datasets.illuminants.sds.DATA_ILLUMINANTS_CIE

# dict() -> new empty dictionary
colour.colorimetry.datasets.illuminants.sds.DATA_ILLUMINANTS_ISO

# Spectral distributions of the illuminants.
colour.colorimetry.datasets.illuminants.sds.SDS_ILLUMINANTS

# Spectral distributions of the *CIE* illuminants.
colour.colorimetry.datasets.illuminants.sds.SDS_ILLUMINANTS_CIE

# Spectral distributions of the *ISO* illuminants.
colour.colorimetry.datasets.illuminants.sds.SDS_ILLUMINANTS_ISO

# dict() -> new empty dictionary
colour.colorimetry.datasets.illuminants.sds_d_illuminant_series.DATA_BASIS_FUNCTIONS_CIE_ILLUMINANT_D_SERIES

# *CIE Illuminant D Series* :math:`S_n(\lambda)` spectral distributions.
colour.colorimetry.datasets.illuminants.sds_d_illuminant_series.SDS_BASIS_FUNCTIONS_CIE_ILLUMINANT_D_SERIES

# *CIE XYZ* tristimulus values of the illuminants.
colour.colorimetry.datasets.illuminants.tristimulus_values.TVS_ILLUMINANTS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.tristimulus_values.TVS_ILLUMINANTS_CIE_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.illuminants.tristimulus_values.TVS_ILLUMINANTS_CIE_STANDARD_OBSERVER_2_DEGREE_CIE1931

# dict() -> new empty dictionary
colour.colorimetry.datasets.lefs.DATA_LEFS_PHOTOPIC

# dict() -> new empty dictionary
colour.colorimetry.datasets.lefs.DATA_LEFS_SCOTOPIC

# dict() -> new empty dictionary
colour.colorimetry.datasets.lefs.DATA_MESOPIC_X

# Spectral distributions of the luminous efficiency functions.
colour.colorimetry.datasets.lefs.SDS_LEFS

# Spectral distributions of the photopic luminous efficiency functions.
colour.colorimetry.datasets.lefs.SDS_LEFS_PHOTOPIC

# Spectral distributions of the scotopic luminous efficiency functions.
colour.colorimetry.datasets.lefs.SDS_LEFS_SCOTOPIC

# Chromaticity coordinates of the light sources.
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_COMMON_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_COMMON_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_NIST_LED_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_NIST_LED_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_NIST_PHILIPS_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_NIST_PHILIPS_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_NIST_TRADITIONAL_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_NIST_TRADITIONAL_STANDARD_OBSERVER_2_DEGREE_CIE1931

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_RIT_STANDARD_OBSERVER_10_DEGREE_CIE1964

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.colorimetry.datasets.light_sources.chromaticity_coordinates.CCS_LIGHT_SOURCES_RIT_STANDARD_OBSERVER_2_DEGREE_CIE1931

# dict() -> new empty dictionary
colour.colorimetry.datasets.light_sources.sds.DATA_LIGHT_SOURCES_COMMON

# dict() -> new empty dictionary
colour.colorimetry.datasets.light_sources.sds.DATA_LIGHT_SOURCES_NIST_LED

# dict() -> new empty dictionary
colour.colorimetry.datasets.light_sources.sds.DATA_LIGHT_SOURCES_NIST_PHILIPS

# dict() -> new empty dictionary
colour.colorimetry.datasets.light_sources.sds.DATA_LIGHT_SOURCES_NIST_TRADITIONAL

# dict() -> new empty dictionary
colour.colorimetry.datasets.light_sources.sds.DATA_LIGHT_SOURCES_RIT

# Spectral distributions of the light sources.
colour.colorimetry.datasets.light_sources.sds.SDS_LIGHT_SOURCES

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.colorimetry.datasets.light_sources.sds.SDS_LIGHT_SOURCES_COMMON

# Spectral distributions of the LED light sources from the *NIST*
colour.colorimetry.datasets.light_sources.sds.SDS_LIGHT_SOURCES_NIST_LED

# Spectral distributions of the Philips light sources from the *NIST*
colour.colorimetry.datasets.light_sources.sds.SDS_LIGHT_SOURCES_NIST_PHILIPS

# Spectral distributions of the traditional light sources from the *NIST*
colour.colorimetry.datasets.light_sources.sds.SDS_LIGHT_SOURCES_NIST_TRADITIONAL

# Spectral distributions of the light sources from the *RIT* *PointerData.xls*
colour.colorimetry.datasets.light_sources.sds.SDS_LIGHT_SOURCES_RIT

# Return the coordinates and closest spectral locus wavelength index to the
colour.colorimetry.dominant.closest_spectral_locus_wavelength

# Return the *colorimetric purity* :math:`P_c` for given colour stimulus
colour.colorimetry.dominant.colorimetric_purity

# Return the *complementary wavelength* :math:`\lambda_c` for given colour
colour.colorimetry.dominant.complementary_wavelength

# Return the *dominant wavelength* :math:`\lambda_d` for given colour
colour.colorimetry.dominant.dominant_wavelength

# Return the *excitation purity* :math:`P_e` for given colour stimulus
colour.colorimetry.dominant.excitation_purity

# Supported gaussian spectral distribution computation methods.
colour.colorimetry.generation.SD_GAUSSIAN_METHODS

# Supported multi *LED* spectral distribution computation methods.
colour.colorimetry.generation.SD_MULTI_LEDS_METHODS

# Supported single *LED* spectral distribution computation methods.
colour.colorimetry.generation.SD_SINGLE_LED_METHODS

# Return the multi-spectral distributions with given labels and given
colour.colorimetry.generation.msds_constant

# Return the multi-spectral distributionss with given labels and given
colour.colorimetry.generation.msds_ones

# Return the multi-spectral distributionss with given labels and given
colour.colorimetry.generation.msds_zeros

# Return a spectral distribution of given spectral shape filled with
colour.colorimetry.generation.sd_constant

# Return a gaussian spectral distribution of given spectral shape using
colour.colorimetry.generation.sd_gaussian

# Return a gaussian spectral distribution of given spectral shape at given
colour.colorimetry.generation.sd_gaussian_fwhm

# Return a gaussian spectral distribution of given spectral shape at
colour.colorimetry.generation.sd_gaussian_normal

# Return a multi *LED* spectral distribution of given spectral shape at
colour.colorimetry.generation.sd_multi_leds

# Return a multi *LED* spectral distribution of given spectral shape at
colour.colorimetry.generation.sd_multi_leds_Ohno2005

# Return a spectral distribution of given spectral shape filled with ones.
colour.colorimetry.generation.sd_ones

# Return a single *LED* spectral distribution of given spectral shape at
colour.colorimetry.generation.sd_single_led

# Return a single *LED* spectral distribution of given spectral shape at
colour.colorimetry.generation.sd_single_led_Ohno2005

# Return a spectral distribution of given spectral shape filled with zeros.
colour.colorimetry.generation.sd_zeros

# Return the daylight locus as *CIE xy* chromaticity coordinates.
colour.colorimetry.illuminants.daylight_locus_function

# Return the spectral distribution of given *CIE Illuminant D Series* using
colour.colorimetry.illuminants.sd_CIE_illuminant_D_series

# *CIE Standard Illuminant A* is intended to represent typical, domestic,
colour.colorimetry.illuminants.sd_CIE_standard_illuminant_A

# Calculate the mesopic weighting function factor :math:`V_m` at given
colour.colorimetry.lefs.mesopic_weighting_function

# Return the mesopic luminous efficiency function :math:`V_m(\lambda)` for
colour.colorimetry.lefs.sd_mesopic_luminous_efficiency_function

# Supported *Lightness* computation methods.
colour.colorimetry.lightness.LIGHTNESS_METHODS

# Return the intermediate value :math:`f(Y/Yn)` in the *Lightness*
colour.colorimetry.lightness.intermediate_lightness_function_CIE1976

# Return the *Lightness* :math:`L` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness

# Compute *Lightness* :math:`L` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness_Abebe2017

# Return the *Lightness* :math:`L^*` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness_CIE1976

# Compute *Lightness* :math:`L_{hdr}` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness_Fairchild2010

# Compute *Lightness* :math:`L_{hdr}` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness_Fairchild2011

# Return the *Lightness* :math:`L` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness_Glasser1958

# Return the *Lightness* :math:`W` of given *luminance* :math:`Y` using
colour.colorimetry.lightness.lightness_Wyszecki1963

# Supported *luminance* computation methods.
colour.colorimetry.luminance.LUMINANCE_METHODS

# Return the *luminance* :math:`Y` in the *luminance* :math:`Y`
colour.colorimetry.luminance.intermediate_luminance_function_CIE1976

# Return the *luminance* :math:`Y` of given *Lightness* :math:`L^*` or given
colour.colorimetry.luminance.luminance

# Return the *luminance* :math:`Y` of given *Munsell* value :math:`V` using
colour.colorimetry.luminance.luminance_ASTMD1535

# Compute *luminance* :math:`Y` of *Lightness* :math:`L` using
colour.colorimetry.luminance.luminance_Abebe2017

# Return the *luminance* :math:`Y` of given *Lightness* :math:`L^*` with
colour.colorimetry.luminance.luminance_CIE1976

# Compute *luminance* :math:`Y` of given *Lightness* :math:`L_{hdr}` using
colour.colorimetry.luminance.luminance_Fairchild2010

# Compute *luminance* :math:`Y` of given *Lightness* :math:`L_{hdr}` using
colour.colorimetry.luminance.luminance_Fairchild2011

# Return the *luminance* :math:`R_Y` of given *Munsell* value :math:`V`
colour.colorimetry.luminance.luminance_Newhall1943

# Return the *luminous efficacy* in :math:`lm\cdot W^{-1}` of given
colour.colorimetry.photometry.luminous_efficacy

# Return the *luminous efficiency* of given spectral distribution using
colour.colorimetry.photometry.luminous_efficiency

# Return the *luminous flux* for given spectral distribution using given
colour.colorimetry.photometry.luminous_flux

# Define the multi-spectral distributions: the base object for multi
colour.colorimetry.spectrum.MultiSpectralDistributions

# Shape for *ASTM E308-15* practise: (360, 780, 1).
colour.colorimetry.spectrum.SPECTRAL_SHAPE_DEFAULT

# Define the spectral distribution: the base object for spectral
colour.colorimetry.spectrum.SpectralDistribution

# Define the base object for spectral distribution shape.
colour.colorimetry.spectrum.SpectralShape

# Reshape given multi-spectral distributions with given spectral shape.
colour.colorimetry.spectrum.reshape_msds

# Reshape given spectral distribution with given spectral shape.
colour.colorimetry.spectrum.reshape_sd

# Convert given spectral and multi-spectral distributions to
colour.colorimetry.spectrum.sds_and_msds_to_msds

# Convert given spectral and multi-spectral distributions to a list of
colour.colorimetry.spectrum.sds_and_msds_to_sds

# Convert *Stockman & Sharpe 10 Degree Cone Fundamentals* colour matching
colour.colorimetry.transformations.LMS_10_degree_cmfs_to_XYZ_10_degree_cmfs

# Convert *Stockman & Sharpe 2 Degree Cone Fundamentals* colour matching
colour.colorimetry.transformations.LMS_2_degree_cmfs_to_XYZ_2_degree_cmfs

# Convert *Stiles & Burch 1959 10 Degree RGB CMFs* colour matching
colour.colorimetry.transformations.RGB_10_degree_cmfs_to_LMS_10_degree_cmfs

# Convert *Stiles & Burch 1959 10 Degree RGB CMFs* colour matching
colour.colorimetry.transformations.RGB_10_degree_cmfs_to_XYZ_10_degree_cmfs

# Convert *Wright & Guild 1931 2 Degree RGB CMFs* colour matching functions
colour.colorimetry.transformations.RGB_2_degree_cmfs_to_XYZ_2_degree_cmfs

# Supported multi-spectral array to *CIE XYZ* tristimulus values conversion
colour.colorimetry.tristimulus_values.MSDS_TO_XYZ_METHODS

# Supported spectral distribution to *CIE XYZ* tristimulus values conversion
colour.colorimetry.tristimulus_values.SD_TO_XYZ_METHODS

# Shape for *ASTM E308-15* practise: (360, 780, 1).
colour.colorimetry.tristimulus_values.SPECTRAL_SHAPE_ASTME308

# Adjust given table of tristimulus weighting factors to account for a
colour.colorimetry.tristimulus_values.adjust_tristimulus_weighting_factors_ASTME308

# Handle the spectral arguments of various *Colour* definitions performing
colour.colorimetry.tristimulus_values.handle_spectral_arguments

# Compute the *Lagrange Coefficients* for given interval size using practise
colour.colorimetry.tristimulus_values.lagrange_coefficients_ASTME2022

# Convert given multi-spectral distributions to *CIE XYZ* tristimulus values
colour.colorimetry.tristimulus_values.msds_to_XYZ

# Convert given multi-spectral distributions to *CIE XYZ* tristimulus values
colour.colorimetry.tristimulus_values.msds_to_XYZ_ASTME308

# Convert given multi-spectral distributions to *CIE XYZ* tristimulus values
colour.colorimetry.tristimulus_values.msds_to_XYZ_integration

# Convert given spectral distribution to *CIE XYZ* tristimulus values using
colour.colorimetry.tristimulus_values.sd_to_XYZ

# Convert given spectral distribution to *CIE XYZ* tristimulus values using
colour.colorimetry.tristimulus_values.sd_to_XYZ_ASTME308

# Convert given spectral distribution to *CIE XYZ* tristimulus values
colour.colorimetry.tristimulus_values.sd_to_XYZ_integration

# Convert given spectral distribution to *CIE XYZ* tristimulus values
colour.colorimetry.tristimulus_values.sd_to_XYZ_tristimulus_weighting_factors_ASTME308

# Return a table of tristimulus weighting factors for given colour matching
colour.colorimetry.tristimulus_values.tristimulus_weighting_factors_ASTME2022

# Convert given wavelength :math:`\lambda` to *CIE XYZ* tristimulus values
colour.colorimetry.tristimulus_values.wavelength_to_XYZ

# Compute the *spectral uniformity* (or *spectral flatness*) of given
colour.colorimetry.uniformity.spectral_uniformity

# Supported *whiteness* computation methods.
colour.colorimetry.whiteness.WHITENESS_METHODS

# Return the *whiteness* :math:`W` using given method.
colour.colorimetry.whiteness.whiteness

# Return the *whiteness* index :math:`WI` of given sample *CIE XYZ*
colour.colorimetry.whiteness.whiteness_ASTME313

# Return the *whiteness* index :math:`WI` of given sample *CIE XYZ*
colour.colorimetry.whiteness.whiteness_Berger1959

# Return the *whiteness* :math:`W` or :math:`W_{10}` and *tint* :math:`T`
colour.colorimetry.whiteness.whiteness_CIE2004

# Return the *whiteness* index :math:`W` and *tint* :math:`T` of given
colour.colorimetry.whiteness.whiteness_Ganz1979

# Return the *whiteness* index :math:`WI` of given sample *CIE L\*a\*b\**
colour.colorimetry.whiteness.whiteness_Stensby1968

# Return the *whiteness* index :math:`WI` of given sample *CIE XYZ*
colour.colorimetry.whiteness.whiteness_Taube1960

# Coefficients :math:`C_X` and :math:`C_Z` for the *ASTM E313* *yellowness* index
colour.colorimetry.yellowness.YELLOWNESS_COEFFICIENTS_ASTME313

# Supported *yellowness* computation methods.
colour.colorimetry.yellowness.YELLOWNESS_METHODS

# Return the *yellowness* :math:`W` using given method.
colour.colorimetry.yellowness.yellowness

# Return the *yellowness* index :math:`YI` of given sample *CIE XYZ*
colour.colorimetry.yellowness.yellowness_ASTMD1925

# Return the *yellowness* index :math:`YI` of given sample *CIE XYZ*
colour.colorimetry.yellowness.yellowness_ASTME313

# Return the *yellowness* index :math:`YI` of given sample *CIE XYZ*
colour.colorimetry.yellowness.yellowness_ASTME313_alternative

# int([x]) -> integer
colour.constants.cie.CONSTANT_KP_M

# int([x]) -> integer
colour.constants.cie.CONSTANT_K_M

# Convert a string or number to a floating-point number, if possible.
colour.constants.codata.CONSTANT_AVOGADRO

# Convert a string or number to a floating-point number, if possible.
colour.constants.codata.CONSTANT_BOLTZMANN

# int([x]) -> integer
colour.constants.codata.CONSTANT_LIGHT_SPEED

# Convert a string or number to a floating-point number, if possible.
colour.constants.codata.CONSTANT_PLANCK

# Double-precision floating-point number type, compatible with Python
colour.constants.common.DTYPE_FLOAT_DEFAULT

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
colour.constants.common.DTYPE_INT_DEFAULT

# Double-precision floating-point number type, compatible with Python
colour.constants.common.EPSILON

# str(object='') -> str
colour.constants.common.PATTERN_FLOATING_POINT_NUMBER

# Convert a string or number to a floating-point number, if possible.
colour.constants.common.THRESHOLD_INTEGER

# Convert a string or number to a floating-point number, if possible.
colour.constants.common.TOLERANCE_ABSOLUTE_DEFAULT

# Convert a string or number to a floating-point number, if possible.
colour.constants.common.TOLERANCE_ABSOLUTE_TESTS

# Convert a string or number to a floating-point number, if possible.
colour.constants.common.TOLERANCE_RELATIVE_DEFAULT

# Convert a string or number to a floating-point number, if possible.
colour.constants.common.TOLERANCE_RELATIVE_TESTS

# Define the base class for abstract continuous function.
colour.continuous.abstract.AbstractContinuousFunction

# Define the base class for multi-continuous signals, a container for
colour.continuous.multi_signals.MultiSignals

# Define the base class for continuous signal.
colour.continuous.signal.Signal

# Return the contrast sensitivity :math:`S` of the human eye according to
colour.contrast.barten1999.contrast_sensitivity_function_Barten1999

# Return the maximum angular size :math:`X` of the object considered using
colour.contrast.barten1999.maximum_angular_size_Barten1999

# Return the optical modulation transfer function (MTF) :math:`M_{opt}` of
colour.contrast.barten1999.optical_MTF_Barten1999

# Return the pupil diameter for given luminance and object or stimulus
colour.contrast.barten1999.pupil_diameter_Barten1999

# Return the retinal illuminance :math:`E` in Trolands for given average
colour.contrast.barten1999.retinal_illuminance_Barten1999

# Return the standard deviation :math:`\sigma` of the line-spread function
colour.contrast.barten1999.sigma_Barten1999

# dict() -> new empty dictionary
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_10_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_11_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_12_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_1_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_2_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_3_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_4_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_5_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_6_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_7_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_8_RESULTS

# Built-in immutable sequence.
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_9_RESULTS

# dict() -> new empty dictionary
colour.corresponding.datasets.breneman1987.BRENEMAN_EXPERIMENT_PRIMARIES_CHROMATICITIES

# Experiment result.
colour.corresponding.datasets.breneman1987.BrenemanExperimentResult

# Chromaticity coordinates of the primaries.
colour.corresponding.datasets.breneman1987.PrimariesChromaticityCoordinates

# Aggregated corresponding chromaticities prediction models.
colour.corresponding.prediction.CORRESPONDING_CHROMATICITIES_PREDICTION_MODELS

# Define a chromatic adaptation model prediction.
colour.corresponding.prediction.CorrespondingChromaticitiesPrediction

# Define a corresponding colour dataset.
colour.corresponding.prediction.CorrespondingColourDataset

# Convert *Breneman (1987)* experiment results to a
colour.corresponding.prediction.convert_experiment_results_Breneman1987

# Return the corresponding chromaticities prediction for given chromatic
colour.corresponding.prediction.corresponding_chromaticities_prediction

# Return the corresponding chromaticities prediction for *CIE 1994*
colour.corresponding.prediction.corresponding_chromaticities_prediction_CIE1994

# Return the corresponding chromaticities prediction for *CMCCAT2000*
colour.corresponding.prediction.corresponding_chromaticities_prediction_CMCCAT2000

# Return the corresponding chromaticities prediction for *Fairchild (1990)*
colour.corresponding.prediction.corresponding_chromaticities_prediction_Fairchild1990

# Return the corresponding chromaticities prediction for *Von Kries*
colour.corresponding.prediction.corresponding_chromaticities_prediction_VonKries

# Return the corresponding chromaticities prediction for
colour.corresponding.prediction.corresponding_chromaticities_prediction_Zhai2018

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam02_ucs.delta_E_CAM02LCD

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam02_ucs.delta_E_CAM02SCD

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam02_ucs.delta_E_CAM02UCS

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam02_ucs.delta_E_Luo2006

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam16_ucs.delta_E_CAM16LCD

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam16_ucs.delta_E_CAM16SCD

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam16_ucs.delta_E_CAM16UCS

# Return the difference :math:`\Delta E'` between two given
colour.difference.cam16_ucs.delta_E_Li2017

# Convert a string or number to a floating-point number, if possible.
colour.difference.delta_e.JND_CIE1976

# Return the difference :math:`\Delta E_{76}` between two given
colour.difference.delta_e.delta_E_CIE1976

# Return the difference :math:`\Delta E_{94}` between two given
colour.difference.delta_e.delta_E_CIE1994

# Return the difference :math:`\Delta E_{00}` between two given
colour.difference.delta_e.delta_E_CIE2000

# Return the difference :math:`\Delta E_{CMC}` between two given
colour.difference.delta_e.delta_E_CMC

# Return the difference :math:`\Delta E_{ITP}` between two given
colour.difference.delta_e.delta_E_ITP

# Return the difference :math:`\Delta E_{DIN99}` between two given
colour.difference.din99.delta_E_DIN99

# Improve the performance of the :math:`\Delta E` value for given
colour.difference.huang2015.power_function_Huang2015

# Supported :math:`STRESS` index computation methods.
colour.difference.stress.INDEX_STRESS_METHODS

# Compute the
colour.difference.stress.index_stress

# Compute the
colour.difference.stress.index_stress_Garcia2007

# Supported ellipse fitting methods.
colour.geometry.ellipse.ELLIPSE_FITTING_METHODS

# Return the canonical form ellipse coefficients from given general form
colour.geometry.ellipse.ellipse_coefficients_canonical_form

# Return the general form ellipse coefficients from given canonical form
colour.geometry.ellipse.ellipse_coefficients_general_form

# Return the coefficients of the implicit second-order polynomial/quadratic
colour.geometry.ellipse.ellipse_fitting

# Return the coefficients of the implicit second-order polynomial/quadratic
colour.geometry.ellipse.ellipse_fitting_Halir1998

# Return the coordinates of the point at angle :math:`\phi` in degrees on
colour.geometry.ellipse.point_at_angle_on_ellipse

# Define the specification for intersection of line segments :math:`l_1` and
colour.geometry.intersection.LineSegmentsIntersections_Specification

# Extend the line segment defined by point arrays :math:`a` and :math:`b` by
colour.geometry.intersection.extend_line_segment

# Compute :math:`l_1` line segments intersections with :math:`l_2` line
colour.geometry.intersection.intersect_line_segments

# Plane to axis mapping.
colour.geometry.primitives.MAPPING_PLANE_TO_AXIS

# Supported geometry primitive generation methods.
colour.geometry.primitives.PRIMITIVE_METHODS

# Return a geometry primitive using given method.
colour.geometry.primitives.primitive

# Generate vertices and indexes for a filled and outlined cube primitive.
colour.geometry.primitives.primitive_cube

# Generate vertices and indexes for a filled and outlined grid primitive.
colour.geometry.primitives.primitive_grid

# Close the chord.
colour.geometry.section.close_chord

# Convert given edges to a chord, starting at given index.
colour.geometry.section.edges_to_chord

# Compute the hull section for given axis at given origin.
colour.geometry.section.hull_section

# Return the unique vertices from given vertices.
colour.geometry.section.unique_vertices

# Supported geometry primitive vertices generation methods.
colour.geometry.vertices.PRIMITIVE_VERTICES_METHODS

# Return the vertices of a geometry primitive using given method.
colour.geometry.vertices.primitive_vertices

# Return the vertices of a cube primitive made of grid primitives for use
colour.geometry.vertices.primitive_vertices_cube_mpl

# Return the vertices of a grid primitive made of quad primitives for use
colour.geometry.vertices.primitive_vertices_grid_mpl

# Return the vertices of a quad primitive for use with *Matplotlib*
colour.geometry.vertices.primitive_vertices_quad_mpl

# Return the vertices of a latitude-longitude sphere primitive.
colour.geometry.vertices.primitive_vertices_sphere

# Convert from *CAM16* specification to *CAM16* :math:`JMh` correlates.
colour.graph.conversion.CAM16_to_JMh_CAM16

# Convert given correlated colour temperature :math:`T_{cp}` and
colour.graph.conversion.CCT_D_uv_to_mired

# Convert from *CIECAM02* specification to *CIECAM02* :math:`JMh`
colour.graph.conversion.CIECAM02_to_JMh_CIECAM02

# The type of the None singleton.
colour.graph.conversion.CONVERSION_GRAPH

# dict() -> new empty dictionary
colour.graph.conversion.CONVERSION_GRAPH_NODE_LABELS

# Built-in mutable sequence.
colour.graph.conversion.CONVERSION_SPECIFICATIONS

# Built-in mutable sequence.
colour.graph.conversion.CONVERSION_SPECIFICATIONS_DATA

# Conversion specification for *Colour* graph for automatic colour
colour.graph.conversion.Conversion_Specification

# Convert from *Hellwig and Fairchild (2022)* specification to
colour.graph.conversion.Hellwig2022_to_JMh_Hellwig2022

# Convert from *CAM6* :math:`JMh` correlates to *CAM6* specification.
colour.graph.conversion.JMh_CAM16_to_CAM16

# Convert from *CIECAM02* :math:`JMh` correlates to *CIECAM02*
colour.graph.conversion.JMh_CIECAM02_to_CIECAM02

# Convert from *Hellwig and Fairchild (2022)* :math:`JMh` correlates to
colour.graph.conversion.JMh_Hellwig2022_to_Hellwig2022

# Convert from *luminance* :math:`Y` to *RGB*.
colour.graph.conversion.RGB_luminance_to_RGB

# Convert from *CIE XYZ* tristimulus values to *luminance* :math:`Y`.
colour.graph.conversion.XYZ_to_luminance

# Convert given object :math:`a` from source colour representation to target
colour.graph.conversion.convert

# Describe the conversion path from source colour representation to target
colour.graph.conversion.describe_conversion_path

# Convert given micro reciprocal degree (mired) to correlated colour
colour.graph.conversion.mired_to_CCT_D_uv

# Built-in immutable sequence.
colour.io.ctl.ARGUMENTS_CTL_RENDER_DEFAULTS

# str(object='') -> str
colour.io.ctl.EXECUTABLE_CTL_RENDER

# Call *ctlrender* on given input image using given *CTL* transforms.
colour.io.ctl.ctl_render

# Process given image data with *ctlrender* using given *CTL* transforms.
colour.io.ctl.process_image_ctl

# Generate the code for a *CTL* transform to test a function processing
colour.io.ctl.template_ctl_transform_float

# Generate the code for a *CTL* transform to test a function processing
colour.io.ctl.template_ctl_transform_float3

colour.io.fichet2021.ComponentsFichet2021

# dict() -> new empty dictionary
colour.io.fichet2021.MAPPING_UNIT_CONVERSION

# str(object='') -> str
colour.io.fichet2021.PATTERN_FICHET2021

# Define the *Fichet et al. (2021)* spectral image specification.
colour.io.fichet2021.Specification_Fichet2021

# Convert given *Fichet et al. (2021)* components to *sRGB* colourspace values.
colour.io.fichet2021.components_to_sRGB_Fichet2021

# Convert match groups of a wavelength (or frequency) to the nanometer value.
colour.io.fichet2021.match_groups_to_nm

# Read the *Fichet et al. (2021)* spectral image at given path using
colour.io.fichet2021.read_spectral_image_Fichet2021

# Convert a spectral distribution to a spectrum attribute value according to
colour.io.fichet2021.sd_to_spectrum_attribute_Fichet2021

# Convert given spectral and multi-spectral distributions to
colour.io.fichet2021.sds_and_msds_to_components_Fichet2021

# Convert a spectrum attribute value to a spectral distribution according to
colour.io.fichet2021.spectrum_attribute_to_sd_Fichet2021

# Write given *Fichet et al. (2021)* components to given path using *OpenImageIO*.
colour.io.fichet2021.write_spectral_image_Fichet2021

# Define an image specification attribute.
colour.io.image.Image_Specification_Attribute

# Define a bit-depth specification.
colour.io.image.Image_Specification_BitDepth

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.io.image.MAPPING_BIT_DEPTH

# Supported image read methods.
colour.io.image.READ_IMAGE_METHODS

# Supported image write methods.
colour.io.image.WRITE_IMAGE_METHODS

# Add given attributes to given *OpenImageIO* image specification.
colour.io.image.add_attributes_to_image_specification_OpenImageIO

# Convert given array :math:`a` to a 3-channels image-like representation.
colour.io.image.as_3_channels_image

# Convert given array to given bit-depth, the current bit-depth of the array
colour.io.image.convert_bit_depth

# Create an *OpenImageIO* image specification.
colour.io.image.image_specification_OpenImageIO

# Read the image data at given path using given method.
colour.io.image.read_image

# Read the image data at given path using *Imageio*.
colour.io.image.read_image_Imageio

# Read the image data at given path using *OpenImageIO*.
colour.io.image.read_image_OpenImageIO

# Write given image data at given path using given method.
colour.io.image.write_image

# Write given image data at given path using *Imageio*.
colour.io.image.write_image_Imageio

# Write given image data at given path using *OpenImageIO*.
colour.io.image.write_image_OpenImageIO

# Read given *Cinespace* *.csp* *LUT* file.
colour.io.luts.cinespace_csp.read_LUT_Cinespace

# Write given *LUT* to given  *Cinespace* *.csp* *LUT* file.
colour.io.luts.cinespace_csp.write_LUT_Cinespace

# Convert given file path to title.
colour.io.luts.common.path_to_title

# Read given *Iridas* *.cube* *LUT* file.
colour.io.luts.iridas_cube.read_LUT_IridasCube

# Write given *LUT* to given  *Iridas* *.cube* *LUT* file.
colour.io.luts.iridas_cube.write_LUT_IridasCube

# Define the base class for *LUT*.
colour.io.luts.lut.AbstractLUT

# Define the base class for a 1D *LUT*.
colour.io.luts.lut.LUT1D

# Define the base class for a 3D *LUT*.
colour.io.luts.lut.LUT3D

# Define the base class for a 3x1D *LUT*.
colour.io.luts.lut.LUT3x1D

# Convert given *LUT* to given ``cls`` class instance.
colour.io.luts.lut.LUT_to_LUT

# Define the base class for *LUT* sequence operators.
colour.io.luts.operator.AbstractLUTSequenceOperator

# Define the *LUT* operator supporting a 3x3 or 4x4 matrix and an offset
colour.io.luts.operator.LUTOperatorMatrix

# Read given *Resolve* *.cube* *LUT* file.
colour.io.luts.resolve_cube.read_LUT_ResolveCube

# Write given *LUT* to given  *Resolve* *.cube* *LUT* file.
colour.io.luts.resolve_cube.write_LUT_ResolveCube

# Define the base class for a *LUT* sequence, i.e., a series of *LUTs*,
colour.io.luts.sequence.LUTSequence

# Read given *Sony* *.spi1d* *LUT* file.
colour.io.luts.sony_spi1d.read_LUT_SonySPI1D

# Write given *LUT* to given *Sony* *.spi1d* *LUT* file.
colour.io.luts.sony_spi1d.write_LUT_SonySPI1D

# Read given *Sony* *.spi3d* *LUT* file.
colour.io.luts.sony_spi3d.read_LUT_SonySPI3D

# Write given *LUT* to given *Sony* *.spi3d* *LUT* file.
colour.io.luts.sony_spi3d.write_LUT_SonySPI3D

# Read given *Sony* *.spimtx* *LUT* file.
colour.io.luts.sony_spimtx.read_LUT_SonySPImtx

# Write given *LUT* to given *Sony* *.spimtx* *LUT* file.
colour.io.luts.sony_spimtx.write_LUT_SonySPImtx

# Process given image data with *OpenColorIO*.
colour.io.ocio.process_image_OpenColorIO

# Read the spectral data from given *CSV* file and returns its content as a
colour.io.tabular.read_sds_from_csv_file

# Read the spectral data from given *CSV* file in the following form::
colour.io.tabular.read_spectral_data_from_csv_file

# Write the given spectral distributions to given *CSV* file.
colour.io.tabular.write_sds_to_csv_file

# *IES TM-27-14* spectral data *XML* file element specification.
colour.io.tm2714.Element_Specification_IESTM2714

# Define the header object for a *IES TM-27-14* spectral distribution.
colour.io.tm2714.Header_IESTM2714

# str(object='') -> str
colour.io.tm2714.NAMESPACE_IESTM2714

# Define a *IES TM-27-14* spectral distribution.
colour.io.tm2714.SpectralDistribution_IESTM2714

# str(object='') -> str
colour.io.tm2714.VERSION_IESTM2714

# Implement support to read and write *IES TM-27-14* spectral data XML file
colour.io.uprtek_sekonic.SpectralDistribution_Sekonic

# Implement support to read and write *IES TM-27-14* spectral data XML file
colour.io.uprtek_sekonic.SpectralDistribution_UPRTek

# str(object='') -> str
colour.io.xrite.XRITE_FILE_ENCODING

# Read the spectral data from given *X-Rite* file and returns it as a
colour.io.xrite.read_sds_from_xrite_file

# Convert from *Luo et al. (2006)* *CAM02-LCD* colourspace :math:`J'a'b'`
colour.models.cam02_ucs.CAM02LCD_to_JMh_CIECAM02

# Convert from *Luo et al. (2006)* *CAM02-LCD* colourspace :math:`J'a'b'`
colour.models.cam02_ucs.CAM02LCD_to_XYZ

# Convert from *Luo et al. (2006)* *CAM02-SCD* colourspace :math:`J'a'b'`
colour.models.cam02_ucs.CAM02SCD_to_JMh_CIECAM02

# Convert from *Luo et al. (2006)* *CAM02-SCD* colourspace :math:`J'a'b'`
colour.models.cam02_ucs.CAM02SCD_to_XYZ

# Convert from *Luo et al. (2006)* *CAM02-UCS* colourspace :math:`J'a'b'`
colour.models.cam02_ucs.CAM02UCS_to_JMh_CIECAM02

# Convert from *Luo et al. (2006)* *CAM02-UCS* colourspace :math:`J'a'b'`
colour.models.cam02_ucs.CAM02UCS_to_XYZ

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.cam02_ucs.COEFFICIENTS_UCS_LUO2006

# Define the class storing *Luo et al. (2006)* fitting coefficients for
colour.models.cam02_ucs.Coefficients_UCS_Luo2006

# Convert from *CIECAM02* :math:`JMh` correlates array to
colour.models.cam02_ucs.JMh_CIECAM02_to_CAM02LCD

# Convert from *CIECAM02* :math:`JMh` correlates array to
colour.models.cam02_ucs.JMh_CIECAM02_to_CAM02SCD

# Convert from *CIECAM02* :math:`JMh` correlates array to
colour.models.cam02_ucs.JMh_CIECAM02_to_CAM02UCS

# Convert from *CIECAM02* :math:`JMh` correlates array to one of the
colour.models.cam02_ucs.JMh_CIECAM02_to_UCS_Luo2006

# Convert from one of the *Luo et al. (2006)* *CAM02-LCD*, *CAM02-SCD*, or
colour.models.cam02_ucs.UCS_Luo2006_to_JMh_CIECAM02

# Convert from one of the *Luo et al. (2006)* *CAM02-LCD*, *CAM02-SCD*, or
colour.models.cam02_ucs.UCS_Luo2006_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *Luo et al. (2006)*
colour.models.cam02_ucs.XYZ_to_CAM02LCD

# Convert from *CIE XYZ* tristimulus values to *Luo et al. (2006)*
colour.models.cam02_ucs.XYZ_to_CAM02SCD

# Convert from *CIE XYZ* tristimulus values to *Luo et al. (2006)*
colour.models.cam02_ucs.XYZ_to_CAM02UCS

# Convert from *CIE XYZ* tristimulus values to one of the
colour.models.cam02_ucs.XYZ_to_UCS_Luo2006

# Convert from *Li et al. (2017)* *CAM16-LCD* colourspace :math:`J'a'b'`
colour.models.cam16_ucs.CAM16LCD_to_JMh_CAM16

# Convert from *Li et al. (2017)* *CAM16-LCD* colourspace :math:`J'a'b'`
colour.models.cam16_ucs.CAM16LCD_to_XYZ

# Convert from *Li et al. (2017)* *CAM16-SCD* colourspace :math:`J'a'b'`
colour.models.cam16_ucs.CAM16SCD_to_JMh_CAM16

# Convert from *Li et al. (2017)* *CAM16-SCD* colourspace :math:`J'a'b'`
colour.models.cam16_ucs.CAM16SCD_to_XYZ

# Convert from *Li et al. (2017)* *CAM16-UCS* colourspace :math:`J'a'b'`
colour.models.cam16_ucs.CAM16UCS_to_JMh_CAM16

# Convert from *Li et al. (2017)* *CAM16-UCS* colourspace :math:`J'a'b'`
colour.models.cam16_ucs.CAM16UCS_to_XYZ

# Convert from *CAM16* :math:`JMh` correlates array to
colour.models.cam16_ucs.JMh_CAM16_to_CAM16LCD

# Convert from *CAM16* :math:`JMh` correlates array to
colour.models.cam16_ucs.JMh_CAM16_to_CAM16SCD

# Convert from *CAM16* :math:`JMh` correlates array to
colour.models.cam16_ucs.JMh_CAM16_to_CAM16UCS

# Convert from *CAM16* :math:`JMh` correlates array to one of the
colour.models.cam16_ucs.JMh_CAM16_to_UCS_Li2017

# Convert from one of the *Li et al. (2017)* *CAM16-LCD*, *CAM16-SCD*, or
colour.models.cam16_ucs.UCS_Li2017_to_JMh_CAM16

# Convert from one of the *Li et al. (2017)* *CAM16-LCD*, *CAM16-SCD*, or
colour.models.cam16_ucs.UCS_Li2017_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *Li et al. (2017)*
colour.models.cam16_ucs.XYZ_to_CAM16LCD

# Convert from *CIE XYZ* tristimulus values to *Li et al. (2017)*
colour.models.cam16_ucs.XYZ_to_CAM16SCD

# Convert from *CIE XYZ* tristimulus values to *Li et al. (2017)*
colour.models.cam16_ucs.XYZ_to_CAM16UCS

# Convert from *CIE XYZ* tristimulus values to one of the *Li et al. (2017)*
colour.models.cam16_ucs.XYZ_to_UCS_Li2017

# Convert from *CIE L\*a\*b\** colourspace to *CIE XYZ* tristimulus
colour.models.cie_lab.Lab_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *CIE L\*a\*b\**
colour.models.cie_lab.XYZ_to_Lab

# Convert from *CIE XYZ* tristimulus values to :math:`uv^pL\*` colourspace.
colour.models.cie_luv.CIE1976UCS_to_XYZ

# Convert from *CIE L\*u\*v\** colourspace to *CIE XYZ* tristimulus
colour.models.cie_luv.Luv_to_XYZ

# Return the :math:`uv^p` chromaticity coordinates from given
colour.models.cie_luv.Luv_to_uv

# Return the *CIE xy* chromaticity coordinates from given *CIE L\*u\*v\**
colour.models.cie_luv.Luv_uv_to_xy

# Convert from *CIE XYZ* tristimulus values to :math:`uv^pL\*` colourspace.
colour.models.cie_luv.XYZ_to_CIE1976UCS

# Convert from *CIE XYZ* tristimulus values to *CIE L\*u\*v\**
colour.models.cie_luv.XYZ_to_Luv

# Return the *CIE L\*u\*v\** colourspace array from given :math:`uv^p`
colour.models.cie_luv.uv_to_Luv

# Return the *CIE L\*u\*v\** colourspace :math:`uv^p` chromaticity
colour.models.cie_luv.xy_to_Luv_uv

# Convert from *CIE XYZ* tristimulus values to :math:`uvV` colourspace.
colour.models.cie_ucs.CIE1960UCS_to_XYZ

# Convert from *CIE 1960 UCS* :math:`UVW` colourspace to *CIE XYZ* tristimulus
colour.models.cie_ucs.UCS_to_XYZ

# Return the *uv* chromaticity coordinates from given *CIE 1960 UCS*
colour.models.cie_ucs.UCS_to_uv

# Return the *CIE xy* chromaticity coordinates from given *CIE 1960 UCS*
colour.models.cie_ucs.UCS_uv_to_xy

# Convert from *CIE XYZ* tristimulus values to :math:`uvV` colourspace.
colour.models.cie_ucs.XYZ_to_CIE1960UCS

# Convert from *CIE XYZ* tristimulus values to *CIE 1960 UCS* :math:`UVW`
colour.models.cie_ucs.XYZ_to_UCS

# Return the *CIE 1960 UCS* :math:`UVW` colourspace array from given *uv*
colour.models.cie_ucs.uv_to_UCS

# Return the *CIE 1960 UCS* :math:`UVW` colourspace *uv* chromaticity
colour.models.cie_ucs.xy_to_UCS_uv

# Convert *CIE 1964 U\*V\*W\** colourspace to *CIE XYZ* tristimulus
colour.models.cie_uvw.UVW_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *CIE 1964 U\*V\*W\**
colour.models.cie_uvw.XYZ_to_UVW

# Return the *CIE xy* chromaticity coordinates from given *CIE XYZ*
colour.models.cie_xyy.XYZ_to_xy

# Convert from *CIE XYZ* tristimulus values to *CIE xyY* colourspace.
colour.models.cie_xyy.XYZ_to_xyY

# Convert from *CIE xyY* colourspace to *CIE XYZ* tristimulus values.
colour.models.cie_xyy.xyY_to_XYZ

# Convert from *CIE xyY* colourspace to *CIE xy* chromaticity coordinates.
colour.models.cie_xyy.xyY_to_xy

# Return the *CIE XYZ* tristimulus values from given *CIE xy* chromaticity
colour.models.cie_xyy.xy_to_XYZ

# Convert from *CIE xy* chromaticity coordinates to *CIE xyY* colourspace by
colour.models.cie_xyy.xy_to_xyY

# Built-in immutable sequence.
colour.models.common.COLOURSPACE_MODELS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.common.COLOURSPACE_MODELS_AXIS_LABELS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.common.COLOURSPACE_MODELS_DOMAIN_RANGE_SCALE_1_TO_REFERENCE

# Convert from *IPT*-like :math:`Iab` colour representation to *CIE XYZ*
colour.models.common.Iab_to_XYZ

# Convert from *JCh* colour representation to *Jab* colour representation.
colour.models.common.JCh_to_Jab

# Convert from *Jab* colour representation to *JCh* colour representation.
colour.models.common.Jab_to_JCh

# Convert from *CIE XYZ* tristimulus values to *IPT*-like :math:`Iab` colour
colour.models.common.XYZ_to_Iab

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.datasets.macadam_ellipses.DATA_MACADAM_1942_ELLIPSES

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.datasets.pointer_gamut.CCS_ILLUMINANT_POINTER_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.datasets.pointer_gamut.CCS_POINTER_GAMUT_BOUNDARY

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.datasets.pointer_gamut.DATA_POINTER_GAMUT_VOLUME

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.din99.DIN99_METHODS

# Convert from *DIN99* colourspace or one of the *DIN99b*, *DIN99c*,
colour.models.din99.DIN99_to_Lab

# Convert from *DIN99* colourspace or one of the *DIN99b*, *DIN99c*,
colour.models.din99.DIN99_to_XYZ

# Convert from *CIE L\*a\*b\** colourspace to *DIN99* colourspace or
colour.models.din99.Lab_to_DIN99

# Convert from *CIE XYZ* tristimulus values to *DIN99* colourspace or
colour.models.din99.XYZ_to_DIN99

# Built-in immutable sequence.
colour.models.hdr_cie_lab.HDR_CIELAB_METHODS

# Convert from *CIE XYZ* tristimulus values to *hdr-CIELAB* colourspace.
colour.models.hdr_cie_lab.XYZ_to_hdr_CIELab

# Compute *hdr-CIELAB* colourspace *Lightness* :math:`\epsilon` exponent
colour.models.hdr_cie_lab.exponent_hdr_CIELab

# Convert from *hdr-CIELAB* colourspace to *CIE XYZ* tristimulus values.
colour.models.hdr_cie_lab.hdr_CIELab_to_XYZ

# Built-in immutable sequence.
colour.models.hdr_ipt.HDR_IPT_METHODS

# Convert from *CIE XYZ* tristimulus values to *hdr-IPT* colourspace.
colour.models.hdr_ipt.XYZ_to_hdr_IPT

# Compute *hdr-IPT* colourspace *Lightness* :math:`\epsilon` exponent using
colour.models.hdr_ipt.exponent_hdr_IPT

# Convert from *hdr-IPT* colourspace to *CIE XYZ* tristimulus values.
colour.models.hdr_ipt.hdr_IPT_to_XYZ

# Convert from *Hunter L,a,b* colour scale to *CIE XYZ* tristimulus values.
colour.models.hunter_lab.Hunter_Lab_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *Hunter L,a,b* colour scale.
colour.models.hunter_lab.XYZ_to_Hunter_Lab

# Convert from *whitepoint* *CIE XYZ* tristimulus values to
colour.models.hunter_lab.XYZ_to_K_ab_HunterLab1966

# Convert from *Hunter Rd,a,b* colour scale to *CIE XYZ* tristimulus values.
colour.models.hunter_rdab.Hunter_Rdab_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *Hunter Rd,a,b* colour scale.
colour.models.hunter_rdab.XYZ_to_Hunter_Rdab

# Convert from :math:`IC_AC_B` tristimulus values to *CIE XYZ* colourspace.
colour.models.icacb.ICaCb_to_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.icacb.MATRIX_ICACB_LMS_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.icacb.MATRIX_ICACB_LMS_TO_XYZ_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.icacb.MATRIX_ICACB_XYZ_TO_LMS

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.icacb.MATRIX_ICACB_XYZ_TO_LMS_2

# Convert from *CIE XYZ* tristimulus values to :math:`IC_AC_B` colourspace.
colour.models.icacb.XYZ_to_ICaCb

# Convert from :math:`I_GP_GT_G` colourspace to *CIE XYZ* tristimulus
colour.models.igpgtg.IgPgTg_to_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.igpgtg.MATRIX_IGPGTG_IGPGTG_TO_LMS_P

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.igpgtg.MATRIX_IGPGTG_LMS_P_TO_IGPGTG

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.igpgtg.MATRIX_IGPGTG_LMS_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.igpgtg.MATRIX_IGPGTG_XYZ_TO_LMS

# Convert from *CIE XYZ* tristimulus values to :math:`I_GP_GT_G`
colour.models.igpgtg.XYZ_to_IgPgTg

# Compute the hue angle in degrees from *IPT* colourspace.
colour.models.ipt.IPT_hue_angle

# Convert from *IPT* colourspace to *CIE XYZ* tristimulus values.
colour.models.ipt.IPT_to_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ipt.MATRIX_IPT_IPT_TO_LMS_P

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ipt.MATRIX_IPT_LMS_P_TO_IPT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ipt.MATRIX_IPT_LMS_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ipt.MATRIX_IPT_XYZ_TO_LMS

# Convert from *CIE XYZ* tristimulus values to *IPT* colourspace.
colour.models.ipt.XYZ_to_IPT

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.jzazbz.CONSTANTS_JZAZBZ_SAFDAR2017

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.jzazbz.CONSTANTS_JZAZBZ_SAFDAR2021

# Built-in immutable sequence.
colour.models.jzazbz.IZAZBZ_METHODS

# Convert from :math:`I_za_zb_z` colourspace to *CIE XYZ* tristimulus
colour.models.jzazbz.Izazbz_to_XYZ

# Convert from :math:`J_za_zb_z` colourspace to *CIE XYZ* tristimulus
colour.models.jzazbz.Jzazbz_to_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.jzazbz.MATRIX_JZAZBZ_IZAZBZ_TO_LMS_P_SAFDAR2017

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.jzazbz.MATRIX_JZAZBZ_IZAZBZ_TO_LMS_P_SAFDAR2021

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.jzazbz.MATRIX_JZAZBZ_LMS_P_TO_IZAZBZ_SAFDAR2017

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.jzazbz.MATRIX_JZAZBZ_LMS_P_TO_IZAZBZ_SAFDAR2021

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.jzazbz.MATRIX_JZAZBZ_LMS_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.jzazbz.MATRIX_JZAZBZ_XYZ_TO_LMS

# Convert from *CIE XYZ* tristimulus values to :math:`I_za_zb_z`
colour.models.jzazbz.XYZ_to_Izazbz

# Convert from *CIE XYZ* tristimulus values to :math:`J_za_zb_z`
colour.models.jzazbz.XYZ_to_Jzazbz

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.oklab.MATRIX_1_LMS_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.oklab.MATRIX_1_XYZ_TO_LMS

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.oklab.MATRIX_2_LAB_TO_LMS

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.oklab.MATRIX_2_LMS_TO_LAB

# Convert from *Oklab* colourspace to *CIE XYZ* tristimulus values.
colour.models.oklab.Oklab_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *Oklab* colourspace.
colour.models.oklab.XYZ_to_Oklab

# Convert from *OSA UCS* colourspace to *CIE XYZ* tristimulus values under
colour.models.osa_ucs.OSA_UCS_to_XYZ

# Convert from *CIE XYZ* tristimulus values under the
colour.models.osa_ucs.XYZ_to_OSA_UCS

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.prolab.MATRIX_INVERSE_Q

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.prolab.MATRIX_Q

# Convert from *ProLab* colourspace to *CIE XYZ* tristimulus values.
colour.models.prolab.ProLab_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *ProLab* colourspace.
colour.models.prolab.XYZ_to_ProLab

# Convert from *Ragoo and Farup (2021)* *Optimised IPT* colourspace to
colour.models.ragoo2021.IPT_Ragoo2021_to_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ragoo2021.MATRIX_IPT_IPT_TO_LMS_P

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ragoo2021.MATRIX_IPT_LMS_P_TO_IPT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ragoo2021.MATRIX_IPT_LMS_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.ragoo2021.MATRIX_IPT_XYZ_TO_LMS

# Convert from *CIE XYZ* tristimulus values to
colour.models.ragoo2021.XYZ_to_IPT_Ragoo2021

# Convert from *CMYK* colourspace to *CMY* colourspace.
colour.models.rgb.cmyk.CMYK_to_CMY

# Convert from *CMY* colourspace to *CMYK* colourspace.
colour.models.rgb.cmyk.CMY_to_CMYK

# Convert from *CMY* colourspace to *CMY* colourspace.
colour.models.rgb.cmyk.CMY_to_RGB

# Convert from *RGB* colourspace to *CMY* colourspace.
colour.models.rgb.cmyk.RGB_to_CMY

# Convert from *CIE XYZ* tristimulus values to *sRGB* colourspace.
colour.models.rgb.common.XYZ_to_sRGB

# Convert from *sRGB* colourspace to *CIE XYZ* tristimulus values.
colour.models.rgb.common.sRGB_to_XYZ

# Convert from *HCL* colourspace to *RGB* colourspace according to
colour.models.rgb.cylindrical.HCL_to_RGB

# Convert from *HSL* colourspace to *RGB* colourspace.
colour.models.rgb.cylindrical.HSL_to_RGB

# Convert from *HSV* colourspace to *RGB* colourspace.
colour.models.rgb.cylindrical.HSV_to_RGB

# Convert from *RGB* colourspace to *HCL* colourspace according to
colour.models.rgb.cylindrical.RGB_to_HCL

# Convert from *RGB* colourspace to *HSL* colourspace.
colour.models.rgb.cylindrical.RGB_to_HSL

# Convert from *RGB* colourspace to *HSV* colourspace.
colour.models.rgb.cylindrical.RGB_to_HSV

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.AP0

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.AP1

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.CCS_WHITEPOINT_ACES

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.MATRIX_AP0_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.MATRIX_AP1_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.MATRIX_XYZ_TO_AP0

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.aces.MATRIX_XYZ_TO_AP1

# *ACES2065-1* colourspace, base encoding, used for exchange of full fidelity
colour.models.rgb.datasets.aces.RGB_COLOURSPACE_ACES2065_1

# *ACEScc* colourspace, a working space for color correctors, target for ASC-CDL
colour.models.rgb.datasets.aces.RGB_COLOURSPACE_ACESCC

# *ACEScct* colourspace, an alternative working space for colour correctors,
colour.models.rgb.datasets.aces.RGB_COLOURSPACE_ACESCCT

# *ACEScg* colourspace, a working space for paint/compositor applications that
colour.models.rgb.datasets.aces.RGB_COLOURSPACE_ACESCG

# *ACESproxy* colourspace, a lightweight encoding for transmission over HD-SDI
colour.models.rgb.datasets.aces.RGB_COLOURSPACE_ACESPROXY

# str(object='') -> str
colour.models.rgb.datasets.aces.WHITEPOINT_NAME_ACES

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_rgb_1998.CCS_WHITEPOINT_ADOBE_RGB1998

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_rgb_1998.MATRIX_ADOBE_RGB1998_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_rgb_1998.MATRIX_XYZ_TO_ADOBE_RGB1998

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_rgb_1998.PRIMARIES_ADOBE_RGB1998

# *Adobe RGB (1998)* colourspace.
colour.models.rgb.datasets.adobe_rgb_1998.RGB_COLOURSPACE_ADOBE_RGB1998

# str(object='') -> str
colour.models.rgb.datasets.adobe_rgb_1998.WHITEPOINT_NAME_ADOBE_RGB1998

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_wide_gamut_rgb.CCS_WHITEPOINT_ADOBE_WIDE_GAMUT_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_wide_gamut_rgb.MATRIX_ADOBE_WIDE_GAMUT_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_wide_gamut_rgb.MATRIX_XYZ_TO_ADOBE_WIDE_GAMUT_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.adobe_wide_gamut_rgb.PRIMARIES_ADOBE_WIDE_GAMUT_RGB

# *Adobe Wide Gamut RGB* colourspace.
colour.models.rgb.datasets.adobe_wide_gamut_rgb.RGB_COLOURSPACE_ADOBE_WIDE_GAMUT_RGB

# str(object='') -> str
colour.models.rgb.datasets.adobe_wide_gamut_rgb.WHITEPOINT_NAME_ADOBE_WIDE_GAMUT_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.apple_rgb.CCS_WHITEPOINT_APPLE_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.apple_rgb.MATRIX_APPLE_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.apple_rgb.MATRIX_XYZ_TO_APPLE_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.apple_rgb.PRIMARIES_APPLE_RGB

# *Apple RGB* colourspace.
colour.models.rgb.datasets.apple_rgb.RGB_COLOURSPACE_APPLE_RGB

# str(object='') -> str
colour.models.rgb.datasets.apple_rgb.WHITEPOINT_NAME_APPLE_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.CCS_WHITEPOINT_ARRI_WIDE_GAMUT_3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.CCS_WHITEPOINT_ARRI_WIDE_GAMUT_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.MATRIX_ARRI_WIDE_GAMUT_3_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.MATRIX_ARRI_WIDE_GAMUT_4_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.MATRIX_XYZ_TO_ARRI_WIDE_GAMUT_3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.MATRIX_XYZ_TO_ARRI_WIDE_GAMUT_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.PRIMARIES_ARRI_WIDE_GAMUT_3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.arri.PRIMARIES_ARRI_WIDE_GAMUT_4

# *ARRI Wide Gamut 3* colourspace.
colour.models.rgb.datasets.arri.RGB_COLOURSPACE_ARRI_WIDE_GAMUT_3

# *ARRI Wide Gamut 4* colourspace.
colour.models.rgb.datasets.arri.RGB_COLOURSPACE_ARRI_WIDE_GAMUT_4

# str(object='') -> str
colour.models.rgb.datasets.arri.WHITEPOINT_NAME_ARRI_WIDE_GAMUT_3

# str(object='') -> str
colour.models.rgb.datasets.arri.WHITEPOINT_NAME_ARRI_WIDE_GAMUT_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.best_rgb.CCS_WHITEPOINT_BEST_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.best_rgb.MATRIX_BEST_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.best_rgb.MATRIX_XYZ_TO_BEST_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.best_rgb.PRIMARIES_BEST_RGB

# *Best RGB* colourspace.
colour.models.rgb.datasets.best_rgb.RGB_COLOURSPACE_BEST_RGB

# str(object='') -> str
colour.models.rgb.datasets.best_rgb.WHITEPOINT_NAME_BEST_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.beta_rgb.CCS_WHITEPOINT_BETA_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.beta_rgb.MATRIX_BETA_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.beta_rgb.MATRIX_XYZ_TO_BETA_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.beta_rgb.PRIMARIES_BETA_RGB

# *Beta RGB* colourspace.
colour.models.rgb.datasets.beta_rgb.RGB_COLOURSPACE_BETA_RGB

# str(object='') -> str
colour.models.rgb.datasets.beta_rgb.WHITEPOINT_NAME_BETA_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.blackmagic_design.CCS_WHITEPOINT_BLACKMAGIC_WIDE_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.blackmagic_design.MATRIX_BLACKMAGIC_WIDE_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.blackmagic_design.MATRIX_XYZ_TO_BLACKMAGIC_WIDE_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.blackmagic_design.PRIMARIES_BLACKMAGIC_WIDE_GAMUT

# *Blackmagic Wide Gamut* colourspace.
colour.models.rgb.datasets.blackmagic_design.RGB_COLOURSPACE_BLACKMAGIC_WIDE_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.blackmagic_design.WHITEPOINT_NAME_BLACKMAGIC_WIDE_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.canon_cinema_gamut.CCS_WHITEPOINT_CINEMA_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.canon_cinema_gamut.MATRIX_CINEMA_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.canon_cinema_gamut.MATRIX_XYZ_TO_CINEMA_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.canon_cinema_gamut.PRIMARIES_CINEMA_GAMUT

# *Canon Cinema Gamut* colourspace.
colour.models.rgb.datasets.canon_cinema_gamut.RGB_COLOURSPACE_CINEMA_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.canon_cinema_gamut.WHITEPOINT_NAME_CINEMA_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.cie_rgb.CCS_WHITEPOINT_CIE_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.cie_rgb.MATRIX_CIE_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.cie_rgb.MATRIX_XYZ_TO_CIE_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.cie_rgb.PRIMARIES_CIE_RGB

# *CIE RGB* colourspace.
colour.models.rgb.datasets.cie_rgb.RGB_COLOURSPACE_CIE_RGB

# str(object='') -> str
colour.models.rgb.datasets.cie_rgb.WHITEPOINT_NAME_CIE_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.color_match_rgb.CCS_WHITEPOINT_COLOR_MATCH_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.color_match_rgb.MATRIX_COLOR_MATCH_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.color_match_rgb.MATRIX_XYZ_TO_COLOR_MATCH_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.color_match_rgb.PRIMARIES_COLOR_MATCH_RGB

# *ColorMatch RGB* colourspace.
colour.models.rgb.datasets.color_match_rgb.RGB_COLOURSPACE_COLOR_MATCH_RGB

# str(object='') -> str
colour.models.rgb.datasets.color_match_rgb.WHITEPOINT_NAME_COLOR_MATCH_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.davinci_wide_gamut.CCS_WHITEPOINT_DAVINCI_WIDE_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.davinci_wide_gamut.MATRIX_DAVINCI_WIDE_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.davinci_wide_gamut.MATRIX_XYZ_TO_DAVINCI_WIDE_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.davinci_wide_gamut.PRIMARIES_DAVINCI_WIDE_GAMUT

# *DaVinci Wide Gamut* colourspace.
colour.models.rgb.datasets.davinci_wide_gamut.RGB_COLOURSPACE_DAVINCI_WIDE_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.davinci_wide_gamut.WHITEPOINT_NAME_DAVINCI_WIDE_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dcdm_xyz.CCS_WHITEPOINT_DCDM_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dcdm_xyz.MATRIX_DCDM_XYZ_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dcdm_xyz.MATRIX_XYZ_TO_DCDM_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dcdm_xyz.PRIMARIES_DCDM_XYZ

# *DCDM XYZ* colourspace.
colour.models.rgb.datasets.dcdm_xyz.RGB_COLOURSPACE_DCDM_XYZ

# str(object='') -> str
colour.models.rgb.datasets.dcdm_xyz.WHITEPOINT_NAME_DCDM_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.CCS_WHITEPOINT_DCI_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.MATRIX_DCI_P3_P_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.MATRIX_DCI_P3_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.MATRIX_XYZ_TO_DCI_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.MATRIX_XYZ_TO_DCI_P3_P

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.PRIMARIES_DCI_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dci_p3.PRIMARIES_DCI_P3_P

# *DCI-P3* colourspace.
colour.models.rgb.datasets.dci_p3.RGB_COLOURSPACE_DCI_P3

# *DCI-P3+* colourspace.
colour.models.rgb.datasets.dci_p3.RGB_COLOURSPACE_DCI_P3_P

# str(object='') -> str
colour.models.rgb.datasets.dci_p3.WHITEPOINT_NAME_DCI_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.display_p3.CCS_WHITEPOINT_DISPLAY_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.display_p3.MATRIX_DISPLAY_P3_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.display_p3.MATRIX_XYZ_TO_DISPLAY_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.display_p3.PRIMARIES_DISPLAY_P3

# *Display P3* colourspace.
colour.models.rgb.datasets.display_p3.RGB_COLOURSPACE_DISPLAY_P3

# str(object='') -> str
colour.models.rgb.datasets.display_p3.WHITEPOINT_NAME_DISPLAY_P3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dji_d_gamut.CCS_WHITEPOINT_DJI_D_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dji_d_gamut.MATRIX_DJI_D_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dji_d_gamut.MATRIX_XYZ_TO_DJI_D_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.dji_d_gamut.PRIMARIES_DJI_D_GAMUT

# *DJI_D-Gamut* colourspace.
colour.models.rgb.datasets.dji_d_gamut.RGB_COLOURSPACE_DJI_D_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.dji_d_gamut.WHITEPOINT_NAME_DJI_D_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.don_rgb_4.CCS_WHITEPOINT_DON_RGB_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.don_rgb_4.MATRIX_DON_RGB_4_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.don_rgb_4.MATRIX_XYZ_TO_DON_RGB_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.don_rgb_4.PRIMARIES_DON_RGB_4

# *Don RGB 4* colourspace.
colour.models.rgb.datasets.don_rgb_4.RGB_COLOURSPACE_DON_RGB_4

# str(object='') -> str
colour.models.rgb.datasets.don_rgb_4.WHITEPOINT_NAME_DON_RGB_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ebu_3213_e.CCS_WHITEPOINT_EBU_3213_E

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ebu_3213_e.MATRIX_EBU_3213_E_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ebu_3213_e.MATRIX_XYZ_TO_EBU_3213_E_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ebu_3213_e.PRIMARIES_EBU_3213_E

# *EBU Tech. 3213-E* colourspace.
colour.models.rgb.datasets.ebu_3213_e.RGB_COLOURSPACE_EBU_3213_E

# str(object='') -> str
colour.models.rgb.datasets.ebu_3213_e.WHITEPOINT_NAME_EBU_3213_E

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.eci_rgb_v2.CCS_WHITEPOINT_ECI_RGB_V2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.eci_rgb_v2.MATRIX_ECI_RGB_V2_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.eci_rgb_v2.MATRIX_XYZ_TO_ECI_RGB_V2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.eci_rgb_v2.PRIMARIES_ECI_RGB_V2

# *ECI RGB v2* colourspace.
colour.models.rgb.datasets.eci_rgb_v2.RGB_COLOURSPACE_ECI_RGB_V2

# str(object='') -> str
colour.models.rgb.datasets.eci_rgb_v2.WHITEPOINT_NAME_ECI_RGB_V

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ekta_space_ps5.CCS_WHITEPOINT_EKTA_SPACE_PS_5

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ekta_space_ps5.MATRIX_EKTA_SPACE_PS_5_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ekta_space_ps5.MATRIX_XYZ_TO_EKTA_SPACE_PS_5

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ekta_space_ps5.PRIMARIES_EKTA_SPACE_PS_5

# *Ekta Space PS 5* colourspace.
colour.models.rgb.datasets.ekta_space_ps5.RGB_COLOURSPACE_EKTA_SPACE_PS_5

# str(object='') -> str
colour.models.rgb.datasets.ekta_space_ps5.WHITEPOINT_NAME_EKTA_SPACE_PS_5_V

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.filmlight_e_gamut.CCS_WHITEPOINT_FILMLIGHT_E_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.filmlight_e_gamut.MATRIX_FILMLIGHT_E_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.filmlight_e_gamut.MATRIX_XYZ_TO_FILMLIGHT_E_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.filmlight_e_gamut.PRIMARIES_FILMLIGHT_E_GAMUT

# *FilmLight E-Gamut* colourspace.
colour.models.rgb.datasets.filmlight_e_gamut.RGB_COLOURSPACE_FILMLIGHT_E_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.filmlight_e_gamut.WHITEPOINT_NAME_FILMLIGHT_E_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.fujifilm_f_gamut.CCS_WHITEPOINT_F_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.fujifilm_f_gamut.MATRIX_F_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.fujifilm_f_gamut.MATRIX_XYZ_TO_F_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.fujifilm_f_gamut.PRIMARIES_F_GAMUT

# *Fujifilm F-Gamut* colourspace.
colour.models.rgb.datasets.fujifilm_f_gamut.RGB_COLOURSPACE_F_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.fujifilm_f_gamut.WHITEPOINT_NAME_F_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.gopro.CCS_WHITEPOINT_PROTUNE_NATIVE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.gopro.MATRIX_PROTUNE_NATIVE_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.gopro.MATRIX_XYZ_TO_PROTUNE_NATIVE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.gopro.PRIMARIES_PROTUNE_NATIVE

# *Protune Native* colourspace.
colour.models.rgb.datasets.gopro.RGB_COLOURSPACE_PROTUNE_NATIVE

# str(object='') -> str
colour.models.rgb.datasets.gopro.WHITEPOINT_NAME_PROTUNE_NATIVE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_2020.CCS_WHITEPOINT_BT2020

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_2020.MATRIX_BT2020_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_2020.MATRIX_XYZ_TO_BT2020

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_2020.PRIMARIES_BT2020

# *RecommendationITU-R BT.2020* colourspace.
colour.models.rgb.datasets.itur_bt_2020.RGB_COLOURSPACE_BT2020

# str(object='') -> str
colour.models.rgb.datasets.itur_bt_2020.WHITEPOINT_NAME_BT2020

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.CCS_WHITEPOINT_BT470_525

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.CCS_WHITEPOINT_BT470_625

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.MATRIX_BT470_525_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.MATRIX_BT470_625_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.MATRIX_XYZ_TO_BT470_525

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.MATRIX_XYZ_TO_BT470_625

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.PRIMARIES_BT470_525

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_470.PRIMARIES_BT470_625

# *Recommendation ITU-R BT.470 - 525* colourspace.
colour.models.rgb.datasets.itur_bt_470.RGB_COLOURSPACE_BT470_525

# *Recommendation ITU-R BT.470 - 625* colourspace.
colour.models.rgb.datasets.itur_bt_470.RGB_COLOURSPACE_BT470_625

# str(object='') -> str
colour.models.rgb.datasets.itur_bt_470.WHITEPOINT_NAME_BT470_525

# str(object='') -> str
colour.models.rgb.datasets.itur_bt_470.WHITEPOINT_NAME_BT470_625

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_709.CCS_WHITEPOINT_BT709

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_709.MATRIX_BT709_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_709.MATRIX_XYZ_TO_BT709

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itur_bt_709.PRIMARIES_BT709

# *Recommendation ITU-R BT.709* colourspace.
colour.models.rgb.datasets.itur_bt_709.RGB_COLOURSPACE_BT709

# str(object='') -> str
colour.models.rgb.datasets.itur_bt_709.WHITEPOINT_NAME_BT709

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.CCS_WHITEPOINT_H273_22_UNSPECIFIED

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.CCS_WHITEPOINT_H273_GENERIC_FILM

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.MATRIX_H273_22_UNSPECIFIED_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.MATRIX_H273_GENERIC_FILM_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.MATRIX_XYZ_TO_H273_22_UNSPECIFIED_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.MATRIX_XYZ_TO_H273_GENERIC_FILM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.PRIMARIES_H273_22_UNSPECIFIED

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.itut_h_273.PRIMARIES_H273_GENERIC_FILM

# *Recommendation ITU-T H.273* row *22* colourspace as given in
colour.models.rgb.datasets.itut_h_273.RGB_COLOURSPACE_H273_22_UNSPECIFIED

# *Recommendation ITU-T H.273* *Generic Film* (colour filters using Illuminant C)
colour.models.rgb.datasets.itut_h_273.RGB_COLOURSPACE_H273_GENERIC_FILM

# str(object='') -> str
colour.models.rgb.datasets.itut_h_273.WHITEPOINT_NAME_H273_22_UNSPECIFIED

# str(object='') -> str
colour.models.rgb.datasets.itut_h_273.WHITEPOINT_NAME_H273_GENERIC_FILM

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.max_rgb.CCS_WHITEPOINT_MAX_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.max_rgb.MATRIX_MAX_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.max_rgb.MATRIX_XYZ_TO_MAX_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.max_rgb.PRIMARIES_MAX_RGB

# *Max RGB* colourspace.
colour.models.rgb.datasets.max_rgb.RGB_COLOURSPACE_MAX_RGB

# str(object='') -> str
colour.models.rgb.datasets.max_rgb.WHITEPOINT_NAME_MAX_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.nikon_n_gamut.CCS_WHITEPOINT_N_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.nikon_n_gamut.MATRIX_N_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.nikon_n_gamut.MATRIX_XYZ_TO_N_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.nikon_n_gamut.PRIMARIES_N_GAMUT

# *Nikon N-Gamut* colourspace.
colour.models.rgb.datasets.nikon_n_gamut.RGB_COLOURSPACE_N_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.nikon_n_gamut.WHITEPOINT_NAME_N_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.CCS_WHITEPOINT_NTSC1953

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.CCS_WHITEPOINT_NTSC1987

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.MATRIX_NTSC1953_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.MATRIX_NTSC1987_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.MATRIX_XYZ_TO_NTSC1953

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.MATRIX_XYZ_TO_NTSC1987

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.PRIMARIES_NTSC1953

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.ntsc.PRIMARIES_NTSC1987

# *NTSC (1953)* colourspace.
colour.models.rgb.datasets.ntsc.RGB_COLOURSPACE_NTSC1953

# *NTSC (1987)* colourspace.
colour.models.rgb.datasets.ntsc.RGB_COLOURSPACE_NTSC1987

# str(object='') -> str
colour.models.rgb.datasets.ntsc.WHITEPOINT_NAME_NTSC1953

# str(object='') -> str
colour.models.rgb.datasets.ntsc.WHITEPOINT_NAME_NTSC1987

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.p3_d65.CCS_WHITEPOINT_P3_D65

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.p3_d65.MATRIX_P3_D65_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.p3_d65.MATRIX_XYZ_TO_P3_D65

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.p3_d65.PRIMARIES_P3_D65

# *P3-D65* colourspace.
colour.models.rgb.datasets.p3_d65.RGB_COLOURSPACE_P3_D65

# str(object='') -> str
colour.models.rgb.datasets.p3_d65.WHITEPOINT_NAME_P3_D65

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.pal_secam.CCS_WHITEPOINT_PAL_SECAM

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.pal_secam.MATRIX_PAL_SECAM_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.pal_secam.MATRIX_XYZ_TO_PAL_SECAM

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.pal_secam.PRIMARIES_PAL_SECAM

# *Pal/Secam* colourspace.
colour.models.rgb.datasets.pal_secam.RGB_COLOURSPACE_PAL_SECAM

# str(object='') -> str
colour.models.rgb.datasets.pal_secam.WHITEPOINT_NAME_PAL_SECAM

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.panasonic_v_gamut.CCS_WHITEPOINT_V_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.panasonic_v_gamut.MATRIX_V_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.panasonic_v_gamut.MATRIX_XYZ_TO_V_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.panasonic_v_gamut.PRIMARIES_V_GAMUT

# *Panasonic V-Gamut* colourspace.
colour.models.rgb.datasets.panasonic_v_gamut.RGB_COLOURSPACE_V_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.panasonic_v_gamut.WHITEPOINT_NAME_V_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.plasa_ansi_e154.CCS_WHITEPOINT_PLASA_ANSI_E154

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.plasa_ansi_e154.MATRIX_PLASA_ANSI_E154_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.plasa_ansi_e154.MATRIX_XYZ_TO_PLASA_ANSI_E154

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.plasa_ansi_e154.PRIMARIES_PLASA_ANSI_E154

# *PLASA ANSI E1.54* colourspace.
colour.models.rgb.datasets.plasa_ansi_e154.RGB_COLOURSPACE_PLASA_ANSI_E154

# str(object='') -> str
colour.models.rgb.datasets.plasa_ansi_e154.WHITEPOINT_NAME_PLASA_ANSI_E154

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_DRAGON_COLOR

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_DRAGON_COLOR_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_RED_COLOR

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_RED_COLOR_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_RED_COLOR_3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_RED_COLOR_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.CCS_WHITEPOINT_RED_WIDE_GAMUT_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_DRAGON_COLOR_2_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_DRAGON_COLOR_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_RED_COLOR_2_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_RED_COLOR_3_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_RED_COLOR_4_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_RED_COLOR_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_RED_WIDE_GAMUT_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_DRAGON_COLOR

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_DRAGON_COLOR_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_RED_COLOR

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_RED_COLOR_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_RED_COLOR_3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_RED_COLOR_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.MATRIX_XYZ_TO_RED_WIDE_GAMUT_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_DRAGON_COLOR

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_DRAGON_COLOR_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_RED_COLOR

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_RED_COLOR_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_RED_COLOR_3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_RED_COLOR_4

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.red.PRIMARIES_RED_WIDE_GAMUT_RGB

# *DRAGONcolor* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_DRAGON_COLOR

# *DRAGONcolor2* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_DRAGON_COLOR_2

# *REDcolor* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_RED_COLOR

# *REDcolor2* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_RED_COLOR_2

# *REDcolor3* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_RED_COLOR_3

# *REDcolor4* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_RED_COLOR_4

# *REDWideGamutRGB* colourspace.
colour.models.rgb.datasets.red.RGB_COLOURSPACE_RED_WIDE_GAMUT_RGB

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_DRAGON_COLOR

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_DRAGON_COLOR_2

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_RED_COLOR

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_RED_COLOR_2

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_RED_COLOR_3

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_RED_COLOR_4

# str(object='') -> str
colour.models.rgb.datasets.red.WHITEPOINT_NAME_RED_WIDE_GAMUT_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.CCS_WHITEPOINT_ERIMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.CCS_WHITEPOINT_PROPHOTO_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.CCS_WHITEPOINT_RIMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.CCS_WHITEPOINT_ROMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_ERIMM_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_PROPHOTO_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_RIMM_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_ROMM_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_XYZ_TO_ERIMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_XYZ_TO_PROPHOTO_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_XYZ_TO_RIMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.MATRIX_XYZ_TO_ROMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.PRIMARIES_ERIMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.PRIMARIES_PROPHOTO_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.PRIMARIES_RIMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.rimm_romm_rgb.PRIMARIES_ROMM_RGB

# *ERIMM RGB* colourspace.
colour.models.rgb.datasets.rimm_romm_rgb.RGB_COLOURSPACE_ERIMM_RGB

# *ProPhoto RGB* colourspace, an alias colourspace for *ROMM RGB*.
colour.models.rgb.datasets.rimm_romm_rgb.RGB_COLOURSPACE_PROPHOTO_RGB

# *RIMM RGB* colourspace. In cases in which it is necessary to identify a
colour.models.rgb.datasets.rimm_romm_rgb.RGB_COLOURSPACE_RIMM_RGB

# *ROMM RGB* colourspace.
colour.models.rgb.datasets.rimm_romm_rgb.RGB_COLOURSPACE_ROMM_RGB

# str(object='') -> str
colour.models.rgb.datasets.rimm_romm_rgb.WHITEPOINT_NAME_ERIMM_RGB

# str(object='') -> str
colour.models.rgb.datasets.rimm_romm_rgb.WHITEPOINT_NAME_PROPHOTO_RGB

# str(object='') -> str
colour.models.rgb.datasets.rimm_romm_rgb.WHITEPOINT_NAME_RIMM_RGB

# str(object='') -> str
colour.models.rgb.datasets.rimm_romm_rgb.WHITEPOINT_NAME_ROMM_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.russell_rgb.CCS_WHITEPOINT_RUSSELL_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.russell_rgb.MATRIX_RUSSELL_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.russell_rgb.MATRIX_XYZ_TO_RUSSELL_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.russell_rgb.PRIMARIES_RUSSELL_RGB

# *Russell RGB* colourspace.
colour.models.rgb.datasets.russell_rgb.RGB_COLOURSPACE_RUSSELL_RGB

# str(object='') -> str
colour.models.rgb.datasets.russell_rgb.WHITEPOINT_NAME_RUSSELL_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sharp.CCS_WHITEPOINT_SHARP_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sharp.MATRIX_SHARP_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sharp.MATRIX_XYZ_TO_SHARP_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sharp.PRIMARIES_SHARP_RGB

# *Sharp RGB* colourspace.
colour.models.rgb.datasets.sharp.RGB_COLOURSPACE_SHARP_RGB

# str(object='') -> str
colour.models.rgb.datasets.sharp.WHITEPOINT_NAME_SHARP_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_240m.CCS_WHITEPOINT_SMPTE_240M

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_240m.MATRIX_SMPTE_240M_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_240m.MATRIX_XYZ_TO_SMPTE_240M

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_240m.PRIMARIES_SMPTE_240M

# *SMPTE 240M* colourspace.
colour.models.rgb.datasets.smpte_240m.RGB_COLOURSPACE_SMPTE_240M

# str(object='') -> str
colour.models.rgb.datasets.smpte_240m.WHITEPOINT_NAME_SMPTE_240M

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_c.CCS_WHITEPOINT_SMPTE_C

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_c.MATRIX_SMPTE_C_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_c.MATRIX_XYZ_TO_SMPTE_C

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.smpte_c.PRIMARIES_SMPTE_C

# *SMPTE C* colourspace.
colour.models.rgb.datasets.smpte_c.RGB_COLOURSPACE_SMPTE_C

# str(object='') -> str
colour.models.rgb.datasets.smpte_c.WHITEPOINT_NAME_SMPTE_C

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.CCS_WHITEPOINT_S_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.CCS_WHITEPOINT_S_GAMUT3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.CCS_WHITEPOINT_S_GAMUT3_CINE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.CCS_WHITEPOINT_VENICE_S_GAMUT3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.CCS_WHITEPOINT_VENICE_S_GAMUT3_CINE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_S_GAMUT3_CINE_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_S_GAMUT3_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_S_GAMUT_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_VENICE_S_GAMUT3_CINE_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_VENICE_S_GAMUT3_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_XYZ_TO_S_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_XYZ_TO_S_GAMUT3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_XYZ_TO_S_GAMUT3_CINE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_XYZ_TO_VENICE_S_GAMUT3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.MATRIX_XYZ_TO_VENICE_S_GAMUT3_CINE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.PRIMARIES_S_GAMUT

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.PRIMARIES_S_GAMUT3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.PRIMARIES_S_GAMUT3_CINE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.PRIMARIES_VENICE_S_GAMUT3

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.sony.PRIMARIES_VENICE_S_GAMUT3_CINE

# *S-Gamut* colourspace.
colour.models.rgb.datasets.sony.RGB_COLOURSPACE_S_GAMUT

# *S-Gamut3* colourspace.
colour.models.rgb.datasets.sony.RGB_COLOURSPACE_S_GAMUT3

# *S-Gamut3.Cine* colourspace.
colour.models.rgb.datasets.sony.RGB_COLOURSPACE_S_GAMUT3_CINE

# *Venice S-Gamut3* colourspace.
colour.models.rgb.datasets.sony.RGB_COLOURSPACE_VENICE_S_GAMUT3

# *Venice S-Gamut3.Cine* colourspace.
colour.models.rgb.datasets.sony.RGB_COLOURSPACE_VENICE_S_GAMUT3_CINE

# str(object='') -> str
colour.models.rgb.datasets.sony.WHITEPOINT_NAME_S_GAMUT

# str(object='') -> str
colour.models.rgb.datasets.sony.WHITEPOINT_NAME_S_GAMUT3

# str(object='') -> str
colour.models.rgb.datasets.sony.WHITEPOINT_NAME_S_GAMUT3_CINE

# str(object='') -> str
colour.models.rgb.datasets.sony.WHITEPOINT_NAME_VENICE_S_GAMUT3

# str(object='') -> str
colour.models.rgb.datasets.sony.WHITEPOINT_NAME_VENICE_S_GAMUT3_CINE

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.srgb.CCS_WHITEPOINT_sRGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.srgb.MATRIX_XYZ_TO_sRGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.srgb.MATRIX_sRGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.srgb.PRIMARIES_sRGB

# *Smits (1999)* colourspace.
colour.models.rgb.datasets.srgb.RGB_COLOURSPACE_sRGB

# str(object='') -> str
colour.models.rgb.datasets.srgb.WHITEPOINT_NAME_sRGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.xtreme_rgb.CCS_WHITEPOINT_XTREME_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.xtreme_rgb.MATRIX_XTREME_RGB_TO_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.xtreme_rgb.MATRIX_XYZ_TO_XTREME_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.datasets.xtreme_rgb.PRIMARIES_XTREME_RGB

# *Xtreme RGB* colourspace.
colour.models.rgb.datasets.xtreme_rgb.RGB_COLOURSPACE_XTREME_RGB

# str(object='') -> str
colour.models.rgb.datasets.xtreme_rgb.WHITEPOINT_NAME_XTREME_RGB

# Return the *luminance* :math:`Y` of given *RGB* components from given
colour.models.rgb.derivation.RGB_luminance

# Return the *luminance equation* from given *primaries* and *whitepoint*.
colour.models.rgb.derivation.RGB_luminance_equation

# Chromatically adapt given *primaries* :math:`xy` chromaticity coordinates
colour.models.rgb.derivation.chromatically_adapted_primaries

# Compute the *Normalised Primary Matrix* (NPM) converting a *RGB*
colour.models.rgb.derivation.normalised_primary_matrix

# Compute the *primaries* and *whitepoint* :math:`xy` chromaticity
colour.models.rgb.derivation.primaries_whitepoint

# Return the *z* coordinate using given :math:`xy` chromaticity coordinates.
colour.models.rgb.derivation.xy_to_z

# Convert from *IHLS* (Improved HLS) colourspace to *RGB* colourspace.
colour.models.rgb.hanbury2003.IHLS_to_RGB

# Convert from *RGB* colourspace to *IHLS* (Improved HLS) colourspace.
colour.models.rgb.hanbury2003.RGB_to_IHLS

# Convert from :math:`IC_TC_P` colour encoding to *ITU-R BT.2020*
colour.models.rgb.ictcp.ICtCp_to_RGB

# Convert from :math:`IC_TC_P` colour encoding to *CIE XYZ* tristimulus
colour.models.rgb.ictcp.ICtCp_to_XYZ

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ictcp.MATRIX_ICTCP_ICTCP_TO_LMS_P

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ictcp.MATRIX_ICTCP_ICTCP_TO_LMS_P_BT2100_HLG_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ictcp.MATRIX_ICTCP_LMS_P_TO_ICTCP

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ictcp.MATRIX_ICTCP_LMS_P_TO_ICTCP_BT2100_HLG_2

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ictcp.MATRIX_ICTCP_LMS_TO_RGB

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ictcp.MATRIX_ICTCP_RGB_TO_LMS

# Convert from *ITU-R BT.2020* colourspace to :math:`IC_TC_P` colour
colour.models.rgb.ictcp.RGB_to_ICtCp

# Convert from *CIE XYZ* tristimulus values to :math:`IC_TC_P` colour
colour.models.rgb.ictcp.XYZ_to_ICtCp

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.CCS_WHITEPOINTS_23001_8

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.CCS_WHITEPOINTS_ISO14496_10

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.CCS_WHITEPOINTS_ISO23091_2

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.CCS_WHITEPOINTS_ITUTH273

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.COLOUR_PRIMARIES_23001_8

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.COLOUR_PRIMARIES_ISO14496_10

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.COLOUR_PRIMARIES_ISO23091_2

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.COLOUR_PRIMARIES_ITUTH273

# Define the constant names used by *FFmpeg* in the `AVColorPrimaries` enum.
colour.models.rgb.itut_h_273.FFmpegConstantsColourPrimaries_ITUTH273

# Define the constant names used by *FFmpeg* in the `AVColorSpace` enum.
colour.models.rgb.itut_h_273.FFmpegConstantsMatrixCoefficients_ITUTH273

# Define the constant names used by *FFmpeg* in the
colour.models.rgb.itut_h_273.FFmpegConstantsTransferCharacteristics_ITUTH273

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_23001_8_RGB_TO_XYZ

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_ISO14496_10_RGB_TO_XYZ

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_ISO23091_2_RGB_TO_XYZ

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_ITUTH273_RGB_TO_XYZ

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_XYZ_TO_23001_8_RGB

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_XYZ_TO_ISO14496_10_RGB

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_XYZ_TO_ISO23091_2_RGB

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRICES_XYZ_TO_ITUTH273_RGB

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRIX_COEFFICIENTS_23001_8

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRIX_COEFFICIENTS_ISO14496_10

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRIX_COEFFICIENTS_ISO23091_2

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.MATRIX_COEFFICIENTS_ITUTH273

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.TRANSFER_CHARACTERISTICS_23001_8

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.TRANSFER_CHARACTERISTICS_ISO14496_10

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.TRANSFER_CHARACTERISTICS_ISO23091_2

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.TRANSFER_CHARACTERISTICS_ITUTH273

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.WHITEPOINT_NAMES_23001_8

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.WHITEPOINT_NAMES_ISO14496_10

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.WHITEPOINT_NAMES_ISO23091_2

# dict() -> new empty dictionary
colour.models.rgb.itut_h_273.WHITEPOINT_NAMES_ITUTH273

# Describe given video signal colour primaries code point.
colour.models.rgb.itut_h_273.describe_video_signal_colour_primaries

# Describe given video signal matrix coefficients code point.
colour.models.rgb.itut_h_273.describe_video_signal_matrix_coefficients

# Describe given video signal transfer characteristics code point.
colour.models.rgb.itut_h_273.describe_video_signal_transfer_characteristics

# Convert from *Prismatic* :math:`L\rho\gamma\beta` colourspace array to
colour.models.rgb.prismatic.Prismatic_to_RGB

# Convert from *RGB* colourspace to *Prismatic* :math:`L\rho\gamma\beta`
colour.models.rgb.prismatic.RGB_to_Prismatic

# Implement support for the *RGB* colourspaces datasets from
colour.models.rgb.rgb_colourspace.RGB_Colourspace

# Convert given *RGB* colourspace array from given input *RGB* colourspace
colour.models.rgb.rgb_colourspace.RGB_to_RGB

# Convert given *RGB* colourspace array to *CIE XYZ* tristimulus values.
colour.models.rgb.rgb_colourspace.RGB_to_XYZ

# Convert from *CIE XYZ* tristimulus values to *RGB* colourspace array.
colour.models.rgb.rgb_colourspace.XYZ_to_RGB

# Compute the matrix :math:`M` converting from given input *RGB*
colour.models.rgb.rgb_colourspace.matrix_RGB_to_RGB

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.aces.CONSTANTS_ACES_CCT

# dict() -> new empty dictionary
colour.models.rgb.transfer_functions.aces.CONSTANTS_ACES_PROXY

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.aces.CONSTANTS_ACES_PROXY_10

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.aces.CONSTANTS_ACES_PROXY_12

# Define the *ACEScc* colourspace log decoding / electro-optical transfer
colour.models.rgb.transfer_functions.aces.log_decoding_ACEScc

# Define the *ACEScct* colourspace log decoding / electro-optical transfer
colour.models.rgb.transfer_functions.aces.log_decoding_ACEScct

# Define the *ACESproxy* colourspace log decoding curve / electro-optical
colour.models.rgb.transfer_functions.aces.log_decoding_ACESproxy

# Define the *ACEScc* colourspace log encoding / opto-electronic transfer
colour.models.rgb.transfer_functions.aces.log_encoding_ACEScc

# Define the *ACEScct* colourspace log encoding / opto-electronic transfer
colour.models.rgb.transfer_functions.aces.log_encoding_ACEScct

# Define the *ACESproxy* colourspace log encoding curve / opto-electronic
colour.models.rgb.transfer_functions.aces.log_encoding_ACESproxy

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.apple_log_profile.CONSTANTS_APPLE_LOG_PROFILE

# Define the *Apple Log Profile* log decoding curve.
colour.models.rgb.transfer_functions.apple_log_profile.log_decoding_AppleLogProfile

# Define the *Apple Log Profile* log encoding curve.
colour.models.rgb.transfer_functions.apple_log_profile.log_encoding_AppleLogProfile

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.arib_std_b67.CONSTANTS_ARIBSTDB67

# Define *ARIB STD-B67 (Hybrid Log-Gamma)* opto-electrical transfer
colour.models.rgb.transfer_functions.arib_std_b67.oetf_ARIBSTDB67

# Define *ARIB STD-B67 (Hybrid Log-Gamma)* inverse opto-electrical transfer
colour.models.rgb.transfer_functions.arib_std_b67.oetf_inverse_ARIBSTDB67

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.arri.CONSTANTS_ARRILOGC4

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.rgb.transfer_functions.arri.DATA_ALEXA_LOG_C_CURVE_BCL

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.rgb.transfer_functions.arri.DATA_ALEXA_LOG_C_CURVE_CONVERSION

# Define the *ARRI LogC3* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.arri.log_decoding_ARRILogC3

# Define the *ARRI LogC4* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.arri.log_decoding_ARRILogC4

# Define the *ARRI LogC3* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.arri.log_encoding_ARRILogC3

# Define the *ARRI LogC4* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.arri.log_encoding_ARRILogC4

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.blackmagic_design.CONSTANTS_BLACKMAGIC_FILM_GENERATION_5

# Define the *Blackmagic Film Generation 5* opto-electronic transfer
colour.models.rgb.transfer_functions.blackmagic_design.oetf_BlackmagicFilmGeneration5

# Define the *Blackmagic Film Generation 5* inverse opto-electronic transfer
colour.models.rgb.transfer_functions.blackmagic_design.oetf_inverse_BlackmagicFilmGeneration5

# Supported *Canon Log 2* log decoding curve / electro-optical transfer function
colour.models.rgb.transfer_functions.canon.CANON_LOG_2_DECODING_METHODS

# Supported *Canon Log 2* log encoding curve / opto-electronic transfer function
colour.models.rgb.transfer_functions.canon.CANON_LOG_2_ENCODING_METHODS

# Supported *Canon Log 3* log decoding curve / electro-optical transfer function
colour.models.rgb.transfer_functions.canon.CANON_LOG_3_DECODING_METHODS

# Supported *Canon Log 3* log encoding curve / opto-electronic transfer function
colour.models.rgb.transfer_functions.canon.CANON_LOG_3_ENCODING_METHODS

# Supported *CanonLog* log decoding curve / electro-optical transfer function
colour.models.rgb.transfer_functions.canon.CANON_LOG_DECODING_METHODS

# Supported *CanonLog* log encoding curve / opto-electronic transfer function
colour.models.rgb.transfer_functions.canon.CANON_LOG_ENCODING_METHODS

# Define the *Canon Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog

# Define the *Canon Log 2* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog2

# Define the *Canon Log 2* v1 log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog2_v1

# Define the *Canon Log 2* v1.2 log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog2_v1_2

# Define the *Canon Log 3* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog3

# Define the *Canon Log 3* v1 log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog3_v1

# Define the *Canon Log 3* v1.2 log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog3_v1_2

# Define the *Canon Log* v1 log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog_v1

# Define the *Canon Log* v1.2 log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.canon.log_decoding_CanonLog_v1_2

# Define the *Canon Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog

# Define the *Canon Log 2* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog2

# Define the *Canon Log 2* v1 log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog2_v1

# Define the *Canon Log 2* v1.2 log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog2_v1_2

# Define the *Canon Log 3* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog3

# Define the *Canon Log 3* v1 log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog3_v1

# Define the *Canon Log 3* v1.2 log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog3_v1_2

# Define the *Canon Log* v1 log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog_v1

# Define the *Canon Log* v1.2 log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.canon.log_encoding_CanonLog_v1_2

# Define the *Cineon* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.cineon.log_decoding_Cineon

# Define the *Cineon* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.cineon.log_encoding_Cineon

# Return the code value :math:`CV` range for given bit-depth, range legality
colour.models.rgb.transfer_functions.common.CV_range

# Convert given code value :math:`CV` or float equivalent of a code value at
colour.models.rgb.transfer_functions.common.full_to_legal

# Convert given code value :math:`CV` or float equivalent of a code value at
colour.models.rgb.transfer_functions.common.legal_to_full

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.davinci_intermediate.CONSTANTS_DAVINCI_INTERMEDIATE

# Define the *DaVinci Intermediate* opto-electronic transfer function.
colour.models.rgb.transfer_functions.davinci_intermediate.oetf_DaVinciIntermediate

# Define the *DaVinci Intermediate* inverse opto-electronic transfer
colour.models.rgb.transfer_functions.davinci_intermediate.oetf_inverse_DaVinciIntermediate

# Define the *DCDM* electro-optical transfer function (EOTF).
colour.models.rgb.transfer_functions.dcdm.eotf_DCDM

# Define the *DCDM* inverse electro-optical transfer function (EOTF).
colour.models.rgb.transfer_functions.dcdm.eotf_inverse_DCDM

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.dicom_gsdf.CONSTANTS_DICOMGSDF

# Define the *DICOM - Grayscale Standard Display Function* electro-optical
colour.models.rgb.transfer_functions.dicom_gsdf.eotf_DICOMGSDF

# Define the *DICOM - Grayscale Standard Display Function* inverse
colour.models.rgb.transfer_functions.dicom_gsdf.eotf_inverse_DICOMGSDF

# Define the *DJI D-Log* log decoding curve.
colour.models.rgb.transfer_functions.dji_d_log.log_decoding_DJIDLog

# Define the *DJI D-Log* log encoding curve.
colour.models.rgb.transfer_functions.dji_d_log.log_encoding_DJIDLog

# Define the *basic* exponent transfer function.
colour.models.rgb.transfer_functions.exponent.exponent_function_basic

# Define the *Monitor Curve* exponent transfer function.
colour.models.rgb.transfer_functions.exponent.exponent_function_monitor_curve

# Define the *FiLMiC Pro 6* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.filmic_pro.log_decoding_FilmicPro6

# Define the *FiLMiC Pro 6* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.filmic_pro.log_encoding_FilmicPro6

# Define the *FilmLight T-Log* log decoding curve.
colour.models.rgb.transfer_functions.filmlight_t_log.log_decoding_FilmLightTLog

# Define the *FilmLight T-Log* log encoding curve.
colour.models.rgb.transfer_functions.filmlight_t_log.log_encoding_FilmLightTLog

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.fujifilm_f_log.CONSTANTS_FLOG

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.fujifilm_f_log.CONSTANTS_FLOG2

# Define the *Fujifilm F-Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.fujifilm_f_log.log_decoding_FLog

# Define the *Fujifilm F-Log2* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.fujifilm_f_log.log_decoding_FLog2

# Define the *Fujifilm F-Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.fujifilm_f_log.log_encoding_FLog

# Define the *Fujifilm F-Log2* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.fujifilm_f_log.log_encoding_FLog2

# Define a typical gamma encoding / decoding function.
colour.models.rgb.transfer_functions.gamma.gamma_function

# Define the *Protune* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.gopro.log_decoding_Protune

# Define the *Protune* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.gopro.log_encoding_Protune

# Define *Recommendation ITU-R BT.1361* extended color gamut system
colour.models.rgb.transfer_functions.itur_bt_1361.oetf_BT1361

# Define *Recommendation ITU-R BT.1361* extended color gamut system inverse
colour.models.rgb.transfer_functions.itur_bt_1361.oetf_inverse_BT1361

# Define *Recommendation ITU-R BT.1886* electro-optical transfer function
colour.models.rgb.transfer_functions.itur_bt_1886.eotf_BT1886

# Define *Recommendation ITU-R BT.1886* inverse electro-optical transfer
colour.models.rgb.transfer_functions.itur_bt_1886.eotf_inverse_BT1886

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.itur_bt_2020.CONSTANTS_BT2020

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.itur_bt_2020.CONSTANTS_BT2020_PRECISE

# Define *Recommendation ITU-R BT.2020* opto-electronic transfer function
colour.models.rgb.transfer_functions.itur_bt_2020.oetf_BT2020

# Define *Recommendation ITU-R BT.2020* inverse opto-electronic transfer
colour.models.rgb.transfer_functions.itur_bt_2020.oetf_inverse_BT2020

# Supported *Recommendation ITU-R BT.2100* *Reference HLG* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.BT2100_HLG_EOTF_INVERSE_METHODS

# Supported *Recommendation ITU-R BT.2100* *Reference HLG* electro-optical
colour.models.rgb.transfer_functions.itur_bt_2100.BT2100_HLG_EOTF_METHODS

# Supported *Recommendation ITU-R BT.2100* *Reference HLG* inverse opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.BT2100_HLG_OOTF_INVERSE_METHODS

# Supported *Recommendation ITU-R BT.2100* *Reference HLG* opto-optical transfer
colour.models.rgb.transfer_functions.itur_bt_2100.BT2100_HLG_OOTF_METHODS

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.itur_bt_2100.CONSTANTS_BT2100_HLG

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.transfer_functions.itur_bt_2100.WEIGHTS_BT2100_HLG

# Return the *Reference HLG* black level lift :math:`\beta` for given
colour.models.rgb.transfer_functions.itur_bt_2100.black_level_lift_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference HLG* electro-optical
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference HLG* electro-optical
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_BT2100_HLG_1

# Define *Recommendation ITU-R BT.2100* *Reference HLG* electro-optical
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_BT2100_HLG_2

# Define *Recommendation ITU-R BT.2100* *Reference PQ* electro-optical
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_BT2100_PQ

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_inverse_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_inverse_BT2100_HLG_1

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_inverse_BT2100_HLG_2

# Define *Recommendation ITU-R BT.2100* *Reference PQ* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.eotf_inverse_BT2100_PQ

# Return the *Reference HLG* system gamma value for given display nominal
colour.models.rgb.transfer_functions.itur_bt_2100.gamma_function_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference HLG* opto-electrical
colour.models.rgb.transfer_functions.itur_bt_2100.oetf_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference PQ* opto-electrical
colour.models.rgb.transfer_functions.itur_bt_2100.oetf_BT2100_PQ

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.oetf_inverse_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference PQ* inverse
colour.models.rgb.transfer_functions.itur_bt_2100.oetf_inverse_BT2100_PQ

# Define *Recommendation ITU-R BT.2100* *Reference HLG* opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference HLG* opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_BT2100_HLG_1

# Define *Recommendation ITU-R BT.2100* *Reference HLG* opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_BT2100_HLG_2

# Define *Recommendation ITU-R BT.2100* *Reference PQ* opto-optical transfer
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_BT2100_PQ

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_inverse_BT2100_HLG

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_inverse_BT2100_HLG_1

# Define *Recommendation ITU-R BT.2100* *Reference HLG* inverse opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_inverse_BT2100_HLG_2

# Define *Recommendation ITU-R BT.2100* *Reference PQ* inverse opto-optical
colour.models.rgb.transfer_functions.itur_bt_2100.ootf_inverse_BT2100_PQ

# Define *Recommendation ITU-R BT.601-7* opto-electronic transfer function
colour.models.rgb.transfer_functions.itur_bt_601.oetf_BT601

# Define *Recommendation ITU-R BT.601-7* inverse opto-electronic transfer
colour.models.rgb.transfer_functions.itur_bt_601.oetf_inverse_BT601

# Define *Recommendation ITU-R BT.709-6* opto-electronic transfer function
colour.models.rgb.transfer_functions.itur_bt_709.oetf_BT709

# Define *Recommendation ITU-R BT.709-6* inverse opto-electronic transfer
colour.models.rgb.transfer_functions.itur_bt_709.oetf_inverse_BT709

# Define the *SMPTE ST 428-1 (2019)* electro-optical transfer function (EOTF).
colour.models.rgb.transfer_functions.itut_h_273.eotf_H273_ST428_1

# Define *Recommendation ITU-T H.273* inverse electro-optical transfer
colour.models.rgb.transfer_functions.itut_h_273.eotf_inverse_H273_ST428_1

# Define *Recommendation ITU-T H.273* opto-electronic transfer function
colour.models.rgb.transfer_functions.itut_h_273.oetf_H273_IEC61966_2

# Define *Recommendation ITU-T H.273* opto-electronic transfer function
colour.models.rgb.transfer_functions.itut_h_273.oetf_H273_Log

# Define *Recommendation ITU-T H.273* opto-electronic transfer function
colour.models.rgb.transfer_functions.itut_h_273.oetf_H273_LogSqrt

# Define *Recommendation ITU-T H.273* inverse opto-electronic transfer
colour.models.rgb.transfer_functions.itut_h_273.oetf_inverse_H273_IEC61966_2

# Define *Recommendation ITU-T H.273* inverse-opto-electronic transfer
colour.models.rgb.transfer_functions.itut_h_273.oetf_inverse_H273_Log

# Define *Recommendation ITU-T H.273* inverse-opto-electronic transfer
colour.models.rgb.transfer_functions.itut_h_273.oetf_inverse_H273_LogSqrt

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.leica_l_log.CONSTANTS_LLOG

# Define the *Leica L-Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.leica_l_log.log_decoding_LLog

# Define the *Leica L-Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.leica_l_log.log_encoding_LLog

# Define a typical linear encoding / decoding function, essentially a
colour.models.rgb.transfer_functions.linear.linear_function

# Define the common *Log2* decoding function.
colour.models.rgb.transfer_functions.log.log_decoding_Log2

# Define the common *Log2* encoding function.
colour.models.rgb.transfer_functions.log.log_encoding_Log2

# Define the basic logarithmic function.
colour.models.rgb.transfer_functions.log.logarithmic_function_basic

# Define the camera logarithmic function.
colour.models.rgb.transfer_functions.log.logarithmic_function_camera

# Define the quasilog logarithmic function.
colour.models.rgb.transfer_functions.log.logarithmic_function_quasilog

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.nikon_n_log.CONSTANTS_NLOG

# Define the *Nikon N-Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.nikon_n_log.log_decoding_NLog

# Define the *Nikon N-Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.nikon_n_log.log_encoding_NLog

# Define the *Panalog* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.panalog.log_decoding_Panalog

# Define the *Panalog* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.panalog.log_encoding_Panalog

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.panasonic_v_log.CONSTANTS_VLOG

# Define the *Panasonic V-Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.panasonic_v_log.log_decoding_VLog

# Define the *Panasonic V-Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.panasonic_v_log.log_encoding_VLog

# Define the *Josh Pines* style *Pivoted Log* log decoding curve /
colour.models.rgb.transfer_functions.pivoted_log.log_decoding_PivotedLog

# Define the *Josh Pines* style *Pivoted Log* log encoding curve /
colour.models.rgb.transfer_functions.pivoted_log.log_encoding_PivotedLog

# Supported *Log3G10* log decoding curve / electro-optical transfer function
colour.models.rgb.transfer_functions.red.LOG3G10_DECODING_METHODS

# Supported *Log3G10* log encoding curve / opto-electronic transfer function
colour.models.rgb.transfer_functions.red.LOG3G10_ENCODING_METHODS

# Define the *Log3G10* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_Log3G10

# Define the *Log3G10* *v1* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_Log3G10_v1

# Define the *Log3G10* *v2* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_Log3G10_v2

# Define the *Log3G10* *v3* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_Log3G10_v3

# Define the *Log3G12* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_Log3G12

# Define the *REDLog* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_REDLog

# Define the *REDLogFilm* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.red.log_decoding_REDLogFilm

# Define the *Log3G10* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_Log3G10

# Define the *Log3G10* *v1* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_Log3G10_v1

# Define the *Log3G10* *v2* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_Log3G10_v2

# Define the *Log3G10* *v3* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_Log3G10_v3

# Define the *Log3G12* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_Log3G12

# Define the *REDLog* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_REDLog

# Define the *REDLogFilm* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.red.log_encoding_REDLogFilm

# Define the *ProPhoto RGB* decoding colour component transfer function
colour.models.rgb.transfer_functions.rimm_romm_rgb.cctf_decoding_ProPhotoRGB

# Define the *RIMM RGB* decoding colour component transfer function
colour.models.rgb.transfer_functions.rimm_romm_rgb.cctf_decoding_RIMMRGB

# Define the *ROMM RGB* decoding colour component transfer function
colour.models.rgb.transfer_functions.rimm_romm_rgb.cctf_decoding_ROMMRGB

# Define the *ProPhoto RGB* encoding colour component transfer function
colour.models.rgb.transfer_functions.rimm_romm_rgb.cctf_encoding_ProPhotoRGB

# Define the *RIMM RGB* encoding colour component transfer function
colour.models.rgb.transfer_functions.rimm_romm_rgb.cctf_encoding_RIMMRGB

# Define the *ROMM RGB* encoding colour component transfer function
colour.models.rgb.transfer_functions.rimm_romm_rgb.cctf_encoding_ROMMRGB

# Define the *ERIMM RGB* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.rimm_romm_rgb.log_decoding_ERIMMRGB

# Define the *ERIMM RGB* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.rimm_romm_rgb.log_encoding_ERIMMRGB

# Define *SMPTE 240M* electro-optical transfer function (EOTF).
colour.models.rgb.transfer_functions.smpte_240m.eotf_SMPTE240M

# Define *SMPTE 240M* opto-electrical transfer function (OETF).
colour.models.rgb.transfer_functions.smpte_240m.oetf_SMPTE240M

# Define the *Sony S-Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.sony.log_decoding_SLog

# Define the *Sony S-Log2* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.sony.log_decoding_SLog2

# Define the *Sony S-Log3* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.sony.log_decoding_SLog3

# Define the *Sony S-Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.sony.log_encoding_SLog

# Define the *Sony S-Log2* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.sony.log_encoding_SLog2

# Define the *Sony S-Log3* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.sony.log_encoding_SLog3

# Define the *IEC 61966-2-1:1999* *sRGB* inverse electro-optical transfer
colour.models.rgb.transfer_functions.srgb.eotf_inverse_sRGB

# Define the *IEC 61966-2-1:1999* *sRGB* electro-optical transfer function
colour.models.rgb.transfer_functions.srgb.eotf_sRGB

# Define a :class:`dict`-like object allowing to access key values using dot
colour.models.rgb.transfer_functions.st_2084.CONSTANTS_ST2084

# Define *SMPTE ST 2084:2014* optimised perceptual electro-optical transfer
colour.models.rgb.transfer_functions.st_2084.eotf_ST2084

# Define *SMPTE ST 2084:2014* optimised perceptual inverse electro-optical
colour.models.rgb.transfer_functions.st_2084.eotf_inverse_ST2084

# Define the *Viper Log* log decoding curve / electro-optical transfer
colour.models.rgb.transfer_functions.viper_log.log_decoding_ViperLog

# Define the *Viper Log* log encoding curve / opto-electronic transfer
colour.models.rgb.transfer_functions.viper_log.log_encoding_ViperLog

# Convert an array of *R'G'B'* values to the corresponding *Y'CbCr* colour
colour.models.rgb.ycbcr.RGB_to_YCbCr

# Convert an array of *RGB* linear values to the corresponding *Yc'Cbc'Crc'*
colour.models.rgb.ycbcr.RGB_to_YcCbcCrc

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.models.rgb.ycbcr.WEIGHTS_YCBCR

# Convert an array of *Y'CbCr* colour encoding values to the corresponding
colour.models.rgb.ycbcr.YCbCr_to_RGB

# Convert an array of *Yc'Cbc'Crc'* colour encoding values to the
colour.models.rgb.ycbcr.YcCbcCrc_to_RGB

# Compute the *Y'CbCr* to *R'G'B'* matrix for given weights, bit-depth,
colour.models.rgb.ycbcr.matrix_YCbCr

# Compute the *R'G'B'* to *Y'CbCr* offsets for given bit-depth, range
colour.models.rgb.ycbcr.offset_YCbCr

# Return the *Y'CbCr* colour encoding ranges array for given bit-depth,
colour.models.rgb.ycbcr.ranges_YCbCr

# Round given array :math:`a` to the nearest int using the method define
colour.models.rgb.ycbcr.round_BT2100

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ycocg.MATRIX_RGB_TO_YCOCG

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.models.rgb.ycocg.MATRIX_YCOCG_TO_RGB

# Convert an array of *R'G'B'* values to the corresponding *YCoCg* colour
colour.models.rgb.ycocg.RGB_to_YCoCg

# Convert an array of *YCoCg* colour encoding values to the corresponding
colour.models.rgb.ycocg.YCoCg_to_RGB

# Convert from *LMS* colourspace to *Kirk (2019)* *Yrg* colourspace.
colour.models.yrg.LMS_to_Yrg

# Convert from *CIE XYZ* tristimulus values to *Kirk (2019)* *Yrg*
colour.models.yrg.XYZ_to_Yrg

# Convert from *Kirk (2019)* *Yrg* colourspace to *LMS* colourspace.
colour.models.yrg.Yrg_to_LMS

# Convert from *Kirk (2019)* *Yrg* colourspace to *CIE XYZ* tristimulus values.
colour.models.yrg.Yrg_to_XYZ

# Convert given colour keyword to *RGB* colourspace according to
colour.notation.css_color_3.keyword_to_RGB_CSSColor3

# List of colour keywords as given by as given by *CSS Color Module Level 3*
colour.notation.datasets.css_color_3.CSS_COLOR_3

# The list of basic colour keywords. The colour names are ASCII case-insensitive.
colour.notation.datasets.css_color_3.CSS_COLOR_3_BASIC

# The list of the X11 colors supported by popular browsers with the addition of
colour.notation.datasets.css_color_3.CSS_COLOR_3_EXTENDED

# Built-in immutable sequence.
colour.notation.datasets.munsell.all.MUNSELL_COLOURS_ALL

# Built-in immutable sequence.
colour.notation.datasets.munsell.experimental.MUNSELL_COLOURS_1929

# Built-in immutable sequence.
colour.notation.datasets.munsell.real.MUNSELL_COLOURS_REAL

# Convert from hexadecimal representation to *RGB* colourspace.
colour.notation.hexadecimal.HEX_to_RGB

# Convert from *RGB* colourspace to hexadecimal representation.
colour.notation.hexadecimal.RGB_to_HEX

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.notation.munsell.CCS_ILLUMINANT_MUNSELL

# str(object='') -> str
colour.notation.munsell.ILLUMINANT_NAME_MUNSELL

# Convert from *CIE L\*C\*Hab* colourspace to approximate *Munsell*
colour.notation.munsell.LCHab_to_munsell_specification

# str(object='') -> str
colour.notation.munsell.MUNSELL_COLOUR_EXTENDED_FORMAT

# str(object='') -> str
colour.notation.munsell.MUNSELL_COLOUR_FORMAT

# str(object='') -> str
colour.notation.munsell.MUNSELL_COLOUR_PATTERN

# str(object='') -> str
colour.notation.munsell.MUNSELL_GRAY_EXTENDED_FORMAT

# str(object='') -> str
colour.notation.munsell.MUNSELL_GRAY_FORMAT

# str(object='') -> str
colour.notation.munsell.MUNSELL_GRAY_PATTERN

# Extend :class:`dict` type to provide a lookup by value(s).
colour.notation.munsell.MUNSELL_HUE_LETTER_CODES

# Supported *Munsell* value computation methods.
colour.notation.munsell.MUNSELL_VALUE_METHODS

# Return for a given *Munsell* *Colorlab* specification hue and *Munsell*
colour.notation.munsell.bounding_hues_from_renotation

# Convert from hue angle in degrees to the *Munsell* *Colorlab*
colour.notation.munsell.hue_angle_to_hue

# Convert from the *Munsell* *Colorlab* specification hue and *Munsell*
colour.notation.munsell.hue_to_ASTM_hue

# Convert from the *Munsell* *Colorlab* specification hue and *Munsell*
colour.notation.munsell.hue_to_hue_angle

# Return whether to use linear or radial interpolation when drawing ovoids
colour.notation.munsell.interpolation_method_from_renotation_ovoid

# Return if given *Munsell* *Colorlab* specification is a grey colour.
colour.notation.munsell.is_grey_munsell_colour

# Return whether given *Munsell* *Colorlab* specification is in
colour.notation.munsell.is_specification_in_renotation

# Return the maximum *Munsell* chroma from *Munsell Renotation System* data
colour.notation.munsell.maximum_chroma_from_renotation

# Retrieve a normalised *Munsell* *Colorlab* specification from given
colour.notation.munsell.munsell_colour_to_munsell_specification

# Convert given *Munsell* colour to *CIE xyY* colourspace.
colour.notation.munsell.munsell_colour_to_xyY

# Convert from *Munsell* *Colorlab* specification to given *Munsell* colour.
colour.notation.munsell.munsell_specification_to_munsell_colour

# Convert given *Munsell* *Colorlab* specification to *CIE xy* chromaticity
colour.notation.munsell.munsell_specification_to_xy

# Convert given *Munsell* *Colorlab* specification to *CIE xyY* colourspace.
colour.notation.munsell.munsell_specification_to_xyY

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_ASTMD1535

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_Ladd1955

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_McCamy1987

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_Moon1943

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_Munsell1933

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_Priest1920

# Return the *Munsell* value :math:`V` of given *luminance* :math:`Y` using
colour.notation.munsell.munsell_value_Saunderson1944

# Normalise given *Munsell* *Colorlab* specification.
colour.notation.munsell.normalise_munsell_specification

# Parse given *Munsell* colour and returns an intermediate *Munsell*
colour.notation.munsell.parse_munsell_colour

# Return given existing *Munsell* *Colorlab* specification *CIE xyY*
colour.notation.munsell.xyY_from_renotation

# Convert from *CIE xyY* colourspace to *Munsell* colour.
colour.notation.munsell.xyY_to_munsell_colour

# Convert from *CIE xyY* colourspace to *Munsell* *Colorlab* specification.
colour.notation.munsell.xyY_to_munsell_specification

# Convert given *Munsell* *Colorlab* specification to *CIE xy* chromaticity
colour.notation.munsell.xy_from_renotation_ovoid

# int([x]) -> integer
colour.phenomena.rayleigh.CONSTANT_AVERAGE_PRESSURE_MEAN_SEA_LEVEL

# int([x]) -> integer
colour.phenomena.rayleigh.CONSTANT_DEFAULT_ALTITUDE

# int([x]) -> integer
colour.phenomena.rayleigh.CONSTANT_DEFAULT_LATITUDE

# Convert a string or number to a floating-point number, if possible.
colour.phenomena.rayleigh.CONSTANT_STANDARD_AIR_TEMPERATURE

# int([x]) -> integer
colour.phenomena.rayleigh.CONSTANT_STANDARD_CO2_CONCENTRATION

# Return :math:`(6+3_p)/(6-7_p)`, the depolarisation term :math:`F(air)` or
colour.phenomena.rayleigh.F_air_Bates1984

# Return :math:`(6+3_p)/(6-7_p)`, the depolarisation term :math:`F(air)` or
colour.phenomena.rayleigh.F_air_Bodhaine1999

# Return :math:`(6+3_p)/(6-7_p)`, the depolarisation term :math:`F(air)` or
colour.phenomena.rayleigh.F_air_Penndorf1957

# Return :math:`(6+3_p)/(6-7_p)`, the depolarisation term :math:`F(air)` or
colour.phenomena.rayleigh.F_air_Young1981

# Return the depolarisation of nitrogen :math:`N_2` as function of
colour.phenomena.rayleigh.N2_depolarisation

# Return the depolarisation of oxygen :math:`O_2` as function of
colour.phenomena.rayleigh.O2_depolarisation

# Return the air refraction index :math:`n_s` from given wavelength
colour.phenomena.rayleigh.air_refraction_index_Bodhaine1999

# Return the air refraction index :math:`n_s` from given wavelength
colour.phenomena.rayleigh.air_refraction_index_Edlen1966

# Return the air refraction index :math:`n_s` from given wavelength
colour.phenomena.rayleigh.air_refraction_index_Peck1972

# Return the air refraction index :math:`n_s` from given wavelength
colour.phenomena.rayleigh.air_refraction_index_Penndorf1957

# Return the gravity :math:`g` in :math:`cm/s_2` (gal) representative of the
colour.phenomena.rayleigh.gravity_List1968

# Return the mean molecular weights :math:`m_a` for dry air as function of
colour.phenomena.rayleigh.mean_molecular_weights

# Return the molecular density :math:`N_s` (molecules :math:`cm^{-3}`)
colour.phenomena.rayleigh.molecular_density

# Return the *Rayleigh* optical depth :math:`T_r(\lambda)` as function of
colour.phenomena.rayleigh.rayleigh_optical_depth

# Return the *Rayleigh* optical depth :math:`T_r(\lambda)` as function of
colour.phenomena.rayleigh.rayleigh_scattering

# Return the scattering cross-section per molecule :math:`\sigma` of dry
colour.phenomena.rayleigh.scattering_cross_section

# Return the *Rayleigh* spectral distribution for given spectral shape.
colour.phenomena.rayleigh.sd_rayleigh_scattering

# Perform colour vision deficiency simulation on given *RGB* colourspace
colour.plotting.blindness.plot_cvd_simulation_Machado2009

# Plot and compares given colour checkers.
colour.plotting.characterisation.plot_multi_colour_checkers

# Plot given colour checker.
colour.plotting.characterisation.plot_single_colour_checker

# Plot blackbody colours.
colour.plotting.colorimetry.plot_blackbody_colours

# Plot given blackbody spectral radiance.
colour.plotting.colorimetry.plot_blackbody_spectral_radiance

# Plot given colour matching functions.
colour.plotting.colorimetry.plot_multi_cmfs

# Plot given illuminants spectral distributions.
colour.plotting.colorimetry.plot_multi_illuminant_sds

# Plot given *Lightness* functions.
colour.plotting.colorimetry.plot_multi_lightness_functions

# Plot given *Luminance* functions.
colour.plotting.colorimetry.plot_multi_luminance_functions

# Plot given spectral distributions.
colour.plotting.colorimetry.plot_multi_sds

# Plot given colour matching functions.
colour.plotting.colorimetry.plot_single_cmfs

# Plot given single illuminant spectral distribution.
colour.plotting.colorimetry.plot_single_illuminant_sd

# Plot given *Lightness* function.
colour.plotting.colorimetry.plot_single_lightness_function

# Plot given *Luminance* function.
colour.plotting.colorimetry.plot_single_luminance_function

# Plot given spectral distribution.
colour.plotting.colorimetry.plot_single_sd

# Plot the visible colours spectrum using given standard observer *CIE XYZ*
colour.plotting.colorimetry.plot_visible_spectrum

# Define a :class:`dict`-like object allowing to access key values using dot
colour.plotting.common.CONSTANTS_ARROW_STYLE

# Define a :class:`dict`-like object allowing to access key values using dot
colour.plotting.common.CONSTANTS_COLOUR_STYLE

# Define a data structure for a colour swatch.
colour.plotting.common.ColourSwatch

# Define the keyword argument types for the :func:`colour.plotting.artist`
colour.plotting.common.KwargsArtist

# Define the keyword argument types for the :func:`colour.plotting.camera`
colour.plotting.common.KwargsCamera

# Define the keyword argument types for the :func:`colour.plotting.render`
colour.plotting.common.KwargsRender

# Convert from *CIE XYZ* tristimulus values to the default plotting
colour.plotting.common.XYZ_to_plotting_colourspace

# Return the current figure and its axes or creates a new one.
colour.plotting.common.artist

# Set the camera settings.
colour.plotting.common.camera

# Return a colour cycle iterator using given colour map.
colour.plotting.common.colour_cycle

# Return *Colour* plotting style.
colour.plotting.common.colour_style

# Return the *RGB* colourspaces matching given filterers.
colour.plotting.common.filter_RGB_colourspaces

# Return the colour matching functions matching given filterers.
colour.plotting.common.filter_cmfs

# Return the colour checkers matching given filterers.
colour.plotting.common.filter_colour_checkers

# Return the illuminants matching given filterers.
colour.plotting.common.filter_illuminants

# Return mapping objects matching given filterers while passing through
colour.plotting.common.filter_passthrough

# Define a context manager setting temporarily a *Matplotlib* font scaling.
colour.plotting.common.font_scaling

# Add labels above given rectangles.
colour.plotting.common.label_rectangles

# Decorate a function to override *Matplotlib* style.
colour.plotting.common.override_style

# Plot given image.
colour.plotting.common.plot_image

# Plot given colours swatches.
colour.plotting.common.plot_multi_colour_swatches

# Plot given functions.
colour.plotting.common.plot_multi_functions

# Plot given colour swatch.
colour.plotting.common.plot_single_colour_swatch

# Plot given function.
colour.plotting.common.plot_single_function

# Render the current figure while adjusting various settings such as the
colour.plotting.common.render

# Set equal aspect ratio to given 3d axes.
colour.plotting.common.uniform_axes3d

# Update given settings collection, *in-place*, with given keyword arguments
colour.plotting.common.update_settings_collection

# Configure *Matplotlib* for headless testing.
colour.plotting.conftest.mpl_headless_backend

# Plot given chromatic adaptation model corresponding chromaticities
colour.plotting.corresponding.plot_corresponding_chromaticities_prediction

# dict() -> new empty dictionary
colour.plotting.datasets.astm_g_173.DATA_ASTMG173_DIRECT_CIRCUMSOLAR

# dict() -> new empty dictionary
colour.plotting.datasets.astm_g_173.DATA_ASTMG173_ETR

# dict() -> new empty dictionary
colour.plotting.datasets.astm_g_173.DATA_ASTMG173_GLOBAL_TILT

# Define the spectral distribution: the base object for spectral
colour.plotting.datasets.astm_g_173.SD_ASTMG173_DIRECT_CIRCUMSOLAR

# Define the spectral distribution: the base object for spectral
colour.plotting.datasets.astm_g_173.SD_ASTMG173_ETR

# Define the spectral distribution: the base object for spectral
colour.plotting.datasets.astm_g_173.SD_ASTMG173_GLOBAL_TILT

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.plotting.diagrams.LABELS_CHROMATICITY_DIAGRAM_DEFAULT

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.plotting.diagrams.METHODS_CHROMATICITY_DIAGRAM

# Return the *Spectral Locus* line vertices, i.e., positions, normals and
colour.plotting.diagrams.lines_spectral_locus

# Plot the *Chromaticity Diagram* according to given method.
colour.plotting.diagrams.plot_chromaticity_diagram

# Plot the *CIE 1931 Chromaticity Diagram*.
colour.plotting.diagrams.plot_chromaticity_diagram_CIE1931

# Plot the *CIE 1960 UCS Chromaticity Diagram*.
colour.plotting.diagrams.plot_chromaticity_diagram_CIE1960UCS

# Plot the *CIE 1976 UCS Chromaticity Diagram*.
colour.plotting.diagrams.plot_chromaticity_diagram_CIE1976UCS

# Plot the *Chromaticity Diagram* colours according to given method.
colour.plotting.diagrams.plot_chromaticity_diagram_colours

# Plot given spectral distribution chromaticity coordinates into the
colour.plotting.diagrams.plot_sds_in_chromaticity_diagram

# Plot given spectral distribution chromaticity coordinates into the
colour.plotting.diagrams.plot_sds_in_chromaticity_diagram_CIE1931

# Plot given spectral distribution chromaticity coordinates into the
colour.plotting.diagrams.plot_sds_in_chromaticity_diagram_CIE1960UCS

# Plot given spectral distribution chromaticity coordinates into the
colour.plotting.diagrams.plot_sds_in_chromaticity_diagram_CIE1976UCS

# Plot the *Spectral Locus* according to given method.
colour.plotting.diagrams.plot_spectral_locus

# Plot *Colour* automatic colour conversion graph using
colour.plotting.graph.plot_automatic_colour_conversion_graph

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.plotting.models.COLOURSPACE_MODELS_AXIS_ORDER

# Reorder the axes of given colourspace model :math:`a` array according to
colour.plotting.models.colourspace_model_axis_reorder

# Return *MacAdam (1942) Ellipses (Observer PGN)* coefficients according to
colour.plotting.models.ellipses_MacAdam1942

# Return the *Pointer's Gamut* line vertices, i.e., positions, normals and
colour.plotting.models.lines_pointer_gamut

# Plot given *RGB* colourspace array in the *Chromaticity Diagram* according
colour.plotting.models.plot_RGB_chromaticities_in_chromaticity_diagram

# Plot given *RGB* colourspace array in the *CIE 1931 Chromaticity Diagram*.
colour.plotting.models.plot_RGB_chromaticities_in_chromaticity_diagram_CIE1931

# Plot given *RGB* colourspace array in the
colour.plotting.models.plot_RGB_chromaticities_in_chromaticity_diagram_CIE1960UCS

# Plot given *RGB* colourspace array in the
colour.plotting.models.plot_RGB_chromaticities_in_chromaticity_diagram_CIE1976UCS

# Plot given *RGB* colourspaces in the *Chromaticity Diagram* according
colour.plotting.models.plot_RGB_colourspaces_in_chromaticity_diagram

# Plot given *RGB* colourspaces in the *CIE 1931 Chromaticity Diagram*.
colour.plotting.models.plot_RGB_colourspaces_in_chromaticity_diagram_CIE1931

# Plot given *RGB* colourspaces in the *CIE 1960 UCS Chromaticity Diagram*.
colour.plotting.models.plot_RGB_colourspaces_in_chromaticity_diagram_CIE1960UCS

# Plot given *RGB* colourspaces in the *CIE 1976 UCS Chromaticity Diagram*.
colour.plotting.models.plot_RGB_colourspaces_in_chromaticity_diagram_CIE1976UCS

# Plot given constant hue loci colour matches data such as that from
colour.plotting.models.plot_constant_hue_loci

# Plot *MacAdam (1942) Ellipses (Observer PGN)* in the
colour.plotting.models.plot_ellipses_MacAdam1942_in_chromaticity_diagram

# Plot *MacAdam (1942) Ellipses (Observer PGN)* in the
colour.plotting.models.plot_ellipses_MacAdam1942_in_chromaticity_diagram_CIE1931

# Plot *MacAdam (1942) Ellipses (Observer PGN)* in the
colour.plotting.models.plot_ellipses_MacAdam1942_in_chromaticity_diagram_CIE1960UCS

# Plot *MacAdam (1942) Ellipses (Observer PGN)* in the
colour.plotting.models.plot_ellipses_MacAdam1942_in_chromaticity_diagram_CIE1976UCS

# Plot given colour component transfer functions.
colour.plotting.models.plot_multi_cctfs

# Plot *Pointer's Gamut* according to given method.
colour.plotting.models.plot_pointer_gamut

# Plot given colourspace colour component transfer function.
colour.plotting.models.plot_single_cctf

# Plot given *Munsell* value functions.
colour.plotting.notation.plot_multi_munsell_value_functions

# Plot given *Lightness* function.
colour.plotting.notation.plot_single_munsell_value_function

# Plot a single *Rayleigh* scattering spectral distribution.
colour.plotting.phenomena.plot_single_sd_rayleigh_scattering

# Plot the blue sky.
colour.plotting.phenomena.plot_the_blue_sky

# Plot the colour quality data of given illuminants or light sources colour
colour.plotting.quality.plot_colour_quality_bars

# Plot the *Colour Quality Scale* (CQS) of given illuminants or light
colour.plotting.quality.plot_multi_sds_colour_quality_scales_bars

# Plot the *Colour Rendering Index* (CRI) of given illuminants or light
colour.plotting.quality.plot_multi_sds_colour_rendering_indexes_bars

# Plot the *Colour Quality Scale* (CQS) of given illuminant or light source
colour.plotting.quality.plot_single_sd_colour_quality_scale_bars

# Plot the *Colour Rendering Index* (CRI) of given illuminant or light
colour.plotting.quality.plot_single_sd_colour_rendering_index_bars

# Axis to plane mapping.
colour.plotting.section.MAPPING_AXIS_TO_PLANE

# Plot given *RGB* colourspace section colours along given axis and origin.
colour.plotting.section.plot_RGB_colourspace_section

# Plot the section colours of given *trimesh* hull along given axis and
colour.plotting.section.plot_hull_section_colours

# Plot the section contour of given *trimesh* hull along given axis and
colour.plotting.section.plot_hull_section_contour

# Plot the visible spectrum volume, i.e., *Rosch-MacAdam* colour solid,
colour.plotting.section.plot_visible_spectrum_section

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.plotting.temperature.LABELS_PLANCKIAN_LOCUS_DEFAULT

# Return the *Daylight Locus* line vertices, i.e., positions, normals and
colour.plotting.temperature.lines_daylight_locus

# Return the *Planckian Locus* line vertices, i.e., positions, normals and
colour.plotting.temperature.lines_planckian_locus

# Plot the *Daylight Locus* according to given method.
colour.plotting.temperature.plot_daylight_locus

# Plot the *Planckian Locus* according to given method.
colour.plotting.temperature.plot_planckian_locus

# Plot the *Planckian Locus* and given illuminants in the
colour.plotting.temperature.plot_planckian_locus_in_chromaticity_diagram

# Plot the *Planckian Locus* and given illuminants in
colour.plotting.temperature.plot_planckian_locus_in_chromaticity_diagram_CIE1931

# Plot the *Planckian Locus* and given illuminants in
colour.plotting.temperature.plot_planckian_locus_in_chromaticity_diagram_CIE1960UCS

# Plot the *Planckian Locus* and given illuminants in
colour.plotting.temperature.plot_planckian_locus_in_chromaticity_diagram_CIE1976UCS

# str(object='') -> str
colour.plotting.tm3018.components.ROOT_RESOURCES_ANSIIESTM3018

# Plot the 16 bin bars for given values according to
colour.plotting.tm3018.components.plot_16_bin_bars

# Plot the local chroma shifts according to
colour.plotting.tm3018.components.plot_colour_fidelity_indexes

# Plot *Color Vector Graphic* according to
colour.plotting.tm3018.components.plot_colour_vector_graphic

# Plot the local chroma shifts according to
colour.plotting.tm3018.components.plot_local_chroma_shifts

# Plot the local colour fidelities according to
colour.plotting.tm3018.components.plot_local_colour_fidelities

# Plot the local hue shifts according to
colour.plotting.tm3018.components.plot_local_hue_shifts

# Plot a comparison of the spectral distributions of a test emission source
colour.plotting.tm3018.components.plot_spectra_ANSIIESTM3018

# dict() -> new empty dictionary
colour.plotting.tm3018.report.CONSTANTS_REPORT_STYLE

# dict() -> new empty dictionary
colour.plotting.tm3018.report.CONSTANT_REPORT_PADDING_FULL

# dict() -> new empty dictionary
colour.plotting.tm3018.report.CONSTANT_REPORT_PADDING_INTERMEDIATE

# dict() -> new empty dictionary
colour.plotting.tm3018.report.CONSTANT_REPORT_PADDING_SIMPLE

# Built-in immutable sequence.
colour.plotting.tm3018.report.CONSTANT_REPORT_ROW_HEIGHT_RATIOS_FULL

# Built-in immutable sequence.
colour.plotting.tm3018.report.CONSTANT_REPORT_ROW_HEIGHT_RATIOS_INTERMEDIATE

# Built-in immutable sequence.
colour.plotting.tm3018.report.CONSTANT_REPORT_ROW_HEIGHT_RATIOS_SIMPLE

# Built-in immutable sequence.
colour.plotting.tm3018.report.CONSTANT_REPORT_SIZE_FULL

# Built-in immutable sequence.
colour.plotting.tm3018.report.CONSTANT_REPORT_SIZE_INTERMEDIATE

# Built-in immutable sequence.
colour.plotting.tm3018.report.CONSTANT_REPORT_SIZE_SIMPLE

# str(object='') -> str
colour.plotting.tm3018.report.CONTENT_REPORT_FOOTER

# str(object='') -> str
colour.plotting.tm3018.report.CONTENT_REPORT_HEADER

# Generate the *ANSI/IES TM-30-18 Colour Rendition Report* for given
colour.plotting.tm3018.report.plot_single_sd_colour_rendition_report

# Generate the full *ANSI/IES TM-30-18 Colour Rendition Report* for given
colour.plotting.tm3018.report.plot_single_sd_colour_rendition_report_full

# Generate the intermediate *ANSI/IES TM-30-18 Colour Rendition Report* for
colour.plotting.tm3018.report.plot_single_sd_colour_rendition_report_intermediate

# Generate the simple *ANSI/IES TM-30-18 Colour Rendition Report* for given
colour.plotting.tm3018.report.plot_single_sd_colour_rendition_report_simple

# Return an *RGB* identity cube made of quad geometric elements and its
colour.plotting.volume.RGB_identity_cube

# Return a grid on *CIE xy* plane made of quad geometric elements and its
colour.plotting.volume.nadir_grid

# Plot given *RGB* colourspaces gamuts in given reference colourspace.
colour.plotting.volume.plot_RGB_colourspaces_gamuts

# Plot given *RGB* colourspace array in a scatter plot.
colour.plotting.volume.plot_RGB_scatter

# Compute the reference illuminant correlated colour temperature
colour.quality.cfi2017.CCT_reference_illuminant

# Define the *CIE 2017 Colour Fidelity Index* (CFI) colour quality
colour.quality.cfi2017.ColourRendering_Specification_CIE2017

# Define the class storing *test colour samples* colorimetry data.
colour.quality.cfi2017.DataColorimetry_TCS_CIE2017

# str(object='') -> str
colour.quality.cfi2017.ROOT_RESOURCES_CIE2017

# Define the base object for spectral distribution shape.
colour.quality.cfi2017.SPECTRAL_SHAPE_CIE2017

# Return the *CIE 2017 Colour Fidelity Index* (CFI) :math:`R_f` of given
colour.quality.cfi2017.colour_fidelity_index_CIE2017

# Convert from colour-appearance difference to
colour.quality.cfi2017.delta_E_to_R_f

# Load the *CIE 2017 Test Colour Samples* dataset appropriate for the given
colour.quality.cfi2017.load_TCS_CIE2017

# Compute the reference illuminant for a given correlated colour temperature
colour.quality.cfi2017.sd_reference_illuminant

# Return the *test colour samples* colorimetry data under given test light
colour.quality.cfi2017.tcs_colorimetry_data

# Return the correlated colour temperature factor penalizing lamps with
colour.quality.cqs.CCT_factor

# Built-in immutable sequence.
colour.quality.cqs.COLOUR_QUALITY_SCALE_METHODS

# Define the *Colour Quality Scale* (CQS) colour rendering (quality)
colour.quality.cqs.ColourRendering_Specification_CQS

# Define the class storing *VS test colour samples* colorimetry data.
colour.quality.cqs.DataColorimetry_VS

# Define the class storing *VS test colour samples* colour quality scale
colour.quality.cqs.DataColourQualityScale_VS

# int([x]) -> integer
colour.quality.cqs.GAMUT_AREA_D65

# Return the *Colour Quality Scale* (CQS) of given spectral distribution
colour.quality.cqs.colour_quality_scale

# Return the *VS test colour samples* rendering scales.
colour.quality.cqs.colour_quality_scales

# Compute the root-mean-square average for given *Colour Quality Scale*
colour.quality.cqs.delta_E_RMS

# Return the gamut area :math:`G` covered by given *CIE L\*a\*b\**
colour.quality.cqs.gamut_area

# Return the *Colour Quality Scale* (CQS) for given :math:`\Delta E_{ab}`
colour.quality.cqs.scale_conversion

# Return the *VS test colour samples* colorimetry data.
colour.quality.cqs.vs_colorimetry_data

# Define the *Colour Rendering Index* (CRI) colour quality specification.
colour.quality.cri.ColourRendering_Specification_CRI

# Define the class storing *test colour samples* colorimetry data.
colour.quality.cri.DataColorimetry_TCS

# Define the class storing *test colour samples* colour rendering index data.
colour.quality.cri.DataColourQualityScale_TCS

# Return the *Colour Rendering Index* (CRI) :math:`Q_a` of given spectral
colour.quality.cri.colour_rendering_index

# Return the *test colour samples* rendering indexes :math:`Q_a`.
colour.quality.cri.colour_rendering_indexes

# Return the *test colour samples* colorimetry data.
colour.quality.cri.tcs_colorimetry_data

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.quality.datasets.tcs.APPROXIMATE_MUNSELL_NOTATIONS_TCS

# dict() -> new empty dictionary
colour.quality.datasets.tcs.DATA_TCS

# dict() -> new empty dictionary
colour.quality.datasets.tcs.INDEXES_TO_NAMES_TCS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.quality.datasets.tcs.SDS_TCS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.quality.datasets.vs.APPROXIMATE_MUNSELL_NOTATIONS_VS_NISTCQS74

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.quality.datasets.vs.APPROXIMATE_MUNSELL_NOTATIONS_VS_NISTCQS90

# dict() -> new empty dictionary
colour.quality.datasets.vs.DATA_VS

# dict() -> new empty dictionary
colour.quality.datasets.vs.INDEXES_TO_NAMES_VS

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.quality.datasets.vs.SDS_VS

# Define the base object for spectral distribution shape.
colour.quality.ssi.SPECTRAL_SHAPE_SSI

# Return the *Academy Spectral Similarity Index* (SSI) of given test
colour.quality.ssi.spectral_similarity_index

colour.quality.tm3018.ArrayLike

# Define the *ANSI/IES TM-30-18 Colour Fidelity Index* (CFI) colour quality
colour.quality.tm3018.ColourQuality_Specification_ANSIIESTM3018

# Define the *CIE 2017 Colour Fidelity Index* (CFI) colour quality
colour.quality.tm3018.ColourRendering_Specification_CIE2017

# Define the class storing *test colour samples* colorimetry data.
colour.quality.tm3018.DataColorimetry_TCS_CIE2017

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.quality.tm3018.NDArrayFloat

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.quality.tm3018.NDArrayInt

# Define the spectral distribution: the base object for spectral
colour.quality.tm3018.SpectralDistribution

# Deprecated alias to builtins.tuple.
colour.quality.tm3018.Tuple

colour.quality.tm3018.annotations

# Convert given variable :math:`a` to :class:`numpy.ndarray` using given
colour.quality.tm3018.as_float_array

# Convert given :math:`a` variable to :class:`numpy.floating` using given
colour.quality.tm3018.as_float_scalar

# Convert given variable :math:`a` to :class:`numpy.ndarray` using given
colour.quality.tm3018.as_int_array

# Compute the area of the polygon formed by the hue bin averages.
colour.quality.tm3018.averages_area

# Cast a value to a type.
colour.quality.tm3018.cast

# Return the *ANSI/IES TM-30-18 Colour Fidelity Index* (CFI) :math:`R_f`
colour.quality.tm3018.colour_fidelity_index_ANSIIESTM3018

# Return the *CIE 2017 Colour Fidelity Index* (CFI) :math:`R_f` of given
colour.quality.tm3018.colour_fidelity_index_CIE2017

# Add dunder methods based on the fields defined in the class.
colour.quality.tm3018.dataclass

# Convert from colour-appearance difference to
colour.quality.tm3018.delta_E_to_R_f

# NumPy
colour.quality.tm3018.np

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.datasets.dyer2017.BASIS_FUNCTIONS_DYER2017

# Define the base object for spectral distribution shape.
colour.recovery.datasets.dyer2017.SPECTRAL_SHAPE_BASIS_FUNCTIONS_DYER2017

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.datasets.mallett2019.DATA_BASIS_FUNCTIONS_sRGB_MALLETT2019

# Define the multi-spectral distributions: the base object for multi
colour.recovery.datasets.mallett2019.MSDS_BASIS_FUNCTIONS_sRGB_MALLETT2019

# Shape for *Mallett and Yuksel (2019)* *sRGB* colourspace basis functions:
colour.recovery.datasets.mallett2019.SPECTRAL_SHAPE_sRGB_MALLETT2019

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.datasets.otsu2018.BASIS_FUNCTIONS_OTSU2018

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.datasets.otsu2018.CLUSTER_MEANS_OTSU2018

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.datasets.otsu2018.SELECTOR_ARRAY_OTSU2018

# The spectral shape of *Otsu et al. (2018)* basis functions and means.
colour.recovery.datasets.otsu2018.SPECTRAL_SHAPE_OTSU2018

# dict() -> new empty dictionary
colour.recovery.datasets.smits1999.DATA_SMITS1999

# *Smits (1999)* spectral distributions.
colour.recovery.datasets.smits1999.SDS_SMITS1999

# Define a class for working with pre-computed lookup tables for the
colour.recovery.jakob2019.LUT3D_Jakob2019

# Define the base object for spectral distribution shape.
colour.recovery.jakob2019.SPECTRAL_SHAPE_JAKOB2019

# The exception used to stop :func:`scipy.optimize.minimize` once the
colour.recovery.jakob2019.StopMinimizationEarlyError

# Recover the spectral distribution of given *CIE XYZ* tristimulus values
colour.recovery.jakob2019.XYZ_to_sd_Jakob2019

# Rescale the dimensionless coefficients to given spectral shape.
colour.recovery.jakob2019.dimensionalise_coefficients

# Compute :math:`\Delta E_{76}` between the target colour and the colour
colour.recovery.jakob2019.error_function

# Compute the coefficients for *Jakob and Hanika (2019)* reflectance
colour.recovery.jakob2019.find_coefficients_Jakob2019

# Create a non-linear lightness scale, as described in *Jakob and Hanika
colour.recovery.jakob2019.lightness_scale

# Return a spectral distribution following the spectral model given by
colour.recovery.jakob2019.sd_Jakob2019

# Perform the *Principal Component Analysis* (PCA) on given camera *RGB*
colour.recovery.jiang2013.PCA_Jiang2013

# Recover the camera *RGB* sensitivities for given camera *RGB* values using
colour.recovery.jiang2013.RGB_to_msds_camera_sensitivities_Jiang2013

# Recover a single camera *RGB* sensitivity for given camera *RGB* values
colour.recovery.jiang2013.RGB_to_sd_camera_sensitivity_Jiang2013

# Recover the spectral distribution of given *RGB* colourspace array using
colour.recovery.mallett2019.RGB_to_sd_Mallett2019

# Perform the spectral primary decomposition as described in *Mallett and
colour.recovery.mallett2019.spectral_primary_decomposition_Mallett2019

# Define the base object for spectral distribution shape.
colour.recovery.meng2015.SPECTRAL_SHAPE_MENG2015

# Recover the spectral distribution of given *CIE XYZ* tristimulus values
colour.recovery.meng2015.XYZ_to_sd_Meng2015

# Store all the information needed for the *Otsu et al. (2018)* spectral
colour.recovery.otsu2018.DATASET_REFERENCE_OTSU2018

# Store the reference reflectances and derived information along with the
colour.recovery.otsu2018.Data_Otsu2018

# Store all the information needed for the *Otsu et al. (2018)* spectral
colour.recovery.otsu2018.Dataset_Otsu2018

# Represent a node in a :meth:`colour.recovery.Tree_Otsu2018` class instance
colour.recovery.otsu2018.Node_Otsu2018

# Represent a horizontal or vertical line, partitioning the 2D space in
colour.recovery.otsu2018.PartitionAxis

# A sub-class of :class:`colour.recovery.otsu2018.Node` class representing
colour.recovery.otsu2018.Tree_Otsu2018

# Recover the spectral distribution of given *CIE XYZ* tristimulus values
colour.recovery.otsu2018.XYZ_to_sd_Otsu2018

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.smits1999.CCS_WHITEPOINT_SMITS1999

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.recovery.smits1999.PRIMARIES_SMITS1999

# Implement support for the *RGB* colourspaces datasets from
colour.recovery.smits1999.RGB_COLOURSPACE_SMITS1999

# Recover the spectral distribution of given *RGB* colourspace array using
colour.recovery.smits1999.RGB_to_sd_Smits1999

# str(object='') -> str
colour.recovery.smits1999.WHITEPOINT_NAME_SMITS1999

# Convert from *CIE XYZ* tristimulus values to *RGB* colourspace with
colour.recovery.smits1999.XYZ_to_RGB_Smits1999

# Return the *CIE xy* chromaticity coordinates of a
colour.temperature.cie_d.CCT_to_xy_CIE_D

# Return the correlated colour temperature :math:`T_{cp}` of a
colour.temperature.cie_d.xy_to_CCT_CIE_D

# Return the *CIE xy* chromaticity coordinates from given correlated colour
colour.temperature.hernandez1999.CCT_to_xy_Hernandez1999

# Return the correlated colour temperature :math:`T_{cp}` from given
colour.temperature.hernandez1999.xy_to_CCT_Hernandez1999

# Return the *CIE xy* chromaticity coordinates from given correlated colour
colour.temperature.kang2002.CCT_to_xy_Kang2002

# Return the correlated colour temperature :math:`T_{cp}` from given
colour.temperature.kang2002.xy_to_CCT_Kang2002

# Return the *CIE UCS* colourspace *uv* chromaticity coordinates from given
colour.temperature.krystek1985.CCT_to_uv_Krystek1985

# Return the correlated colour temperature :math:`T_{cp}` from given
colour.temperature.krystek1985.uv_to_CCT_Krystek1985

# Return the *CIE xy* chromaticity coordinates from given correlated colour
colour.temperature.mccamy1992.CCT_to_xy_McCamy1992

# Return the correlated colour temperature :math:`T_{cp}` from given
colour.temperature.mccamy1992.xy_to_CCT_McCamy1992

# Convert a string or number to a floating-point number, if possible.
colour.temperature.ohno2013.CCT_DEFAULT_SPACING_OHNO2013

# int([x]) -> integer
colour.temperature.ohno2013.CCT_MAXIMAL_OHNO2013

# int([x]) -> integer
colour.temperature.ohno2013.CCT_MINIMAL_OHNO2013

# Return the *CIE XYZ* tristimulus values from given correlated colour
colour.temperature.ohno2013.CCT_to_XYZ_Ohno2013

# Return the *CIE UCS* colourspace *uv* chromaticity coordinates from given
colour.temperature.ohno2013.CCT_to_uv_Ohno2013

# Return the correlated colour temperature :math:`T_{cp}` and
colour.temperature.ohno2013.XYZ_to_CCT_Ohno2013

# Return a planckian table from given *CIE UCS* colourspace *uv*
colour.temperature.ohno2013.planckian_table

# Return the correlated colour temperature :math:`T_{cp}` and
colour.temperature.ohno2013.uv_to_CCT_Ohno2013

# Return the *CIE UCS* colourspace *uv* chromaticity coordinates from given
colour.temperature.planck1900.CCT_to_uv_Planck1900

# Return the correlated colour temperature :math:`T_{cp}` of a blackbody from
colour.temperature.planck1900.uv_to_CCT_Planck1900

# Convert given correlated colour temperature :math:`T_{cp}` to micro
colour.temperature.robertson1968.CCT_to_mired

# Return the *CIE UCS* colourspace *uv* chromaticity coordinates from given
colour.temperature.robertson1968.CCT_to_uv_Robertson1968

# Built-in immutable sequence.
colour.temperature.robertson1968.DATA_ISOTEMPERATURE_LINES_ROBERTSON1968

# Built-in mutable sequence.
colour.temperature.robertson1968.ISOTEMPERATURE_LINES_ROBERTSON1968

# Define the data for a *Roberston (1968)* iso-temperature line.
colour.temperature.robertson1968.ISOTemperatureLine_Specification_Robertson1968

# Convert given micro reciprocal degree to correlated colour temperature
colour.temperature.robertson1968.mired_to_CCT

# Return the correlated colour temperature :math:`T_{cp}` and
colour.temperature.robertson1968.uv_to_CCT_Robertson1968

# A mixin providing mathematical operations for :class:`dataclass`-like
colour.utilities.array.MixinDataclassArithmetic

# A mixin providing conversion methods for :class:`dataclass`-like class
colour.utilities.array.MixinDataclassArray

# A mixin providing fields introspection for the :class:`dataclass`-like
colour.utilities.array.MixinDataclassFields

# A mixin providing iteration capabilities over the :class:`dataclass`-like
colour.utilities.array.MixinDataclassIterable

# Convert given variable :math:`a` to :class:`numpy.ndarray` using given
colour.utilities.array.as_array

# Attempt to convert given variable :math:`a` to :class:`numpy.floating`
colour.utilities.array.as_float

# Convert given variable :math:`a` to :class:`numpy.ndarray` using given
colour.utilities.array.as_float_array

# Convert given :math:`a` variable to :class:`numpy.floating` using given
colour.utilities.array.as_float_scalar

# Attempt to convert given variable :math:`a` to :class:`numpy.integer`
colour.utilities.array.as_int

# Convert given variable :math:`a` to :class:`numpy.ndarray` using given
colour.utilities.array.as_int_array

# Convert given :math:`a` variable to :class:`numpy.integer` using given
colour.utilities.array.as_int_scalar

# Return the centroid indexes of given array :math:`a`.
colour.utilities.array.centroid

# Return the closest array :math:`a` elements to the reference array
colour.utilities.array.closest

# Return the array :math:`a` closest element indexes to the reference array
colour.utilities.array.closest_indexes

# Define context manager and decorator temporarily setting *Colour*
colour.utilities.array.domain_range_scale

# Fill given array :math:`a` NaN values according to given method.
colour.utilities.array.fill_nan

# Format given array :math:`a` as a row.
colour.utilities.array.format_array_as_row

# Scale given array :math:`a` from range **'1'**. The behaviour is as
colour.utilities.array.from_range_1

# Scale given array :math:`a` from range **'10'**, used by
colour.utilities.array.from_range_10

# Scale given array :math:`a` from range **'100'**. The behaviour is as
colour.utilities.array.from_range_100

# Scale given array :math:`a` from degrees range. The behaviour is as
colour.utilities.array.from_range_degrees

# Scale given array :math:`a` from int range. The behaviour is as follows:
colour.utilities.array.from_range_int

# Wrap :func:`np.full` definition to create an array with the active type
colour.utilities.array.full

# Return the current *Colour* domain-range scale. The following scales are
colour.utilities.array.get_domain_range_scale

# Return whether given array :math:`a` contains only NaN values.
colour.utilities.array.has_only_nan

# Return whether each element of the array :math:`a` is also present in the
colour.utilities.array.in_array

# Reduce the dimension of array :math:`a` by one, by using an array of
colour.utilities.array.index_along_last_axis

# Return the interval size of given distribution.
colour.utilities.array.interval

# Return whether *Colour* :class:`numpy.ndarray` copy is enabled: Various API
colour.utilities.array.is_ndarray_copy_enabled

# Return whether given distribution is uniform.
colour.utilities.array.is_uniform

# Return a :class:`numpy.ndarray` copy if the relevant *Colour* state is
colour.utilities.array.ndarray_copy

# Define a context manager and decorator temporarily setting *Colour*
colour.utilities.array.ndarray_copy_enable

# Define a context manager setting given array :math:`a` writeable to
colour.utilities.array.ndarray_write

# Wrap :func:`np.ones` definition to create an array with the active
colour.utilities.array.ones

# Orient given array :math:`a` according to given orientation.
colour.utilities.array.orient

# Return the rows of given array :math:`a` as diagonal matrices.
colour.utilities.array.row_as_diagonal

# Set *Colour* default :class:`numpy.floating` precision by setting
colour.utilities.array.set_default_float_dtype

# Set *Colour* default :class:`numpy.integer` precision by setting
colour.utilities.array.set_default_int_dtype

# Set the current *Colour* domain-range scale. The following scales are
colour.utilities.array.set_domain_range_scale

# Set *Colour* :class:`numpy.ndarray` copy enabled state.
colour.utilities.array.set_ndarray_copy_enable

# Scale given array :math:`a` to domain **'1'**. The behaviour is as
colour.utilities.array.to_domain_1

# Scale given array :math:`a` to domain **'10'**, used by
colour.utilities.array.to_domain_10

# Scale given array :math:`a` to domain **'100'**. The behaviour is as
colour.utilities.array.to_domain_100

# Scale given array :math:`a` to degrees domain. The behaviour is as
colour.utilities.array.to_domain_degrees

# Scale given array :math:`a` to int domain. The behaviour is as follows:
colour.utilities.array.to_domain_int

# Split given stacked array :math:`a` along the last axis (tail) to produce
colour.utilities.array.tsplit

# Stack given array of arrays :math:`a` along the last axis (tail) to
colour.utilities.array.tstack

# Wrap :func:`np.zeros` definition to create an array with the active
colour.utilities.array.zeros

# Define a callback.
colour.utilities.callback.Callback

# A mixin providing support for callbacks.
colour.utilities.callback.MixinCallback

# A registry for mapping-based caches.
colour.utilities.common.CACHE_REGISTRY

# A registry for mapping-based caches.
colour.utilities.common.CacheRegistry

# Provide the `assert` statement functionality without being disabled by
colour.utilities.common.attest

# Return a batch generator from given sequence.
colour.utilities.common.batch

# Define a context manager and decorator temporarily setting *Colour* caching
colour.utilities.common.caching_enable

# Copy a definition using the same code, globals, defaults, closure, and
colour.utilities.common.copy_definition

# Define a context manager and decorator to temporarily disabling *Colour*
colour.utilities.common.disable_multiprocessing

# Filter keyword arguments incompatible with the given function signature.
colour.utilities.common.filter_kwargs

# Filter given mapping with given names.
colour.utilities.common.filter_mapping

# Return the first item of given iterable.
colour.utilities.common.first_item

# Decorate a function to handle *Numpy* errors.
colour.utilities.common.handle_numpy_errors

# Wrap given function wrapper.
colour.utilities.common.ignore_numpy_errors

# Decorate a function to ignore *Python* warnings.
colour.utilities.common.ignore_python_warnings

# Return the hash value for the given object.
colour.utilities.common.int_digest

# Return whether *Colour* caching is enabled.
colour.utilities.common.is_caching_enabled

# Return whether given variable :math:`a` is an :class:`numpy.integer`-like
colour.utilities.common.is_integer

# Return whether given variable :math:`a` is iterable.
colour.utilities.common.is_iterable

# Return whether given variable :math:`a` is a :class:`Real`-like
colour.utilities.common.is_numeric

# Return whether given element type is present in given mapping types.
colour.utilities.common.is_sibling

# Define a context manager providing a multiprocessing pool.
colour.utilities.common.multiprocessing_pool

# Handle optional argument value by providing a default value.
colour.utilities.common.optional

# Wrap given function wrapper.
colour.utilities.common.print_numpy_errors

# Wrap given function wrapper.
colour.utilities.common.raise_numpy_errors

# Set *Colour* caching enabled state.
colour.utilities.common.set_caching_enable

# Generate a *SEO* friendly and human-readable slug from given object.
colour.utilities.common.slugify

# Validate whether given method exists in the given valid methods and
colour.utilities.common.validate_method

# Wrap given function wrapper.
colour.utilities.common.warn_numpy_errors

# A class used for future argument removal.
colour.utilities.deprecation.ArgumentFutureRemove

# A class used for future argument name deprecation, i.e., argument name will
colour.utilities.deprecation.ArgumentFutureRename

# A class used for an argument that has been removed.
colour.utilities.deprecation.ArgumentRemoved

# A class used for an argument that has been renamed.
colour.utilities.deprecation.ArgumentRenamed

# Define a class that allows customisation of module attributes access with
colour.utilities.deprecation.ModuleAPI

# A class used for future object access deprecation, i.e., object access will
colour.utilities.deprecation.ObjectFutureAccessChange

# A class used for future object access removal, i.e., object access will
colour.utilities.deprecation.ObjectFutureAccessRemove

# A class used for future object removal.
colour.utilities.deprecation.ObjectFutureRemove

# A class used for future object name deprecation, i.e., object name will
colour.utilities.deprecation.ObjectFutureRename

# A class used for an object that has been removed.
colour.utilities.deprecation.ObjectRemoved

# A class used for an object that has been renamed.
colour.utilities.deprecation.ObjectRenamed

# Build the effective API changes for a desired API changes mapping.
colour.utilities.deprecation.build_API_changes

# Return given attribute value.
colour.utilities.deprecation.get_attribute

# Handle arguments deprecation according to desired API changes mapping.
colour.utilities.deprecation.handle_arguments_deprecation

# A :class:`dict` sub-class that allows settings a docstring to :class:`dict`
colour.utilities.documentation.DocstringDict

# A :class:`float` sub-class that allows settings a docstring to
colour.utilities.documentation.DocstringFloat

# A :class:`numpy.integer` sub-class that allows settings a docstring to
colour.utilities.documentation.DocstringInt

# A :class:`str` sub-class that allows settings a docstring to
colour.utilities.documentation.DocstringText

# A :class:`tuple` sub-class that allows settings a docstring to
colour.utilities.documentation.DocstringTuple

# Return whether the documentation is being built by checking whether the
colour.utilities.documentation.is_documentation_building

# Compute the mean squared error (MSE) or mean squared deviation (MSD)
colour.utilities.metrics.metric_mse

# Compute the peak signal-to-noise ratio (PSNR) between given variables
colour.utilities.metrics.metric_psnr

# Define a class inherited by control flow nodes.
colour.utilities.network.ControlFlowNode

# Define a class inherited by control flow nodes.
colour.utilities.network.ControlFlowNode

# Define a special node with execution input and output ports.
colour.utilities.network.ExecutionNode

# Define a special port for nodes supporting execution input and output
colour.utilities.network.ExecutionPort

# Define a ``for`` loop node.
colour.utilities.network.For

# Define an advanced ``for`` loop node distributing the work across multiple
colour.utilities.network.ParallelForMultiprocess

# Define an advanced ``for`` loop node distributing the work across multiple
colour.utilities.network.ParallelForThread

# Define an object that can be added either as an input or output port,
colour.utilities.network.Port

# Define a node-graph for :class:`colour.utilities.PortNode` class instances.
colour.utilities.network.PortGraph

# Define a node with support for input and output ports.
colour.utilities.network.PortNode

# Represent a basic node supporting the creation of basic node trees.
colour.utilities.network.TreeNode

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.utilities.requirements.REQUIREMENTS_TO_CALLABLE

# Return whether *ctlrender* is installed and available.
colour.utilities.requirements.is_ctlrender_installed

# Return whether *Matplotlib* is installed and available.
colour.utilities.requirements.is_matplotlib_installed

# Return whether *NetworkX* is installed and available.
colour.utilities.requirements.is_networkx_installed

# Return whether *OpenColorIO* is installed and available.
colour.utilities.requirements.is_opencolorio_installed

# Return whether *OpenImageIO* is installed and available.
colour.utilities.requirements.is_openimageio_installed

# Return whether *Pandas* is installed and available.
colour.utilities.requirements.is_pandas_installed

# Return whether *Pydot* is installed and available. The presence of
colour.utilities.requirements.is_pydot_installed

# Return whether *tqdm* is installed and available.
colour.utilities.requirements.is_tqdm_installed

# Return whether *Trimesh* is installed and available.
colour.utilities.requirements.is_trimesh_installed

# Return whether *xxhash* is installed and available.
colour.utilities.requirements.is_xxhash_installed

# Decorate a function to check whether various ancillary package requirements
colour.utilities.requirements.required

# Implement a delimiter and case-insensitive :class:`dict`-like object with
colour.utilities.structures.CanonicalMapping

# Implement a lazy delimiter and case-insensitive :class:`dict`-like object
colour.utilities.structures.LazyCanonicalMapping

# Extend :class:`dict` type to provide a lookup by value(s).
colour.utilities.structures.Lookup

# Define a :class:`dict`-like object allowing to access key values using dot
colour.utilities.structures.Structure

# dict() -> new empty dictionary
colour.utilities.verbose.ANCILLARY_COLOUR_SCIENCE_PACKAGES

# dict() -> new empty dictionary
colour.utilities.verbose.ANCILLARY_DEVELOPMENT_PACKAGES

# dict() -> new empty dictionary
colour.utilities.verbose.ANCILLARY_EXTRAS_PACKAGES

# dict() -> new empty dictionary
colour.utilities.verbose.ANCILLARY_RUNTIME_PACKAGES

# Define the base class of *Colour* runtime warnings.
colour.utilities.verbose.ColourRuntimeWarning

# Define the base class of *Colour* usage warnings.
colour.utilities.verbose.ColourUsageWarning

# Define the base class of *Colour* warnings.
colour.utilities.verbose.ColourWarning

# Instances of the Logger class represent a single logging channel. A
colour.utilities.verbose.LOGGER

# A mixin providing a convenient logging method.
colour.utilities.verbose.MixinLogging

# Convert given string to bool.
colour.utilities.verbose.as_bool

# Describe *Colour* running environment, i.e., interpreter, runtime and
colour.utilities.verbose.describe_environment

# Filter *Colour* and also optionally overall Python warnings.
colour.utilities.verbose.filter_warnings

# Print a message inside a box.
colour.utilities.verbose.message_box

# Return an (almost) evaluable string representation of the given object.
colour.utilities.verbose.multiline_repr

# Return a formatted string representation of the given object.
colour.utilities.verbose.multiline_str

# Define a context manager implementing context changes to *Numpy* print
colour.utilities.verbose.numpy_print_options

# Issue a runtime warning.
colour.utilities.verbose.runtime_warning

# Alternative :func:`warnings.showwarning` definition that allows traceback
colour.utilities.verbose.show_warning

# Define a context manager and decorator temporarily suppressing standard
colour.utilities.verbose.suppress_stdout

# Define a context manager filtering *Colour* and also optionally overall
colour.utilities.verbose.suppress_warnings

# Issue a usage warning.
colour.utilities.verbose.usage_warning

# Issue a warning.
colour.utilities.verbose.warning

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.volume.datasets.optimal_colour_stimuli.OPTIMAL_COLOUR_STIMULI_A

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.volume.datasets.optimal_colour_stimuli.OPTIMAL_COLOUR_STIMULI_C

# ndarray(shape, dtype=float, buffer=None, offset=0,
colour.volume.datasets.optimal_colour_stimuli.OPTIMAL_COLOUR_STIMULI_D65

# Illuminants *Optimal Colour Stimuli*.
colour.volume.datasets.optimal_colour_stimuli.OPTIMAL_COLOUR_STIMULI_ILLUMINANTS

# Return whether given *CIE xyY* colourspace array is within MacAdam limits
colour.volume.macadam_limits.is_within_macadam_limits

# Return whether given points are within given mesh volume using Delaunay
colour.volume.mesh.is_within_mesh_volume

# Return whether given *CIE XYZ* tristimulus values are within Pointer's
colour.volume.pointer_gamut.is_within_pointer_gamut

# Compute given *RGB* colourspace volume limits in *CIE L\*a\*b\**
colour.volume.rgb.RGB_colourspace_limits

# Return given *RGB* colourspace percentage coverage of Pointer's Gamut
colour.volume.rgb.RGB_colourspace_pointer_gamut_coverage_MonteCarlo

# Return given *RGB* colourspace percentage coverage of visible spectrum
colour.volume.rgb.RGB_colourspace_visible_spectrum_coverage_MonteCarlo

# Perform given *RGB* colourspace volume computation using *Monte Carlo*
colour.volume.rgb.RGB_colourspace_volume_MonteCarlo

# Return given *RGB* colourspace percentage coverage of an arbitrary volume.
colour.volume.rgb.RGB_colourspace_volume_coverage_MonteCarlo

# Randomly sample the *CIE L\*a\*b\** colourspace volume and returns the
colour.volume.rgb.sample_RGB_colourspace_volume_MonteCarlo

# Define the base object for spectral distribution shape.
colour.volume.spectrum.SPECTRAL_SHAPE_OUTER_SURFACE_XYZ

# Generate the *Rosch-MacAdam* colour solid, i.e., *CIE XYZ* colourspace
colour.volume.spectrum.XYZ_outer_surface

# Generate the pulse waves of given number of bins necessary to totally
colour.volume.spectrum.generate_pulse_waves

# Return whether given *CIE XYZ* tristimulus values are within the visible
colour.volume.spectrum.is_within_visible_spectrum

# Generate the *Rosch-MacAdam* colour solid, i.e., *CIE XYZ* colourspace
colour.volume.spectrum.solid_RoschMacAdam

