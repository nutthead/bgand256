Warning: Could not import scipy.conftest: No module named 'hypothesis'
Warning: Module scipy.linalg._decomp_interpolative has no attribute idd_ldiv: module 'scipy.linalg._decomp_interpolative' has no attribute 'idd_ldiv'
Warning: Module scipy.linalg._decomp_interpolative has no attribute idd_poweroftwo: module 'scipy.linalg._decomp_interpolative' has no attribute 'idd_poweroftwo'
Warning: Module scipy.linalg._decomp_interpolative has no attribute idz_id2svdidd_findrank: module 'scipy.linalg._decomp_interpolative' has no attribute 'idz_id2svdidd_findrank'
Warning: Could not import scipy.special._precompute.cosine_cdf: No module named 'mpmath'
Warning: Could not import scipy.special._precompute.struve_convergence: No module named 'mpmath'
# Show libraries and system information on which SciPy was built
scipy.__config__.show

scipy._cyutility.Enum

scipy._cyutility.array

scipy._cyutility.memoryview

# Returns True when the argument is true, False otherwise.
scipy._lib._array_api.SCIPY_ARRAY_API

# str(object='') -> str
scipy._lib._array_api.SCIPY_DEVICE

# SciPy-specific replacement for `np.asarray` with `order`, `check_finite`, and
scipy._lib._array_api._asarray

# Get the array API compatible namespace for the arrays xs.
scipy._lib._array_api.array_namespace

# Backwards compatible replacement. In new code, use xp_assert_close instead.
scipy._lib._array_api.assert_almost_equal

# Backwards compatible replacement. In new code, use xp_assert_close instead.
scipy._lib._array_api.assert_array_almost_equal

# In all ``xp_assert_*`` and ``assert_*`` function calls executed within this
scipy._lib._array_api.default_xp

# pytest.warns context manager, but only if x is not a lazy array.
scipy._lib._array_api.eager_warns

# Returns True if `xp` is an array-api-strict namespace.
scipy._lib._array_api.is_array_api_strict

scipy._lib._array_api.is_complex

# Returns True if `xp` is a CuPy namespace.
scipy._lib._array_api.is_cupy

# Returns True if `xp` is a JAX namespace.
scipy._lib._array_api.is_jax

# Return True if x is potentially a future or it may be otherwise impossible or
scipy._lib._array_api.is_lazy_array

# Returns True if `xp` is an MArray namespace; False otherwise.
scipy._lib._array_api.is_marray

# Returns True if `xp` is a NumPy namespace.
scipy._lib._array_api.is_numpy

# Returns True if `xp` is a PyTorch namespace.
scipy._lib._array_api.is_torch

# Return the `scipy`-like namespace of a non-NumPy backend
scipy._lib._array_api.scipy_namespace_for

scipy._lib._array_api.xp_assert_close

scipy._lib._array_api.xp_assert_equal

scipy._lib._array_api.xp_assert_less

# Decorator for a function that states its support among various
scipy._lib._array_api.xp_capabilities

# Copies an array.
scipy._lib._array_api.xp_copy

# Hardware device the array data resides on.
scipy._lib._array_api.xp_device

# Promotes elements of *args to result dtype, ignoring `None`s.
scipy._lib._array_api.xp_promote

scipy._lib._array_api.xp_ravel

# Returns the dtype that results from applying type promotion rules
scipy._lib._array_api.xp_result_type

# Return the total number of elements of x.
scipy._lib._array_api.xp_size

scipy._lib._array_api.xp_unsupported_param_msg

scipy._lib._array_api.xp_vector_norm

# Get the array API compatible namespace for the arrays xs.
scipy._lib._array_api_compat_vendor.array_namespace

scipy._lib._array_api_compat_vendor.common

# Hardware device the array data resides on.
scipy._lib._array_api_compat_vendor.device

# Get the array API compatible namespace for the arrays `xs`.
scipy._lib._array_api_compat_vendor.get_namespace

# Return True if `x` is an array API compatible array object.
scipy._lib._array_api_compat_vendor.is_array_api_obj

# Returns True if `xp` is an array-api-strict namespace.
scipy._lib._array_api_compat_vendor.is_array_api_strict_namespace

# Return True if `x` is a CuPy array.
scipy._lib._array_api_compat_vendor.is_cupy_array

# Returns True if `xp` is a CuPy namespace.
scipy._lib._array_api_compat_vendor.is_cupy_namespace

# Return True if `x` is a dask.array Array.
scipy._lib._array_api_compat_vendor.is_dask_array

# Returns True if `xp` is a Dask namespace.
scipy._lib._array_api_compat_vendor.is_dask_namespace

# Return True if `x` is a JAX array.
scipy._lib._array_api_compat_vendor.is_jax_array

# Returns True if `xp` is a JAX namespace.
scipy._lib._array_api_compat_vendor.is_jax_namespace

# Return True if x is potentially a future or it may be otherwise impossible or
scipy._lib._array_api_compat_vendor.is_lazy_array

# Return True if `x` is a ndonnx Array.
scipy._lib._array_api_compat_vendor.is_ndonnx_array

# Returns True if `xp` is an NDONNX namespace.
scipy._lib._array_api_compat_vendor.is_ndonnx_namespace

# Return True if `x` is a NumPy array.
scipy._lib._array_api_compat_vendor.is_numpy_array

# Returns True if `xp` is a NumPy namespace.
scipy._lib._array_api_compat_vendor.is_numpy_namespace

# Return True if `x` is an array from the `sparse` package.
scipy._lib._array_api_compat_vendor.is_pydata_sparse_array

# Returns True if `xp` is a pydata/sparse namespace.
scipy._lib._array_api_compat_vendor.is_pydata_sparse_namespace

# Return True if `x` is a PyTorch tensor.
scipy._lib._array_api_compat_vendor.is_torch_array

# Returns True if `xp` is a PyTorch namespace.
scipy._lib._array_api_compat_vendor.is_torch_namespace

# Return False if ``x.__setitem__`` is expected to raise; True otherwise.
scipy._lib._array_api_compat_vendor.is_writeable_array

scipy._lib._array_api_compat_vendor.numpy

# Get the array API compatible namespace for the arrays xs.
scipy._lib._array_api_compat_vendor.scipy_array_namespace

# Return the total number of elements of x.
scipy._lib._array_api_compat_vendor.size

# Copy the array from the device on which it currently resides to the specified ``device``.
scipy._lib._array_api_compat_vendor.to_device

scipy._lib._ccallback.CData

# Low-level callback function.
scipy._lib._ccallback.LowLevelCallable

# Function Pointer
scipy._lib._ccallback.PyCFuncPtr

# create and manipulate C data types in Python
scipy._lib._ccallback.ctypes

# The type of the None singleton.
scipy._lib._ccallback.ffi

# check_capsule(item)
scipy._lib._ccallback_c.check_capsule

# create and manipulate C data types in Python
scipy._lib._ccallback_c.ctypes

scipy._lib._ccallback_c.get_capsule_signature

# get_raw_capsule(ptr, name, context)
scipy._lib._ccallback_c.get_raw_capsule

# int([x]) -> integer
scipy._lib._ccallback_c.idx

scipy._lib._ccallback_c.plus1_ctypes

scipy._lib._ccallback_c.plus1_t

scipy._lib._ccallback_c.plus1b_ctypes

scipy._lib._ccallback_c.plus1b_t

scipy._lib._ccallback_c.plus1bc_ctypes

scipy._lib._ccallback_c.plus1bc_t

# Built-in immutable sequence.
scipy._lib._ccallback_c.sig

# Built-in mutable sequence.
scipy._lib._ccallback_c.sigs

scipy._lib._ccallback_c.sine_ctypes

scipy._lib._ccallback_c.sine_t

# Implementation of a caller routine in Cython
scipy._lib._ccallback_c.test_call_cython

# Disjoint set data structure for incremental connectivity queries.
scipy._lib._disjoint_set.DisjointSet

scipy._lib._docscrape.Callable

scipy._lib._docscrape.ClassDoc

scipy._lib._docscrape.FunctionDoc

# A Mapping is a generic container for associating key/value
scipy._lib._docscrape.Mapping

# Parses a numpydoc string to an abstract representation
scipy._lib._docscrape.NumpyDocString

scipy._lib._docscrape.ObjDoc

# Parameter(name, type, desc)
scipy._lib._docscrape.Parameter

scipy._lib._docscrape.ParseError

# A line-based string reader.
scipy._lib._docscrape.Reader

scipy._lib._docscrape.cached_property

# Generic (shallow and deep) copying operations.
scipy._lib._docscrape.copy

# Deindent a list of lines maximally
scipy._lib._docscrape.dedent_lines

scipy._lib._docscrape.get_doc_object

# Get useful information from live Python objects.
scipy._lib._docscrape.inspect

# Returns a new subclass of tuple with named fields.
scipy._lib._docscrape.namedtuple

# Generate Python documentation in HTML or text for interactive use.
scipy._lib._docscrape.pydoc

# Support for regular expressions (RE).
scipy._lib._docscrape.re

# Remove leading and trailing blank lines from a list of lines
scipy._lib._docscrape.strip_blank_lines

# This module provides access to some objects used or maintained by the
scipy._lib._docscrape.sys

# Text wrapping and filling.
scipy._lib._docscrape.textwrap

# Issue a warning, or maybe ignore it or raise an exception.
scipy._lib._docscrape.warn

# Get the array API compatible namespace for the arrays xs.
scipy._lib._elementwise_iterative_method.array_namespace

# This module provides access to the mathematical functions
scipy._lib._elementwise_iterative_method.math

# NumPy
scipy._lib._elementwise_iterative_method.np

# Returns the dtype that results from applying type promotion rules
scipy._lib._elementwise_iterative_method.xp_result_type

# Return the total number of elements of x.
scipy._lib._elementwise_iterative_method.xp_size

# Extra array functions built on top of the array API standard.
scipy._lib._elementwise_iterative_method.xpx

# get_fpu_mode()
scipy._lib._fpumode.get_fpu_mode

# Context manager to check that object is deallocated
scipy._lib._gcutils.assert_deallocated

# Context manager to set state of garbage collector to `state`
scipy._lib._gcutils.gc_state

# Set status of garbage collector
scipy._lib._gcutils.set_gc_state

# An invalid version was found, users should refer to PEP 440.
scipy._lib._pep440.InvalidVersion

scipy._lib._pep440.LegacyVersion

# str(object='') -> str
scipy._lib._pep440.VERSION_PATTERN

scipy._lib._pep440.Version

# Parse the given version string and return either a :class:`Version` object
scipy._lib._pep440.parse

scipy._lib._sparse.SparseABC

# Is `x` of a sparse array or sparse matrix type?
scipy._lib._sparse.issparse

scipy._lib._test_ccallback.test_call_nodata

scipy._lib._test_ccallback.test_call_nonlocal

scipy._lib._test_ccallback.test_call_simple

scipy._lib._test_ccallback.test_get_data_capsule

scipy._lib._test_ccallback.test_get_plus1_capsule

scipy._lib._test_ccallback.test_get_plus1b_capsule

scipy._lib._test_ccallback.test_get_plus1bc_capsule

scipy._lib._test_deprecation_call.call

# Returns True when the argument is true, False otherwise.
scipy._lib._testutils.IS_MUSL

# Run tests for this namespace
scipy._lib._testutils.PytestTester

# These are situations that can be tested in our pythran tests:
scipy._lib._testutils._TestPythranFunc

# Check *free_mb* of memory is available, otherwise do pytest.skip
scipy._lib._testutils.check_free_memory

scipy._lib._threadsafety.ReentrancyError

# Threading lock that raises an exception for reentrant calls.
scipy._lib._threadsafety.ReentrancyLock

# Decorate a function with a threading lock and prevent reentrant calls.
scipy._lib._threadsafety.non_reentrant

# @contextmanager decorator.
scipy._lib._tmpdirs.contextmanager

# Change directory to given directory for duration of ``with`` block
scipy._lib._tmpdirs.in_dir

# Create, return, and change directory to a temporary directory
scipy._lib._tmpdirs.in_tempdir

# User-callable function to create and return a unique temporary
scipy._lib._tmpdirs.mkdtemp

# OS routines for NT or Posix depending on what system we're on.
scipy._lib._tmpdirs.os

# Recursively delete a directory tree.
scipy._lib._tmpdirs.rmtree

# Create and return a temporary directory. This has the same
scipy._lib._tmpdirs.tempdir

# An exception that is thrown when no compatible backend is found for a method.
scipy._lib._uarray._backend.BackendNotImplementedError

# A utility class which marks an argument with a specific dispatch type.
scipy._lib._uarray._backend.Dispatchable

scipy._lib._uarray._backend._BackendState

scipy._lib._uarray._backend._Function

scipy._lib._uarray._backend._SetBackendContext

scipy._lib._uarray._backend._SkipBackendContext

# Marks all unmarked arguments as a given type.
scipy._lib._uarray._backend.all_of_type

# This utility method clears registered backends.
scipy._lib._uarray._backend.clear_backends

# Creates a decorator for generating multimethods.
scipy._lib._uarray._backend.create_multimethod

# Set the backend to the first active backend that supports ``value``
scipy._lib._uarray._backend.determine_backend

# Set a backend supporting all ``dispatchables``
scipy._lib._uarray._backend.determine_backend_multi

# Generates a multimethod.
scipy._lib._uarray._backend.generate_multimethod

# Returns an opaque object containing the current state of all the backends.
scipy._lib._uarray._backend.get_state

# Creates a utility function to mark something as a specific type.
scipy._lib._uarray._backend.mark_as

# This utility method sets registers backend for permanent use. It
scipy._lib._uarray._backend.register_backend

# Returns a context manager that resets all state once exited.
scipy._lib._uarray._backend.reset_state

# A context manager that sets the preferred backend.
scipy._lib._uarray._backend.set_backend

# This utility method replaces the default backend for permanent use. It
scipy._lib._uarray._backend.set_global_backend

# A context manager that sets the state of the backends to one returned by :obj:`get_state`.
scipy._lib._uarray._backend.set_state

# A context manager that allows one to skip a given backend from processing
scipy._lib._uarray._backend.skip_backend

# Wraps a ``__ua_convert__`` defined for a single element to all elements.
scipy._lib._uarray._backend.wrap_single_convertor

# Wraps a ``__ua_convert__`` defined for a single element to all elements.
scipy._lib._uarray._backend.wrap_single_convertor_instance

# An exception that is thrown when no compatible backend is found for a method.
scipy._lib._uarray._uarray.BackendNotImplementedError

scipy._lib._uarray._uarray.clear_backends

scipy._lib._uarray._uarray.determine_backend

scipy._lib._uarray._uarray.get_state

scipy._lib._uarray._uarray.register_backend

scipy._lib._uarray._uarray.set_global_backend

scipy._lib._uarray._uarray.set_state

# Special type indicating an unconstrained type.
scipy._lib._util.Array

# Axis supplied was invalid.
scipy._lib._util.AxisError

# Represent a PEP 604 union type
scipy._lib._util.DecimalNumber

# FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)
scipy._lib._util.FullArgSpec

scipy._lib._util.FunctionDoc

# Generator(bit_generator)
scipy._lib._util.Generator

# Type variable.
scipy._lib._util.GeneratorType

# Represent a PEP 604 union type
scipy._lib._util.IntNumber

# Special typing form to define literal types (a.k.a. value types).
scipy._lib._util.Literal

# Parallelisation wrapper for working with map-like callables, such as
scipy._lib._util.MapWrapper

# Create a module object.
scipy._lib._util.ModuleType

# Parameter(name, type, desc)
scipy._lib._util.Parameter

# Represent a PEP 604 union type
scipy._lib._util.SeedType

# Special form for marking type aliases.
scipy._lib._util.TypeAlias

# Type variable.
scipy._lib._util.TypeVar

# Get the array API compatible namespace for the arrays xs.
scipy._lib._util.array_namespace

# Turn `seed` into a `np.random.RandomState` instance.
scipy._lib._util.check_random_state

# @contextmanager decorator.
scipy._lib._util.contextmanager

# The type of the None singleton.
scipy._lib._util.copy_if_needed

# Compute the factorial and return as a float
scipy._lib._util.float_factorial

# functools.py - Tools for working with functions and callable objects
scipy._lib._util.functools

# inspect.getfullargspec replacement using inspect.signature.
scipy._lib._util.getfullargspec_no_self

# Get useful information from live Python objects.
scipy._lib._util.inspect

# Return True if x is potentially a future or it may be otherwise impossible or
scipy._lib._util.is_lazy_array

# Returns True if `xp` is an MArray namespace; False otherwise.
scipy._lib._util.is_marray

# Returns True if `xp` is a NumPy namespace.
scipy._lib._util.is_numpy

# Is `x` of a sparse array or sparse matrix type?
scipy._lib._util.issparse

# This module provides access to the mathematical functions
scipy._lib._util.math

# Returns a new subclass of tuple with named fields.
scipy._lib._util.namedtuple

scipy._lib._util.normalize_axis_index

# NumPy
scipy._lib._util.np

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
scipy._lib._util.np_long

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
scipy._lib._util.np_ulong

scipy._lib._util.np_vecdot

# Abstract Base Classes (ABCs) for numbers, according to PEP 3141.
scipy._lib._util.numbers

# Operator interface.
scipy._lib._util.operator

# Support for regular expressions (RE).
scipy._lib._util.re

# Return random integers from low (inclusive) to high (exclusive), or if
scipy._lib._util.rng_integers

# Python part of the warnings subsystem.
scipy._lib._util.warnings

# Return the device of an array in `args`, for the purpose of
scipy._lib._util.xp_result_device

# Returns the dtype that results from applying type promotion rules
scipy._lib._util.xp_result_type

# Return the total number of elements of x.
scipy._lib._util.xp_size

# Decorator to automatically replace xp with the corresponding array module.
scipy._lib.array_api_compat._internal.get_xp

# UniqueAllResult(values, indices, inverse_indices, counts)
scipy._lib.array_api_compat.common._aliases.UniqueAllResult

# UniqueCountsResult(values, counts)
scipy._lib.array_api_compat.common._aliases.UniqueCountsResult

# UniqueInverseResult(values, inverse_indices)
scipy._lib.array_api_compat.common._aliases.UniqueInverseResult

scipy._lib.array_api_compat.common._aliases.arange

scipy._lib.array_api_compat.common._aliases.argsort

scipy._lib.array_api_compat.common._aliases.ceil

scipy._lib.array_api_compat.common._aliases.clip

scipy._lib.array_api_compat.common._aliases.cumulative_prod

scipy._lib.array_api_compat.common._aliases.cumulative_sum

scipy._lib.array_api_compat.common._aliases.empty

scipy._lib.array_api_compat.common._aliases.empty_like

scipy._lib.array_api_compat.common._aliases.eye

scipy._lib.array_api_compat.common._aliases.finfo

scipy._lib.array_api_compat.common._aliases.floor

scipy._lib.array_api_compat.common._aliases.full

scipy._lib.array_api_compat.common._aliases.full_like

scipy._lib.array_api_compat.common._aliases.iinfo

# Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``.
scipy._lib.array_api_compat.common._aliases.isdtype

scipy._lib.array_api_compat.common._aliases.linspace

scipy._lib.array_api_compat.common._aliases.matmul

scipy._lib.array_api_compat.common._aliases.matrix_transpose

scipy._lib.array_api_compat.common._aliases.nonzero

scipy._lib.array_api_compat.common._aliases.ones

scipy._lib.array_api_compat.common._aliases.ones_like

scipy._lib.array_api_compat.common._aliases.permute_dims

scipy._lib.array_api_compat.common._aliases.reshape

scipy._lib.array_api_compat.common._aliases.sign

scipy._lib.array_api_compat.common._aliases.sort

scipy._lib.array_api_compat.common._aliases.std

scipy._lib.array_api_compat.common._aliases.tensordot

scipy._lib.array_api_compat.common._aliases.trunc

scipy._lib.array_api_compat.common._aliases.unique_all

scipy._lib.array_api_compat.common._aliases.unique_counts

scipy._lib.array_api_compat.common._aliases.unique_inverse

scipy._lib.array_api_compat.common._aliases.unique_values

scipy._lib.array_api_compat.common._aliases.unstack

scipy._lib.array_api_compat.common._aliases.var

scipy._lib.array_api_compat.common._aliases.vecdot

scipy._lib.array_api_compat.common._aliases.zeros

scipy._lib.array_api_compat.common._aliases.zeros_like

scipy._lib.array_api_compat.common._fft.fft

scipy._lib.array_api_compat.common._fft.fftfreq

scipy._lib.array_api_compat.common._fft.fftn

scipy._lib.array_api_compat.common._fft.fftshift

scipy._lib.array_api_compat.common._fft.hfft

scipy._lib.array_api_compat.common._fft.ifft

scipy._lib.array_api_compat.common._fft.ifftn

scipy._lib.array_api_compat.common._fft.ifftshift

scipy._lib.array_api_compat.common._fft.ihfft

scipy._lib.array_api_compat.common._fft.irfft

scipy._lib.array_api_compat.common._fft.irfftn

scipy._lib.array_api_compat.common._fft.rfft

scipy._lib.array_api_compat.common._fft.rfftfreq

scipy._lib.array_api_compat.common._fft.rfftn

# Get the array API compatible namespace for the arrays `xs`.
scipy._lib.array_api_compat.common._helpers.array_namespace

# Hardware device the array data resides on.
scipy._lib.array_api_compat.common._helpers.device

# Get the array API compatible namespace for the arrays `xs`.
scipy._lib.array_api_compat.common._helpers.get_namespace

# Return True if `x` is an array API compatible array object.
scipy._lib.array_api_compat.common._helpers.is_array_api_obj

# Returns True if `xp` is an array-api-strict namespace.
scipy._lib.array_api_compat.common._helpers.is_array_api_strict_namespace

# Return True if `x` is a CuPy array.
scipy._lib.array_api_compat.common._helpers.is_cupy_array

# Returns True if `xp` is a CuPy namespace.
scipy._lib.array_api_compat.common._helpers.is_cupy_namespace

# Return True if `x` is a dask.array Array.
scipy._lib.array_api_compat.common._helpers.is_dask_array

# Returns True if `xp` is a Dask namespace.
scipy._lib.array_api_compat.common._helpers.is_dask_namespace

# Return True if `x` is a JAX array.
scipy._lib.array_api_compat.common._helpers.is_jax_array

# Returns True if `xp` is a JAX namespace.
scipy._lib.array_api_compat.common._helpers.is_jax_namespace

# Return True if x is potentially a future or it may be otherwise impossible or
scipy._lib.array_api_compat.common._helpers.is_lazy_array

# Return True if `x` is a ndonnx Array.
scipy._lib.array_api_compat.common._helpers.is_ndonnx_array

# Returns True if `xp` is an NDONNX namespace.
scipy._lib.array_api_compat.common._helpers.is_ndonnx_namespace

# Return True if `x` is a NumPy array.
scipy._lib.array_api_compat.common._helpers.is_numpy_array

# Returns True if `xp` is a NumPy namespace.
scipy._lib.array_api_compat.common._helpers.is_numpy_namespace

# Return True if `x` is an array from the `sparse` package.
scipy._lib.array_api_compat.common._helpers.is_pydata_sparse_array

# Returns True if `xp` is a pydata/sparse namespace.
scipy._lib.array_api_compat.common._helpers.is_pydata_sparse_namespace

# Return True if `x` is a PyTorch tensor.
scipy._lib.array_api_compat.common._helpers.is_torch_array

# Returns True if `xp` is a PyTorch namespace.
scipy._lib.array_api_compat.common._helpers.is_torch_namespace

# Return False if ``x.__setitem__`` is expected to raise; True otherwise.
scipy._lib.array_api_compat.common._helpers.is_writeable_array

# Return the total number of elements of x.
scipy._lib.array_api_compat.common._helpers.size

# Copy the array from the device on which it currently resides to the specified ``device``.
scipy._lib.array_api_compat.common._helpers.to_device

# EighResult(eigenvalues, eigenvectors)
scipy._lib.array_api_compat.common._linalg.EighResult

# QRResult(Q, R)
scipy._lib.array_api_compat.common._linalg.QRResult

# SVDResult(U, S, Vh)
scipy._lib.array_api_compat.common._linalg.SVDResult

# SlogdetResult(sign, logabsdet)
scipy._lib.array_api_compat.common._linalg.SlogdetResult

scipy._lib.array_api_compat.common._linalg.cholesky

scipy._lib.array_api_compat.common._linalg.cross

scipy._lib.array_api_compat.common._linalg.diagonal

scipy._lib.array_api_compat.common._linalg.eigh

scipy._lib.array_api_compat.common._linalg.matmul

scipy._lib.array_api_compat.common._linalg.matrix_norm

scipy._lib.array_api_compat.common._linalg.matrix_rank

scipy._lib.array_api_compat.common._linalg.matrix_transpose

scipy._lib.array_api_compat.common._linalg.outer

scipy._lib.array_api_compat.common._linalg.pinv

scipy._lib.array_api_compat.common._linalg.qr

scipy._lib.array_api_compat.common._linalg.slogdet

scipy._lib.array_api_compat.common._linalg.svd

scipy._lib.array_api_compat.common._linalg.svdvals

scipy._lib.array_api_compat.common._linalg.tensordot

scipy._lib.array_api_compat.common._linalg.trace

scipy._lib.array_api_compat.common._linalg.vecdot

scipy._lib.array_api_compat.common._linalg.vector_norm

# The base class of the class hierarchy.
scipy._lib.array_api_compat.common._typing.Array

scipy._lib.array_api_compat.common._typing.Capabilities

# The base class of the class hierarchy.
scipy._lib.array_api_compat.common._typing.DType

scipy._lib.array_api_compat.common._typing.DTypeKind

scipy._lib.array_api_compat.common._typing.DTypesAll

# A Mapping is a generic container for associating key/value
scipy._lib.array_api_compat.common._typing.DTypesAny

scipy._lib.array_api_compat.common._typing.DTypesBool

scipy._lib.array_api_compat.common._typing.DTypesComplex

scipy._lib.array_api_compat.common._typing.DTypesIntegral

scipy._lib.array_api_compat.common._typing.DTypesNumeric

scipy._lib.array_api_compat.common._typing.DTypesReal

scipy._lib.array_api_compat.common._typing.DTypesSigned

scipy._lib.array_api_compat.common._typing.DTypesUnsigned

scipy._lib.array_api_compat.common._typing.DefaultDTypes

# The base class of the class hierarchy.
scipy._lib.array_api_compat.common._typing.Device

scipy._lib.array_api_compat.common._typing.HasShape

scipy._lib.array_api_compat.common._typing.JustComplex

scipy._lib.array_api_compat.common._typing.JustFloat

scipy._lib.array_api_compat.common._typing.JustInt

# Create a module object.
scipy._lib.array_api_compat.common._typing.Namespace

scipy._lib.array_api_compat.common._typing.NestedSequence

scipy._lib.array_api_compat.common._typing.SupportsArrayNamespace

# The base class of the class hierarchy.
scipy._lib.array_api_compat.common._typing.SupportsBufferProtocol

# UniqueAllResult(values, indices, inverse_indices, counts)
scipy._lib.array_api_compat.numpy._aliases.UniqueAllResult

# UniqueCountsResult(values, counts)
scipy._lib.array_api_compat.numpy._aliases.UniqueCountsResult

# UniqueInverseResult(values, inverse_indices)
scipy._lib.array_api_compat.numpy._aliases.UniqueInverseResult

# Get the array API inspection namespace for NumPy.
scipy._lib.array_api_compat.numpy._aliases.__array_namespace_info__

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.acos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.acosh

# Array API compatibility wrapper for arange.
scipy._lib.array_api_compat.numpy._aliases.arange

# Array API compatibility wrapper for argsort.
scipy._lib.array_api_compat.numpy._aliases.argsort

# Array API compatibility wrapper for asarray().
scipy._lib.array_api_compat.numpy._aliases.asarray

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.asin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.asinh

scipy._lib.array_api_compat.numpy._aliases.astype

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.atan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.atan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.atanh

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.bitwise_invert

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.bitwise_left_shift

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.bitwise_right_shift

# Boolean type (True or False), stored as a byte.
scipy._lib.array_api_compat.numpy._aliases.bool

# Array API compatibility wrapper for ceil.
scipy._lib.array_api_compat.numpy._aliases.ceil

# Array API compatibility wrapper for clip.
scipy._lib.array_api_compat.numpy._aliases.clip

# concatenate(
scipy._lib.array_api_compat.numpy._aliases.concat

scipy._lib.array_api_compat.numpy._aliases.count_nonzero

# Array API compatibility wrapper for cumulative_prod.
scipy._lib.array_api_compat.numpy._aliases.cumulative_prod

# Array API compatibility wrapper for cumulative_sum.
scipy._lib.array_api_compat.numpy._aliases.cumulative_sum

# Array API compatibility wrapper for empty.
scipy._lib.array_api_compat.numpy._aliases.empty

# Array API compatibility wrapper for empty_like.
scipy._lib.array_api_compat.numpy._aliases.empty_like

# Array API compatibility wrapper for eye.
scipy._lib.array_api_compat.numpy._aliases.eye

# Array API compatibility wrapper for finfo.
scipy._lib.array_api_compat.numpy._aliases.finfo

# Array API compatibility wrapper for floor.
scipy._lib.array_api_compat.numpy._aliases.floor

# Array API compatibility wrapper for full.
scipy._lib.array_api_compat.numpy._aliases.full

# Array API compatibility wrapper for full_like.
scipy._lib.array_api_compat.numpy._aliases.full_like

# Array API compatibility wrapper for iinfo.
scipy._lib.array_api_compat.numpy._aliases.iinfo

# Determine if a provided dtype is of a specified data type ``kind``.
scipy._lib.array_api_compat.numpy._aliases.isdtype

# Array API compatibility wrapper for linspace.
scipy._lib.array_api_compat.numpy._aliases.linspace

# Array API compatibility wrapper for matmul.
scipy._lib.array_api_compat.numpy._aliases.matmul

# Array API compatibility wrapper for matrix_transpose.
scipy._lib.array_api_compat.numpy._aliases.matrix_transpose

# Array API compatibility wrapper for nonzero.
scipy._lib.array_api_compat.numpy._aliases.nonzero

# Array API compatibility wrapper for ones.
scipy._lib.array_api_compat.numpy._aliases.ones

# Array API compatibility wrapper for ones_like.
scipy._lib.array_api_compat.numpy._aliases.ones_like

# Array API compatibility wrapper for permute_dims.
scipy._lib.array_api_compat.numpy._aliases.permute_dims

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy._lib.array_api_compat.numpy._aliases.pow

# Array API compatibility wrapper for reshape.
scipy._lib.array_api_compat.numpy._aliases.reshape

# Array API compatibility wrapper for sign.
scipy._lib.array_api_compat.numpy._aliases.sign

# Array API compatibility wrapper for sort.
scipy._lib.array_api_compat.numpy._aliases.sort

# Array API compatibility wrapper for std.
scipy._lib.array_api_compat.numpy._aliases.std

scipy._lib.array_api_compat.numpy._aliases.take_along_axis

# Array API compatibility wrapper for tensordot.
scipy._lib.array_api_compat.numpy._aliases.tensordot

# Array API compatibility wrapper for trunc.
scipy._lib.array_api_compat.numpy._aliases.trunc

# Array API compatibility wrapper for unique_all.
scipy._lib.array_api_compat.numpy._aliases.unique_all

# Array API compatibility wrapper for unique_counts.
scipy._lib.array_api_compat.numpy._aliases.unique_counts

# Array API compatibility wrapper for unique_inverse.
scipy._lib.array_api_compat.numpy._aliases.unique_inverse

# Array API compatibility wrapper for unique_values.
scipy._lib.array_api_compat.numpy._aliases.unique_values

# Split an array into a sequence of arrays along the given axis.
scipy._lib.array_api_compat.numpy._aliases.unstack

# Array API compatibility wrapper for var.
scipy._lib.array_api_compat.numpy._aliases.var

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
scipy._lib.array_api_compat.numpy._aliases.vecdot

# Array API compatibility wrapper for zeros.
scipy._lib.array_api_compat.numpy._aliases.zeros

# Array API compatibility wrapper for zeros_like.
scipy._lib.array_api_compat.numpy._aliases.zeros_like

# Get the array API inspection namespace for NumPy.
scipy._lib.array_api_compat.numpy._info.__array_namespace_info__

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy._lib.array_api_compat.numpy._typing.Array

# dtype(dtype, align=False, copy=False, [metadata])
scipy._lib.array_api_compat.numpy._typing.DType

scipy._lib.array_api_compat.numpy._typing.Device

# Array API compatibility wrapper for fft.
scipy._lib.array_api_compat.numpy.fft.fft

# Compute the 2-dimensional discrete Fourier Transform.
scipy._lib.array_api_compat.numpy.fft.fft2

# Array API compatibility wrapper for fftfreq.
scipy._lib.array_api_compat.numpy.fft.fftfreq

# Array API compatibility wrapper for fftn.
scipy._lib.array_api_compat.numpy.fft.fftn

# Array API compatibility wrapper for fftshift.
scipy._lib.array_api_compat.numpy.fft.fftshift

# Array API compatibility wrapper for hfft.
scipy._lib.array_api_compat.numpy.fft.hfft

# Array API compatibility wrapper for ifft.
scipy._lib.array_api_compat.numpy.fft.ifft

# Compute the 2-dimensional inverse discrete Fourier Transform.
scipy._lib.array_api_compat.numpy.fft.ifft2

# Array API compatibility wrapper for ifftn.
scipy._lib.array_api_compat.numpy.fft.ifftn

# Array API compatibility wrapper for ifftshift.
scipy._lib.array_api_compat.numpy.fft.ifftshift

# Array API compatibility wrapper for ihfft.
scipy._lib.array_api_compat.numpy.fft.ihfft

# Array API compatibility wrapper for irfft.
scipy._lib.array_api_compat.numpy.fft.irfft

# Computes the inverse of `rfft2`.
scipy._lib.array_api_compat.numpy.fft.irfft2

# Array API compatibility wrapper for irfftn.
scipy._lib.array_api_compat.numpy.fft.irfftn

# Array API compatibility wrapper for rfft.
scipy._lib.array_api_compat.numpy.fft.rfft

# Compute the 2-dimensional FFT of a real array.
scipy._lib.array_api_compat.numpy.fft.rfft2

# Array API compatibility wrapper for rfftfreq.
scipy._lib.array_api_compat.numpy.fft.rfftfreq

# Array API compatibility wrapper for rfftn.
scipy._lib.array_api_compat.numpy.fft.rfftn

# EighResult(eigenvalues, eigenvectors)
scipy._lib.array_api_compat.numpy.linalg.EighResult

# Generic Python-exception-derived object raised by linalg functions.
scipy._lib.array_api_compat.numpy.linalg.LinAlgError

# QRResult(Q, R)
scipy._lib.array_api_compat.numpy.linalg.QRResult

# SVDResult(U, S, Vh)
scipy._lib.array_api_compat.numpy.linalg.SVDResult

# SlogdetResult(sign, logabsdet)
scipy._lib.array_api_compat.numpy.linalg.SlogdetResult

# Array API compatibility wrapper for cholesky.
scipy._lib.array_api_compat.numpy.linalg.cholesky

# Compute the condition number of a matrix.
scipy._lib.array_api_compat.numpy.linalg.cond

# Array API compatibility wrapper for cross.
scipy._lib.array_api_compat.numpy.linalg.cross

# Compute the determinant of an array.
scipy._lib.array_api_compat.numpy.linalg.det

# Array API compatibility wrapper for diagonal.
scipy._lib.array_api_compat.numpy.linalg.diagonal

# Compute the eigenvalues and right eigenvectors of a square array.
scipy._lib.array_api_compat.numpy.linalg.eig

# Array API compatibility wrapper for eigh.
scipy._lib.array_api_compat.numpy.linalg.eigh

# Compute the eigenvalues of a general matrix.
scipy._lib.array_api_compat.numpy.linalg.eigvals

# Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
scipy._lib.array_api_compat.numpy.linalg.eigvalsh

# Compute the inverse of a matrix.
scipy._lib.array_api_compat.numpy.linalg.inv

# Return the least-squares solution to a linear matrix equation.
scipy._lib.array_api_compat.numpy.linalg.lstsq

# Array API compatibility wrapper for matmul.
scipy._lib.array_api_compat.numpy.linalg.matmul

# Array API compatibility wrapper for matrix_norm.
scipy._lib.array_api_compat.numpy.linalg.matrix_norm

# Raise a square matrix to the (integer) power `n`.
scipy._lib.array_api_compat.numpy.linalg.matrix_power

# Array API compatibility wrapper for matrix_rank.
scipy._lib.array_api_compat.numpy.linalg.matrix_rank

# Array API compatibility wrapper for matrix_transpose.
scipy._lib.array_api_compat.numpy.linalg.matrix_transpose

# Compute the dot product of two or more arrays in a single function call,
scipy._lib.array_api_compat.numpy.linalg.multi_dot

# Matrix or vector norm.
scipy._lib.array_api_compat.numpy.linalg.norm

# Array API compatibility wrapper for outer.
scipy._lib.array_api_compat.numpy.linalg.outer

# Array API compatibility wrapper for pinv.
scipy._lib.array_api_compat.numpy.linalg.pinv

# Array API compatibility wrapper for qr.
scipy._lib.array_api_compat.numpy.linalg.qr

# Array API compatibility wrapper for slogdet.
scipy._lib.array_api_compat.numpy.linalg.slogdet

scipy._lib.array_api_compat.numpy.linalg.solve

# Array API compatibility wrapper for svd.
scipy._lib.array_api_compat.numpy.linalg.svd

# Array API compatibility wrapper for svdvals.
scipy._lib.array_api_compat.numpy.linalg.svdvals

# Array API compatibility wrapper for tensordot.
scipy._lib.array_api_compat.numpy.linalg.tensordot

# Compute the 'inverse' of an N-dimensional array.
scipy._lib.array_api_compat.numpy.linalg.tensorinv

# Solve the tensor equation ``a x = b`` for x.
scipy._lib.array_api_compat.numpy.linalg.tensorsolve

# Array API compatibility wrapper for trace.
scipy._lib.array_api_compat.numpy.linalg.trace

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
scipy._lib.array_api_compat.numpy.linalg.vecdot

# Computes the vector norm of a vector (or batch of vectors) ``x``.
scipy._lib.array_api_compat.numpy.linalg.vector_norm

# Computes the vector norm of a vector (or batch of vectors) ``x``.
scipy._lib.array_api_compat.numpy.linalg.vector_norm

# Return a boolean array where two arrays are element-wise equal within a tolerance.
scipy._lib.array_api_extra._delegation.isclose

# Pad the input array.
scipy._lib.array_api_extra._delegation.pad

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._at.Array

scipy._lib.array_api_extra._lib._at.Callable

# Special type construct to mark class variables.
scipy._lib.array_api_extra._lib._at.ClassVar

# Create a collection of name/value pairs.
scipy._lib.array_api_extra._lib._at.Enum

# Create a module object.
scipy._lib.array_api_extra._lib._at.ModuleType

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._at.SetIndex

# Returns True when the argument is true, False otherwise.
scipy._lib.array_api_extra._lib._at.TYPE_CHECKING

# Sentinel for undefined values.
scipy._lib.array_api_extra._lib._at.Undef

scipy._lib.array_api_extra._lib._at.annotations

# Get the array API compatible namespace for the arrays xs.
scipy._lib.array_api_extra._lib._at.array_namespace

# Update operations for read-only arrays.
scipy._lib.array_api_extra._lib._at.at

# Cast a value to a type.
scipy._lib.array_api_extra._lib._at.cast

# Return True if `x` is a dask.array Array.
scipy._lib.array_api_extra._lib._at.is_dask_array

# Return True if `x` is a JAX array.
scipy._lib.array_api_extra._lib._at.is_jax_array

# Return True if `x` is a PyTorch tensor.
scipy._lib.array_api_extra._lib._at.is_torch_array

# Return False if ``x.__setitem__`` is expected to raise; True otherwise.
scipy._lib.array_api_extra._lib._at.is_writeable_array

# Get the namespace of Dask chunks.
scipy._lib.array_api_extra._lib._at.meta_namespace

# Operator interface.
scipy._lib.array_api_extra._lib._at.operator

# All array library backends explicitly tested by array-api-extra.
scipy._lib.array_api_extra._lib._backends.Backend

# Run one of two elementwise functions depending on a condition.
scipy._lib.array_api_extra._lib._funcs.apply_where

# Recursively expand the dimension of an array to at least `ndim`.
scipy._lib.array_api_extra._lib._funcs.atleast_nd

# Compute the shape of the broadcasted arrays.
scipy._lib.array_api_extra._lib._funcs.broadcast_shapes

# Estimate a covariance matrix.
scipy._lib.array_api_extra._lib._funcs.cov

# Construct a diagonal array.
scipy._lib.array_api_extra._lib._funcs.create_diagonal

# Expand the shape of an array.
scipy._lib.array_api_extra._lib._funcs.expand_dims

# Kronecker product of two arrays.
scipy._lib.array_api_extra._lib._funcs.kron

# Count the number of unique elements in an array.
scipy._lib.array_api_extra._lib._funcs.nunique

# See docstring in `array_api_extra._delegation.py`.
scipy._lib.array_api_extra._lib._funcs.pad

# Find the set difference of two arrays.
scipy._lib.array_api_extra._lib._funcs.setdiff1d

# Return the normalized sinc function.
scipy._lib.array_api_extra._lib._funcs.sinc

# Special type indicating an unconstrained type.
scipy._lib.array_api_extra._lib._lazy.Any

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._lazy.Array

scipy._lib.array_api_extra._lib._lazy.Callable

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._lazy.DType

# Create a module object.
scipy._lib.array_api_extra._lib._lazy.ModuleType

# Special type indicating an unconstrained type.
scipy._lib.array_api_extra._lib._lazy.NumPyObject

# Parameter specification variable.
scipy._lib.array_api_extra._lib._lazy.P

# Parameter specification variable.
scipy._lib.array_api_extra._lib._lazy.ParamSpec

# All the operations on a read-only sequence.
scipy._lib.array_api_extra._lib._lazy.Sequence

# Returns True when the argument is true, False otherwise.
scipy._lib.array_api_extra._lib._lazy.TYPE_CHECKING

# Special form for marking type aliases.
scipy._lib.array_api_extra._lib._lazy.TypeAlias

scipy._lib.array_api_extra._lib._lazy.annotations

# Get the array API compatible namespace for the arrays xs.
scipy._lib.array_api_extra._lib._lazy.array_namespace

# Compute the shape of the broadcasted arrays.
scipy._lib.array_api_extra._lib._lazy.broadcast_shapes

# Cast a value to a type.
scipy._lib.array_api_extra._lib._lazy.cast

# Returns True if `xp` is a Dask namespace.
scipy._lib.array_api_extra._lib._lazy.is_dask_namespace

# Returns True if `xp` is a JAX namespace.
scipy._lib.array_api_extra._lib._lazy.is_jax_namespace

# Return True if `x` is a Python scalar, False otherwise.
scipy._lib.array_api_extra._lib._lazy.is_python_scalar

# Lazily apply an eager function.
scipy._lib.array_api_extra._lib._lazy.lazy_apply

# This module provides access to the mathematical functions
scipy._lib.array_api_extra._lib._lazy.math

# Decorator for overloaded functions/methods.
scipy._lib.array_api_extra._lib._lazy.overload

# Create a new function with partial application of the given arguments
scipy._lib.array_api_extra._lib._lazy.partial

# Decorator factory to apply update_wrapper() to a wrapper function
scipy._lib.array_api_extra._lib._lazy.wraps

# Convert array to NumPy, bypassing GPU-CPU transfer guards and densification guards.
scipy._lib.array_api_extra._lib._testing.as_numpy_array

# Array-API compatible version of `np.testing.assert_allclose`.
scipy._lib.array_api_extra._lib._testing.xp_assert_close

# Array-API compatible version of `np.testing.assert_array_equal`.
scipy._lib.array_api_extra._lib._testing.xp_assert_equal

# Array-API compatible version of `np.testing.assert_array_less`.
scipy._lib.array_api_extra._lib._testing.xp_assert_less

# Get the array API compatible namespace for the arrays xs.
scipy._lib.array_api_extra._lib._utils._compat.array_namespace

# Hardware device the array data resides on.
scipy._lib.array_api_extra._lib._utils._compat.device

# Return True if `x` is an array API compatible array object.
scipy._lib.array_api_extra._lib._utils._compat.is_array_api_obj

# Returns True if `xp` is an array-api-strict namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_array_api_strict_namespace

# Return True if `x` is a CuPy array.
scipy._lib.array_api_extra._lib._utils._compat.is_cupy_array

# Returns True if `xp` is a CuPy namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_cupy_namespace

# Return True if `x` is a dask.array Array.
scipy._lib.array_api_extra._lib._utils._compat.is_dask_array

# Returns True if `xp` is a Dask namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_dask_namespace

# Return True if `x` is a JAX array.
scipy._lib.array_api_extra._lib._utils._compat.is_jax_array

# Returns True if `xp` is a JAX namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_jax_namespace

# Return True if x is potentially a future or it may be otherwise impossible or
scipy._lib.array_api_extra._lib._utils._compat.is_lazy_array

# Return True if `x` is a NumPy array.
scipy._lib.array_api_extra._lib._utils._compat.is_numpy_array

# Returns True if `xp` is a NumPy namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_numpy_namespace

# Return True if `x` is an array from the `sparse` package.
scipy._lib.array_api_extra._lib._utils._compat.is_pydata_sparse_array

# Returns True if `xp` is a pydata/sparse namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_pydata_sparse_namespace

# Return True if `x` is a PyTorch tensor.
scipy._lib.array_api_extra._lib._utils._compat.is_torch_array

# Returns True if `xp` is a PyTorch namespace.
scipy._lib.array_api_extra._lib._utils._compat.is_torch_namespace

# Return False if ``x.__setitem__`` is expected to raise; True otherwise.
scipy._lib.array_api_extra._lib._utils._compat.is_writeable_array

# Return the total number of elements of x.
scipy._lib.array_api_extra._lib._utils._compat.size

# Copy the array from the device on which it currently resides to the specified ``device``.
scipy._lib.array_api_extra._lib._utils._compat.to_device

# Ensure both `a` and `b` are arrays.
scipy._lib.array_api_extra._lib._utils._helpers.asarrays

# Return patched ``xp.__array_namespace_info__().capabilities()``.
scipy._lib.array_api_extra._lib._utils._helpers.capabilities

# Return shape of an array. Raise if shape is not fully defined.
scipy._lib.array_api_extra._lib._utils._helpers.eager_shape

# Check whether each element of an array is also present in a second array.
scipy._lib.array_api_extra._lib._utils._helpers.in1d

# Return True if `x` is a Python scalar, False otherwise.
scipy._lib.array_api_extra._lib._utils._helpers.is_python_scalar

# Wrap `func` with ``jax.jit``, with the following differences:
scipy._lib.array_api_extra._lib._utils._helpers.jax_autojit

# Complex mean, https://github.com/data-apis/array-api/issues/846.
scipy._lib.array_api_extra._lib._utils._helpers.mean

# Get the namespace of Dask chunks.
scipy._lib.array_api_extra._lib._utils._helpers.meta_namespace

# Use the pickle machinery to extract objects out of an arbitrary container.
scipy._lib.array_api_extra._lib._utils._helpers.pickle_flatten

# Reverse of ``pickle_flatten``.
scipy._lib.array_api_extra._lib._utils._helpers.pickle_unflatten

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._utils._typing.Array

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._utils._typing.DType

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._utils._typing.Device

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._utils._typing.GetIndex

# The base class of the class hierarchy.
scipy._lib.array_api_extra._lib._utils._typing.SetIndex

# Tag a function to be tested on lazy backends.
scipy._lib.array_api_extra.testing.lazy_xp_function

# Test lazy execution of functions tagged with :func:`lazy_xp_function`.
scipy._lib.array_api_extra.testing.patch_lazy_xp_functions

# Constants.
scipy._lib.cobyqa.framework.Constants

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.framework.EPS

# Models for a nonlinear optimization problem.
scipy._lib.cobyqa.framework.Models

# Options.
scipy._lib.cobyqa.framework.Options

# Quadratic model.
scipy._lib.cobyqa.framework.Quadratic

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.framework.TINY

# Trust-region framework.
scipy._lib.cobyqa.framework.TrustRegion

# Maximize approximately the absolute value of a quadratic function subject
scipy._lib.cobyqa.framework.cauchy_geometry

# Minimize approximately a quadratic function subject to bound and linear
scipy._lib.cobyqa.framework.constrained_tangential_byrd_omojokun

# Get a relative tolerance for a set of arrays.
scipy._lib.cobyqa.framework.get_arrays_tol

# Solve a linear least-squares problem with bounds on the variables.
scipy._lib.cobyqa.framework.lsq_linear

# Minimize approximately a linear constraint violation subject to bound
scipy._lib.cobyqa.framework.normal_byrd_omojokun

# NumPy
scipy._lib.cobyqa.framework.np

scipy._lib.cobyqa.framework.qr_tangential_byrd_omojokun

# Maximize approximately the absolute value of a quadratic function subject
scipy._lib.cobyqa.framework.spider_geometry

# Minimize approximately a quadratic function subject to bound constraints in
scipy._lib.cobyqa.framework.tangential_byrd_omojokun

# Python part of the warnings subsystem.
scipy._lib.cobyqa.framework.warnings

# Bound constraints ``xl <= x <= xu``.
scipy._lib.cobyqa.main.BoundConstraints

# Bounds constraint on the variables.
scipy._lib.cobyqa.main.Bounds

# Exception raised when the callback function raises a ``StopIteration``.
scipy._lib.cobyqa.main.CallbackSuccess

# Constants.
scipy._lib.cobyqa.main.Constants

# dict() -> new empty dictionary
scipy._lib.cobyqa.main.DEFAULT_CONSTANTS

# dict() -> new empty dictionary
scipy._lib.cobyqa.main.DEFAULT_OPTIONS

# Exit statuses.
scipy._lib.cobyqa.main.ExitStatus

# Exception raised when a feasible point of a feasible problem is found.
scipy._lib.cobyqa.main.FeasibleSuccess

# Linear constraint on the variables.
scipy._lib.cobyqa.main.LinearConstraint

# Linear constraints ``a_ub @ x <= b_ub`` and ``a_eq @ x == b_eq``.
scipy._lib.cobyqa.main.LinearConstraints

# Exception raised when the maximum number of evaluations is reached.
scipy._lib.cobyqa.main.MaxEvalError

# Nonlinear constraint on the variables.
scipy._lib.cobyqa.main.NonlinearConstraint

# Nonlinear constraints ``c_ub(x) <= 0`` and ``c_eq(x) == b_eq``.
scipy._lib.cobyqa.main.NonlinearConstraints

# Real-valued objective function.
scipy._lib.cobyqa.main.ObjectiveFunction

# Represents the optimization result.
scipy._lib.cobyqa.main.OptimizeResult

# Options.
scipy._lib.cobyqa.main.Options

# dict() -> new empty dictionary
scipy._lib.cobyqa.main.PRINT_OPTIONS

# Optimization problem.
scipy._lib.cobyqa.main.Problem

# Exception raised when the target value is reached.
scipy._lib.cobyqa.main.TargetSuccess

# Trust-region framework.
scipy._lib.cobyqa.main.TrustRegion

# Preprocess a 1-dimensional array.
scipy._lib.cobyqa.main.exact_1d_array

# Minimize a scalar function using the COBYQA method.
scipy._lib.cobyqa.main.minimize

# NumPy
scipy._lib.cobyqa.main.np

# Python part of the warnings subsystem.
scipy._lib.cobyqa.main.warnings

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.models.EPS

# Exception raised when a feasible point of a feasible problem is found.
scipy._lib.cobyqa.models.FeasibleSuccess

# Interpolation set.
scipy._lib.cobyqa.models.Interpolation

# Exception raised when the maximum number of evaluations is reached.
scipy._lib.cobyqa.models.MaxEvalError

# Models for a nonlinear optimization problem.
scipy._lib.cobyqa.models.Models

# Options.
scipy._lib.cobyqa.models.Options

# Quadratic model.
scipy._lib.cobyqa.models.Quadratic

# Exception raised when the target value is reached.
scipy._lib.cobyqa.models.TargetSuccess

# Build the left-hand side matrix of the interpolation system. The
scipy._lib.cobyqa.models.build_system

# Solve a standard or generalized eigenvalue problem for a complex
scipy._lib.cobyqa.models.eigh

# NumPy
scipy._lib.cobyqa.models.np

# Python part of the warnings subsystem.
scipy._lib.cobyqa.models.warnings

# Convert a string or number to a floating-point number, if possible.
scipy._lib.cobyqa.problem.BARRIER

# Bound constraints ``xl <= x <= xu``.
scipy._lib.cobyqa.problem.BoundConstraints

# Bounds constraint on the variables.
scipy._lib.cobyqa.problem.Bounds

# Exception raised when the callback function raises a ``StopIteration``.
scipy._lib.cobyqa.problem.CallbackSuccess

# Linear constraint on the variables.
scipy._lib.cobyqa.problem.LinearConstraint

# Linear constraints ``a_ub @ x <= b_ub`` and ``a_eq @ x == b_eq``.
scipy._lib.cobyqa.problem.LinearConstraints

# Nonlinear constraint on the variables.
scipy._lib.cobyqa.problem.NonlinearConstraint

# Nonlinear constraints ``c_ub(x) <= 0`` and ``c_eq(x) == b_eq``.
scipy._lib.cobyqa.problem.NonlinearConstraints

# Real-valued objective function.
scipy._lib.cobyqa.problem.ObjectiveFunction

# Represents the optimization result.
scipy._lib.cobyqa.problem.OptimizeResult

# dict() -> new empty dictionary
scipy._lib.cobyqa.problem.PRINT_OPTIONS

# Constraint prepared from a user defined constraint.
scipy._lib.cobyqa.problem.PreparedConstraint

# Optimization problem.
scipy._lib.cobyqa.problem.Problem

# Generic (shallow and deep) copying operations.
scipy._lib.cobyqa.problem.copy

# Preprocess a 1-dimensional array.
scipy._lib.cobyqa.problem.exact_1d_array

# Get a relative tolerance for a set of arrays.
scipy._lib.cobyqa.problem.get_arrays_tol

# NumPy
scipy._lib.cobyqa.problem.np

# Get a signature object for the passed callable.
scipy._lib.cobyqa.problem.signature

# Context manager to suppress specified exceptions
scipy._lib.cobyqa.problem.suppress

# Convert a string or number to a floating-point number, if possible.
scipy._lib.cobyqa.settings.BARRIER

# Constants.
scipy._lib.cobyqa.settings.Constants

# dict() -> new empty dictionary
scipy._lib.cobyqa.settings.DEFAULT_CONSTANTS

# dict() -> new empty dictionary
scipy._lib.cobyqa.settings.DEFAULT_OPTIONS

# Create a collection of name/value pairs.
scipy._lib.cobyqa.settings.Enum

# Exit statuses.
scipy._lib.cobyqa.settings.ExitStatus

# Options.
scipy._lib.cobyqa.settings.Options

# dict() -> new empty dictionary
scipy._lib.cobyqa.settings.PRINT_OPTIONS

# NumPy
scipy._lib.cobyqa.settings.np

# This module provides access to some objects used or maintained by the
scipy._lib.cobyqa.settings.sys

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.subsolvers.geometry.TINY

# Maximize approximately the absolute value of a quadratic function subject
scipy._lib.cobyqa.subsolvers.geometry.cauchy_geometry

# Get a relative tolerance for a set of arrays.
scipy._lib.cobyqa.subsolvers.geometry.get_arrays_tol

# Get useful information from live Python objects.
scipy._lib.cobyqa.subsolvers.geometry.inspect

# NumPy
scipy._lib.cobyqa.subsolvers.geometry.np

# Maximize approximately the absolute value of a quadratic function subject
scipy._lib.cobyqa.subsolvers.geometry.spider_geometry

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.subsolvers.optim.EPS

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.subsolvers.optim.TINY

# Minimize approximately a quadratic function subject to bound and linear
scipy._lib.cobyqa.subsolvers.optim.constrained_tangential_byrd_omojokun

# Get a relative tolerance for a set of arrays.
scipy._lib.cobyqa.subsolvers.optim.get_arrays_tol

# Get useful information from live Python objects.
scipy._lib.cobyqa.subsolvers.optim.inspect

# Minimize approximately a linear constraint violation subject to bound
scipy._lib.cobyqa.subsolvers.optim.normal_byrd_omojokun

# NumPy
scipy._lib.cobyqa.subsolvers.optim.np

# Compute QR decomposition of a matrix.
scipy._lib.cobyqa.subsolvers.optim.qr

scipy._lib.cobyqa.subsolvers.optim.qr_normal_byrd_omojokun

scipy._lib.cobyqa.subsolvers.optim.qr_tangential_byrd_omojokun

# Minimize approximately a quadratic function subject to bound constraints in
scipy._lib.cobyqa.subsolvers.optim.tangential_byrd_omojokun

# Exception raised when the callback function raises a ``StopIteration``.
scipy._lib.cobyqa.utils.exceptions.CallbackSuccess

# Exception raised when a feasible point of a feasible problem is found.
scipy._lib.cobyqa.utils.exceptions.FeasibleSuccess

# Exception raised when the maximum number of evaluations is reached.
scipy._lib.cobyqa.utils.exceptions.MaxEvalError

# Exception raised when the target value is reached.
scipy._lib.cobyqa.utils.exceptions.TargetSuccess

# Double-precision floating-point number type, compatible with Python
scipy._lib.cobyqa.utils.math.EPS

# Preprocess a 1-dimensional array.
scipy._lib.cobyqa.utils.math.exact_1d_array

# Preprocess a 2-dimensional array.
scipy._lib.cobyqa.utils.math.exact_2d_array

# Get a relative tolerance for a set of arrays.
scipy._lib.cobyqa.utils.math.get_arrays_tol

# NumPy
scipy._lib.cobyqa.utils.math.np

# The package was not found.
scipy._lib.cobyqa.utils.versions.PackageNotFoundError

# OS routines for NT or Posix depending on what system we're on.
scipy._lib.cobyqa.utils.versions.os

# This module tries to retrieve as much platform-identifying data as
scipy._lib.cobyqa.utils.versions.platform

# Display useful system and dependencies information.
scipy._lib.cobyqa.utils.versions.show_versions

# This module provides access to some objects used or maintained by the
scipy._lib.cobyqa.utils.versions.sys

# Get the version string for the named package.
scipy._lib.cobyqa.utils.versions.version

# ArgSpec(args, varargs, varkw, defaults)
scipy._lib.decorator.ArgSpec

scipy._lib.decorator.ContextManager

# Compiled regular expression object.
scipy._lib.decorator.DEF

# An object with the ability to create functions with a given signature.
scipy._lib.decorator.FunctionMaker

# Append ``a`` to the list of the virtual ancestors, unless it is already
scipy._lib.decorator.append

# This module implements specialized container datatypes providing
scipy._lib.decorator.collections

# decorator(ContextManager) converts functions/generators into factories of ContextManager objects
scipy._lib.decorator.contextmanager

# decorate(func, caller) decorates a function using a caller.
scipy._lib.decorator.decorate

# decorator(caller) converts a caller function into a decorator
scipy._lib.decorator.decorator

# Factory of decorators turning a function into a generic function
scipy._lib.decorator.dispatch_on

scipy._lib.decorator.get_init

# A replacement for inspect.getargspec
scipy._lib.decorator.getargspec

# Get the names and default values of a callable object's parameters.
scipy._lib.decorator.getfullargspec

# FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)
scipy._lib.decorator.init

# Get useful information from live Python objects.
scipy._lib.decorator.inspect

# Functional tools for creating and using iterators.
scipy._lib.decorator.itertools

# int([x]) -> integer
scipy._lib.decorator.n_args

# Operator interface.
scipy._lib.decorator.operator

# Support for regular expressions (RE).
scipy._lib.decorator.re

# This module provides access to some objects used or maintained by the
scipy._lib.decorator.sys

# Deprecate a function by emitting a warning on use.
scipy._lib.deprecation._deprecated

# Decorator to take the docstring from obj, with oldval replaced by newval
scipy._lib.doccer.doc_replace

# Fill a function docstring from variables in dictionary.
scipy._lib.doccer.docformat

# This decorator replaces the decorated function's docstring
scipy._lib.doccer.extend_notes_in_docstring

# Return docstring decorator using docdict variable dictionary.
scipy._lib.doccer.filldoc

# Minimum indent for all lines in line list
scipy._lib.doccer.indentcount_lines

# This decorator modifies the decorated function's docstring by
scipy._lib.doccer.inherit_docstring_from

# This decorator replaces the decorated function's docstring
scipy._lib.doccer.replace_notes_in_docstring

# Unindent all strings in a docdict.
scipy._lib.doccer.unindent_dict

# Set docstring to minimum indent for all lines, including first.
scipy._lib.doccer.unindent_string

# Capture messages emitted to FILE* streams. Do this by directing them
scipy._lib.messagestream.MessageStream

# OS routines for NT or Posix depending on what system we're on.
scipy._lib.messagestream.os

# Temporary files.
scipy._lib.messagestream.tempfile

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.cobyla.BOUNDMAX

# COBYLAResult(x: numpy.ndarray, f: float, constr: numpy.ndarray, cstrv: float, nf: int, xhist: numpy.ndarray | None, fhist: numpy.ndarray | None, chist: numpy.ndarray | None, conhist: numpy.ndarray | None, info: int)
scipy._lib.pyprima.cobyla.cobyla.COBYLAResult

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.cobyla.CTOL_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.cobyla.cobyla.CWEIGHT_DEFAULT

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.cobyla.cobyla.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.cobyla.EPS

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.cobyla.cobyla.ETA1_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.cobyla.cobyla.ETA2_DEFAULT

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.cobyla.FTARGET_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.cobyla.cobyla.GAMMA1_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobyla.GAMMA2_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobyla.IPRINT_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobyla.MAXFUN_DIM_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobyla.RHOBEG_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.cobyla.cobyla.RHOEND_DEFAULT

# Among all the arguments, only CALCFC, M_NLCON, and X are obligatory. The others are
scipy._lib.pyprima.cobyla.cobyla.cobyla

# This subroutine performs the actual computations of COBYLA.
scipy._lib.pyprima.cobyla.cobyla.cobylb

# Shallow copy operation on arbitrary Python objects.
scipy._lib.pyprima.cobyla.cobyla.copy

# Add dunder methods based on the fields defined in the class.
scipy._lib.pyprima.cobyla.cobyla.dataclass

# This function evaluates CALCFC at X, returning the objective function value and the
scipy._lib.pyprima.cobyla.cobyla.evaluate

# This subroutine wraps the linear and bound constraints into a single constraint:
scipy._lib.pyprima.cobyla.cobyla.get_lincon

scipy._lib.pyprima.cobyla.cobyla.matprod

# This function moderates the constraint value, the constraint demanding this value
scipy._lib.pyprima.cobyla.cobyla.moderatec

# This function moderates the function value of a MINIMIZATION problem. It replaces
scipy._lib.pyprima.cobyla.cobyla.moderatef

# This function moderates a decision variable. It replaces NaN by 0 and Inf/-Inf by
scipy._lib.pyprima.cobyla.cobyla.moderatex

# NumPy
scipy._lib.pyprima.cobyla.cobyla.np

# This subroutine preprocesses the inputs. It does nothing to the inputs that are valid.
scipy._lib.pyprima.cobyla.cobyla.preproc

# This is a Python equivalent of the Fortran 'present' function for optional arguments.
scipy._lib.pyprima.cobyla.cobyla.present

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobylb.CALLBACK_TERMINATE

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobylb.DAMAGING_ROUNDING

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.cobyla.cobylb.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.cobylb.EPS

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobylb.INFO_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobylb.MAXTR_REACHED

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobylb.MIN_MAXFILT

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.cobylb.REALMAX

# int([x]) -> integer
scipy._lib.pyprima.cobyla.cobylb.SMALL_TR_RADIUS

# This module checks whether to break out of the solver loop in the constrained case.
scipy._lib.pyprima.cobyla.cobylb.checkbreak_con

# This subroutine performs the actual computations of COBYLA.
scipy._lib.pyprima.cobyla.cobylb.cobylb

# This function evaluates CALCFC at X, returning the objective function value and the
scipy._lib.pyprima.cobyla.cobylb.evaluate

# This function calculates the ratio between the "typical change" of F and that of CONSTR.
scipy._lib.pyprima.cobyla.cobylb.fcratio

# This subroutine identifies the best vertex of the current simplex with respect to the merit
scipy._lib.pyprima.cobyla.cobylb.findpole

# This subroutine prints messages for each evaluation of the objective function.
scipy._lib.pyprima.cobyla.cobylb.fmsg

# This function calculates a geometry step so that the geometry of the interpolation set is improved
scipy._lib.pyprima.cobyla.cobylb.geostep

# This function gets the penalty parameter CPEN so that PREREM = PREREF + CPEN * PREREC > 0.
scipy._lib.pyprima.cobyla.cobylb.getcpen

# This function initializes the filter (XFILT, etc) that will be used when selecting
scipy._lib.pyprima.cobyla.cobylb.initfilt

# This subroutine does the initialization concerning X, function values, and
scipy._lib.pyprima.cobyla.cobylb.initxfc

scipy._lib.pyprima.cobyla.cobylb.inprod

# This procedure tests whether A = B^{-1} up to the tolerance TOL.
scipy._lib.pyprima.cobyla.cobylb.isinv

scipy._lib.pyprima.cobyla.cobylb.matprod

scipy._lib.pyprima.cobyla.cobylb.norm

# NumPy
scipy._lib.pyprima.cobyla.cobylb.np

# Believe it or now, x**2 is not always the same as x*x in Python. In Fortran they
scipy._lib.pyprima.cobyla.cobylb.primapow2

# According to its documentation, np.sum will sometimes do partial pairwise summation.
scipy._lib.pyprima.cobyla.cobylb.primasum

# This function evaluates the reduction ratio of a trust-region step, handling inf/nan properly.
scipy._lib.pyprima.cobyla.cobylb.redrat

# This function calculates RHO when it needs to be reduced.
scipy._lib.pyprima.cobyla.cobylb.redrho

# This function prints messages at return.
scipy._lib.pyprima.cobyla.cobylb.retmsg

# This function prints messages when RHO is updated.
scipy._lib.pyprima.cobyla.cobylb.rhomsg

# This subroutine saves X, F, and CSTRV in XFILT, FFILT, and CFILT (and CONSTR in CONFILT
scipy._lib.pyprima.cobyla.cobylb.savefilt

# Save the data values to the history lists.
scipy._lib.pyprima.cobyla.cobylb.savehist

# This subroutine selects X according to FHIST and CHIST, which represents (a part of) history
scipy._lib.pyprima.cobyla.cobylb.selectx

# This function finds (the index) of a current interpolation point to be replaced with
scipy._lib.pyprima.cobyla.cobylb.setdrop_tr

# This function updates the trust region radius according to RATIO and DNORM.
scipy._lib.pyprima.cobyla.cobylb.trrad

# This function calculated an n-component vector d by the following two stages. In the first
scipy._lib.pyprima.cobyla.cobylb.trstlp

scipy._lib.pyprima.cobyla.cobylb.updatepole

# This function revises the simplex by updating the elements of SIM, SIMI, FVAL, CONMAT, and CVAL
scipy._lib.pyprima.cobyla.cobylb.updatexfc

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.cobyla.geometry.DEBUGGING

# This function calculates a geometry step so that the geometry of the interpolation set is improved
scipy._lib.pyprima.cobyla.geometry.geostep

scipy._lib.pyprima.cobyla.geometry.inprod

# This procedure tests whether A = B^{-1} up to the tolerance TOL.
scipy._lib.pyprima.cobyla.geometry.isinv

scipy._lib.pyprima.cobyla.geometry.matprod

scipy._lib.pyprima.cobyla.geometry.norm

# NumPy
scipy._lib.pyprima.cobyla.geometry.np

# Believe it or now, x**2 is not always the same as x*x in Python. In Fortran they
scipy._lib.pyprima.cobyla.geometry.primapow2

# According to its documentation, np.sum will sometimes do partial pairwise summation.
scipy._lib.pyprima.cobyla.geometry.primasum

# This function finds (the index) of a current interpolation point to be replaced with
scipy._lib.pyprima.cobyla.geometry.setdrop_tr

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.cobyla.initialize.DEBUGGING

# int([x]) -> integer
scipy._lib.pyprima.cobyla.initialize.INFO_DEFAULT

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.initialize.REALMAX

# This module checks whether to break out of the solver loop in the constrained case.
scipy._lib.pyprima.cobyla.initialize.checkbreak_con

# This function evaluates CALCFC at X, returning the objective function value and the
scipy._lib.pyprima.cobyla.initialize.evaluate

# This subroutine prints messages for each evaluation of the objective function.
scipy._lib.pyprima.cobyla.initialize.fmsg

# This function initializes the filter (XFILT, etc) that will be used when selecting
scipy._lib.pyprima.cobyla.initialize.initfilt

# This subroutine does the initialization concerning X, function values, and
scipy._lib.pyprima.cobyla.initialize.initxfc

scipy._lib.pyprima.cobyla.initialize.inv

# NumPy
scipy._lib.pyprima.cobyla.initialize.np

# This subroutine saves X, F, and CSTRV in XFILT, FFILT, and CFILT (and CONSTR in CONFILT
scipy._lib.pyprima.cobyla.initialize.savefilt

# Save the data values to the history lists.
scipy._lib.pyprima.cobyla.initialize.savehist

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.cobyla.trustregion.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.trustregion.EPS

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.trustregion.REALMAX

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.cobyla.trustregion.REALMIN

scipy._lib.pyprima.cobyla.trustregion.inprod

# This function tests whether x is minor compared to ref. It is used by Powell, e.g., in COBYLA.
scipy._lib.pyprima.cobyla.trustregion.isminor

scipy._lib.pyprima.cobyla.trustregion.lsqr

scipy._lib.pyprima.cobyla.trustregion.matprod

# NumPy
scipy._lib.pyprima.cobyla.trustregion.np

# ============================
scipy._lib.pyprima.cobyla.trustregion.npt

# According to its documentation, np.sum will sometimes do partial pairwise summation.
scipy._lib.pyprima.cobyla.trustregion.primasum

# This function updates the QR factorization of an MxN matrix A of full column rank, attempting to
scipy._lib.pyprima.cobyla.trustregion.qradd_Rdiag

# This function updates the QR factorization for an MxN matrix A=Q@R so that the updated Q and
scipy._lib.pyprima.cobyla.trustregion.qrexc_Rdiag

# This function updates the trust region radius according to RATIO and DNORM.
scipy._lib.pyprima.cobyla.trustregion.trrad

# This function calculated an n-component vector d by the following two stages. In the first
scipy._lib.pyprima.cobyla.trustregion.trstlp

# This subroutine does the real calculations for trstlp, both stage 1 and stage 2.
scipy._lib.pyprima.cobyla.trustregion.trstlp_sub

# int([x]) -> integer
scipy._lib.pyprima.cobyla.update.DAMAGING_ROUNDING

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.cobyla.update.DEBUGGING

# int([x]) -> integer
scipy._lib.pyprima.cobyla.update.INFO_DEFAULT

# This subroutine identifies the best vertex of the current simplex with respect to the merit
scipy._lib.pyprima.cobyla.update.findpole

scipy._lib.pyprima.cobyla.update.inprod

scipy._lib.pyprima.cobyla.update.inv

# This procedure tests whether A = B^{-1} up to the tolerance TOL.
scipy._lib.pyprima.cobyla.update.isinv

scipy._lib.pyprima.cobyla.update.matprod

# NumPy
scipy._lib.pyprima.cobyla.update.np

scipy._lib.pyprima.cobyla.update.outprod

# According to its documentation, np.sum will sometimes do partial pairwise summation.
scipy._lib.pyprima.cobyla.update.primasum

scipy._lib.pyprima.cobyla.update.updatepole

# This function revises the simplex by updating the elements of SIM, SIMI, FVAL, CONMAT, and CVAL
scipy._lib.pyprima.cobyla.update.updatexfc

# Bounds constraint on the variables.
scipy._lib.pyprima.common._bounds.Bounds

# NumPy
scipy._lib.pyprima.common._bounds.np

# `bounds` can either be an object with the properties lb and ub, or a list of tuples
scipy._lib.pyprima.common._bounds.process_bounds

# Linear constraint on the variables.
scipy._lib.pyprima.common._linear_constraints.LinearConstraint

scipy._lib.pyprima.common._linear_constraints.combine_multiple_linear_constraints

# NumPy
scipy._lib.pyprima.common._linear_constraints.np

scipy._lib.pyprima.common._linear_constraints.separate_LC_into_eq_and_ineq

# NumPy
scipy._lib.pyprima.common._nonlinear_constraints.np

scipy._lib.pyprima.common._nonlinear_constraints.process_nl_constraints

# The Python interfaces receives the constraints as lb <= constraint(x) <= ub, 
scipy._lib.pyprima.common._nonlinear_constraints.transform_constraint_function

# Linear constraint on the variables.
scipy._lib.pyprima.common._project.LinearConstraint

# Represents the optimization result.
scipy._lib.pyprima.common._project.OptimizeResult

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common._project.eps

# NumPy
scipy._lib.pyprima.common._project.np

# Built-in immutable sequence.
scipy._lib.pyprima.common._project.scalar_types

# int([x]) -> integer
scipy._lib.pyprima.common.checkbreak.FTARGET_ACHIEVED

# int([x]) -> integer
scipy._lib.pyprima.common.checkbreak.INFO_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.checkbreak.MAXFUN_REACHED

# int([x]) -> integer
scipy._lib.pyprima.common.checkbreak.NAN_INF_F

# int([x]) -> integer
scipy._lib.pyprima.common.checkbreak.NAN_INF_X

# This module checks whether to break out of the solver loop in the constrained case.
scipy._lib.pyprima.common.checkbreak.checkbreak_con

# This module checks whether to break out of the solver loop in the unconstrained case.
scipy._lib.pyprima.common.checkbreak.checkbreak_unc

# NumPy
scipy._lib.pyprima.common.checkbreak.np

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.consts.BOUNDMAX

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.CONSTRMAX

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.consts.CTOL_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.CWEIGHT_DEFAULT

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.consts.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.consts.EPS

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.ETA1_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.ETA2_DEFAULT

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.consts.FTARGET_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.FUNCMAX

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.GAMMA1_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.consts.GAMMA2_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.consts.IPRINT_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.consts.MAXFILT_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.consts.MAXFUN_DIM_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.consts.MAXHISTMEM

# int([x]) -> integer
scipy._lib.pyprima.common.consts.MHM

# int([x]) -> integer
scipy._lib.pyprima.common.consts.MIN_MAXFILT

# int([x]) -> integer
scipy._lib.pyprima.common.consts.PRIMA_MAX_HIST_MEM_MB

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.consts.REALMAX

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.consts.REALMIN

# int([x]) -> integer
scipy._lib.pyprima.common.consts.RHOBEG_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.consts.RHOEND_DEFAULT

# NumPy
scipy._lib.pyprima.common.consts.np

# OS routines for NT or Posix depending on what system we're on.
scipy._lib.pyprima.common.consts.os

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.evaluate.CONSTRMAX

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.evaluate.DEBUGGING

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.evaluate.FUNCMAX

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.evaluate.REALMAX

# This function evaluates CALCFC at X, returning the objective function value and the
scipy._lib.pyprima.common.evaluate.evaluate

scipy._lib.pyprima.common.evaluate.matprod

# This function moderates the constraint value, the constraint demanding this value
scipy._lib.pyprima.common.evaluate.moderatec

# This function moderates the function value of a MINIMIZATION problem. It replaces
scipy._lib.pyprima.common.evaluate.moderatef

# This function moderates a decision variable. It replaces NaN by 0 and Inf/-Inf by
scipy._lib.pyprima.common.evaluate.moderatex

# NumPy
scipy._lib.pyprima.common.evaluate.np

# According to its documentation, np.sum will sometimes do partial pairwise summation.
scipy._lib.pyprima.common.evaluate.primasum

# Save the data values to the history lists.
scipy._lib.pyprima.common.history.savehist

# int([x]) -> integer
scipy._lib.pyprima.common.infos.ASSERTION_FAILS

# int([x]) -> integer
scipy._lib.pyprima.common.infos.CALLBACK_TERMINATE

# int([x]) -> integer
scipy._lib.pyprima.common.infos.DAMAGING_ROUNDING

# int([x]) -> integer
scipy._lib.pyprima.common.infos.FTARGET_ACHIEVED

# int([x]) -> integer
scipy._lib.pyprima.common.infos.INFO_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.infos.INVALID_INPUT

# int([x]) -> integer
scipy._lib.pyprima.common.infos.MAXFUN_REACHED

# int([x]) -> integer
scipy._lib.pyprima.common.infos.MAXTR_REACHED

# int([x]) -> integer
scipy._lib.pyprima.common.infos.MEMORY_ALLOCATION_FAILS

# int([x]) -> integer
scipy._lib.pyprima.common.infos.NAN_INF_F

# int([x]) -> integer
scipy._lib.pyprima.common.infos.NAN_INF_MODEL

# int([x]) -> integer
scipy._lib.pyprima.common.infos.NAN_INF_X

# int([x]) -> integer
scipy._lib.pyprima.common.infos.NO_SPACE_BETWEEN_BOUNDS

# int([x]) -> integer
scipy._lib.pyprima.common.infos.SMALL_TR_RADIUS

# int([x]) -> integer
scipy._lib.pyprima.common.infos.TRSUBP_FAILED

# int([x]) -> integer
scipy._lib.pyprima.common.infos.VALIDATION_FAILS

# int([x]) -> integer
scipy._lib.pyprima.common.infos.ZERO_LINEAR_CONSTRAINT

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.linalg.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.linalg.EPS

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.linalg.REALMAX

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.linalg.REALMIN

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.linalg.USE_NAIVE_MATH

# Get a relative tolerance for a set of arrays. Borrowed from COBYQA
scipy._lib.pyprima.common.linalg.get_arrays_tol

scipy._lib.pyprima.common.linalg.hypot

scipy._lib.pyprima.common.linalg.inprod

scipy._lib.pyprima.common.linalg.inv

# This procedure tests whether A = B^{-1} up to the tolerance TOL.
scipy._lib.pyprima.common.linalg.isinv

# This function tests whether x is minor compared to ref. It is used by Powell, e.g., in COBYLA.
scipy._lib.pyprima.common.linalg.isminor

# This function tests whether the matrix A has orthonormal columns up to the tolerance TOL.
scipy._lib.pyprima.common.linalg.isorth

scipy._lib.pyprima.common.linalg.istril

scipy._lib.pyprima.common.linalg.istriu

scipy._lib.pyprima.common.linalg.lsqr

scipy._lib.pyprima.common.linalg.matprod

scipy._lib.pyprima.common.linalg.matprod12

scipy._lib.pyprima.common.linalg.matprod21

scipy._lib.pyprima.common.linalg.matprod22

scipy._lib.pyprima.common.linalg.norm

# NumPy
scipy._lib.pyprima.common.linalg.np

scipy._lib.pyprima.common.linalg.outprod

# As in MATLAB, planerot(x) returns a 2x2 Givens matrix G for x in R2 so that Y=G@x has Y[1] = 0.
scipy._lib.pyprima.common.linalg.planerot

# This is a Python equivalent of the Fortran 'present' function for optional arguments.
scipy._lib.pyprima.common.linalg.present

# Believe it or now, x**2 is not always the same as x*x in Python. In Fortran they
scipy._lib.pyprima.common.linalg.primapow2

# According to its documentation, np.sum will sometimes do partial pairwise summation.
scipy._lib.pyprima.common.linalg.primasum

scipy._lib.pyprima.common.linalg.qr

# int([x]) -> integer
scipy._lib.pyprima.common.message.CALLBACK_TERMINATE

# int([x]) -> integer
scipy._lib.pyprima.common.message.DAMAGING_ROUNDING

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.message.DEBUGGING

# int([x]) -> integer
scipy._lib.pyprima.common.message.FTARGET_ACHIEVED

# int([x]) -> integer
scipy._lib.pyprima.common.message.MAXFUN_REACHED

# int([x]) -> integer
scipy._lib.pyprima.common.message.MAXTR_REACHED

# int([x]) -> integer
scipy._lib.pyprima.common.message.NAN_INF_F

# int([x]) -> integer
scipy._lib.pyprima.common.message.NAN_INF_MODEL

# int([x]) -> integer
scipy._lib.pyprima.common.message.NAN_INF_X

# int([x]) -> integer
scipy._lib.pyprima.common.message.NO_SPACE_BETWEEN_BOUNDS

# int([x]) -> integer
scipy._lib.pyprima.common.message.SMALL_TR_RADIUS

# int([x]) -> integer
scipy._lib.pyprima.common.message.TRSUBP_FAILED

# int([x]) -> integer
scipy._lib.pyprima.common.message.ZERO_LINEAR_CONSTRAINT

# This function prints a message when CPEN is updated.
scipy._lib.pyprima.common.message.cpenmsg

# This subroutine prints messages for each evaluation of the objective function.
scipy._lib.pyprima.common.message.fmsg

scipy._lib.pyprima.common.message.get_info_string

# NumPy
scipy._lib.pyprima.common.message.np

# This is a Python equivalent of the Fortran 'present' function for optional arguments.
scipy._lib.pyprima.common.message.present

# This function prints messages at return.
scipy._lib.pyprima.common.message.retmsg

# This function prints messages when RHO is updated.
scipy._lib.pyprima.common.message.rhomsg

# str(object='') -> str
scipy._lib.pyprima.common.message.spaces

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.powalg.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.powalg.EPS

scipy._lib.pyprima.common.powalg.hypot

scipy._lib.pyprima.common.powalg.inprod

# This function tests whether x is minor compared to ref. It is used by Powell, e.g., in COBYLA.
scipy._lib.pyprima.common.powalg.isminor

scipy._lib.pyprima.common.powalg.matprod

# NumPy
scipy._lib.pyprima.common.powalg.np

# As in MATLAB, planerot(x) returns a 2x2 Givens matrix G for x in R2 so that Y=G@x has Y[1] = 0.
scipy._lib.pyprima.common.powalg.planerot

# This function updates the QR factorization of an MxN matrix A of full column rank, attempting to
scipy._lib.pyprima.common.powalg.qradd_Rdiag

# This function updates the QR factorization for an MxN matrix A=Q@R so that the updated Q and
scipy._lib.pyprima.common.powalg.qrexc_Rdiag

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.preproc.CTOL_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.preproc.CWEIGHT_DEFAULT

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.preproc.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.preproc.EPS

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.preproc.ETA1_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.preproc.ETA2_DEFAULT

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.preproc.FTARGET_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.preproc.GAMMA1_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.preproc.GAMMA2_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.preproc.IPRINT_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.preproc.MAXFILT_DEFAULT

# int([x]) -> integer
scipy._lib.pyprima.common.preproc.MAXHISTMEM

# int([x]) -> integer
scipy._lib.pyprima.common.preproc.MIN_MAXFILT

# int([x]) -> integer
scipy._lib.pyprima.common.preproc.RHOBEG_DEFAULT

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.preproc.RHOEND_DEFAULT

# NumPy
scipy._lib.pyprima.common.preproc.np

# This subroutine preprocesses the inputs. It does nothing to the inputs that are valid.
scipy._lib.pyprima.common.preproc.preproc

# This is a Python equivalent of the Fortran 'present' function for optional arguments.
scipy._lib.pyprima.common.preproc.present

# Issue a warning, or maybe ignore it or raise an exception.
scipy._lib.pyprima.common.preproc.warn

# This is a Python equivalent of the Fortran 'present' function for optional arguments.
scipy._lib.pyprima.common.present.present

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.ratio.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.ratio.REALMAX

# NumPy
scipy._lib.pyprima.common.ratio.np

# This function evaluates the reduction ratio of a trust-region step, handling inf/nan properly.
scipy._lib.pyprima.common.ratio.redrat

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.redrho.DEBUGGING

# NumPy
scipy._lib.pyprima.common.redrho.np

# This function calculates RHO when it needs to be reduced.
scipy._lib.pyprima.common.redrho.redrho

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.selectx.CONSTRMAX

# Returns True when the argument is true, False otherwise.
scipy._lib.pyprima.common.selectx.DEBUGGING

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.selectx.EPS

# Convert a string or number to a floating-point number, if possible.
scipy._lib.pyprima.common.selectx.FUNCMAX

# Double-precision floating-point number type, compatible with Python
scipy._lib.pyprima.common.selectx.REALMAX

# This function compares whether FC1 = (F1, C1) is (strictly) better than FC2 = (F2, C2), which
scipy._lib.pyprima.common.selectx.isbetter

# NumPy
scipy._lib.pyprima.common.selectx.np

# ============================
scipy._lib.pyprima.common.selectx.npt

# This is a Python equivalent of the Fortran 'present' function for optional arguments.
scipy._lib.pyprima.common.selectx.present

# This subroutine saves X, F, and CSTRV in XFILT, FFILT, and CFILT (and CONSTR in CONFILT
scipy._lib.pyprima.common.selectx.savefilt

# This subroutine selects X according to FHIST and CHIST, which represents (a part of) history
scipy._lib.pyprima.common.selectx.selectx

# An exception that is thrown when no compatible backend is found for a method.
scipy._lib.uarray.BackendNotImplementedError

# A utility class which marks an argument with a specific dispatch type.
scipy._lib.uarray.Dispatchable

# Marks all unmarked arguments as a given type.
scipy._lib.uarray.all_of_type

# This utility method clears registered backends.
scipy._lib.uarray.clear_backends

# Creates a decorator for generating multimethods.
scipy._lib.uarray.create_multimethod

# Set the backend to the first active backend that supports ``value``
scipy._lib.uarray.determine_backend

# Set a backend supporting all ``dispatchables``
scipy._lib.uarray.determine_backend_multi

# Generates a multimethod.
scipy._lib.uarray.generate_multimethod

# Returns an opaque object containing the current state of all the backends.
scipy._lib.uarray.get_state

# Creates a utility function to mark something as a specific type.
scipy._lib.uarray.mark_as

# This utility method sets registers backend for permanent use. It
scipy._lib.uarray.register_backend

# Returns a context manager that resets all state once exited.
scipy._lib.uarray.reset_state

# A context manager that sets the preferred backend.
scipy._lib.uarray.set_backend

# This utility method replaces the default backend for permanent use. It
scipy._lib.uarray.set_global_backend

# A context manager that sets the state of the backends to one returned by :obj:`get_state`.
scipy._lib.uarray.set_state

# A context manager that allows one to skip a given backend from processing
scipy._lib.uarray.skip_backend

# Wraps a ``__ua_convert__`` defined for a single element to all elements.
scipy._lib.uarray.wrap_single_convertor

# Wraps a ``__ua_convert__`` defined for a single element to all elements.
scipy._lib.uarray.wrap_single_convertor_instance

# Binary heap.
scipy.cluster._hierarchy.Heap

# Structure for fast cluster labeling in unsorted dendrogram.
scipy.cluster._hierarchy.LinkageUnionFind

# Calculate the size of each cluster. The result is the fourth column of
scipy.cluster._hierarchy.calculate_cluster_sizes

# Form flat clusters by distance criterion.
scipy.cluster._hierarchy.cluster_dist

# Form flat clusters by inconsistent criterion.
scipy.cluster._hierarchy.cluster_in

# Form flat clusters by maxclust criterion.
scipy.cluster._hierarchy.cluster_maxclust_dist

# Form flat clusters by maxclust_monocrit criterion.
scipy.cluster._hierarchy.cluster_maxclust_monocrit

# Form flat clusters by monocrit criterion.
scipy.cluster._hierarchy.cluster_monocrit

# Calculate the cophenetic distances between each observation
scipy.cluster._hierarchy.cophenetic_distances

# Perform hierarchy clustering.
scipy.cluster._hierarchy.fast_linkage

# Get the maximum statistic for each non-singleton cluster. For the i'th
scipy.cluster._hierarchy.get_max_Rfield_for_each_cluster

# Get the maximum inconsistency coefficient for each non-singleton cluster.
scipy.cluster._hierarchy.get_max_dist_for_each_cluster

# Calculate the inconsistency statistics.
scipy.cluster._hierarchy.inconsistent

# Find the leader (root) of each flat cluster.
scipy.cluster._hierarchy.leaders

# Perform hierarchy clustering.
scipy.cluster._hierarchy.linkage

# Perform hierarchy clustering using MST algorithm for single linkage.
scipy.cluster._hierarchy.mst_single_linkage

# Perform hierarchy clustering using nearest-neighbor chain algorithm.
scipy.cluster._hierarchy.nn_chain

# NumPy
scipy.cluster._hierarchy.np

# Perform a pre-order traversal on the linkage tree and get a list of ids
scipy.cluster._hierarchy.prelist

# Return True if input array is a valid distance matrix.
scipy.cluster._optimal_leaf_ordering.is_valid_dm

# Return True if the input array is a valid condensed distance matrix.
scipy.cluster._optimal_leaf_ordering.is_valid_y

# NumPy
scipy.cluster._optimal_leaf_ordering.np

# Compute the optimal leaf order for Z (according to D) and return an
scipy.cluster._optimal_leaf_ordering.optimal_leaf_ordering

# Convert a vector-form distance vector to a square-form distance
scipy.cluster._optimal_leaf_ordering.squareform

# NumPy
scipy.cluster._vq.np

# The update-step of K-means. Calculate the mean of observations in each
scipy.cluster._vq.update_cluster_means

# Vector quantization ndarray wrapper. Only support float32 and float64.
scipy.cluster._vq.vq

# A tree node class for representing a cluster.
scipy.cluster.hierarchy.ClusterNode

# Disjoint set data structure for incremental connectivity queries.
scipy.cluster.hierarchy.DisjointSet

# Perform average/UPGMA linkage on a condensed distance matrix.
scipy.cluster.hierarchy.average

# Perform centroid/UPGMC linkage.
scipy.cluster.hierarchy.centroid

# Perform complete/max/farthest point linkage on a condensed distance matrix.
scipy.cluster.hierarchy.complete

# Calculate the cophenetic distances between each observation in
scipy.cluster.hierarchy.cophenet

# Check for correspondence between linkage and condensed distance matrices.
scipy.cluster.hierarchy.correspond

# Given a linkage matrix Z, return the cut tree.
scipy.cluster.hierarchy.cut_tree

# Plot the hierarchical clustering as a dendrogram.
scipy.cluster.hierarchy.dendrogram

# Form flat clusters from the hierarchical clustering defined by
scipy.cluster.hierarchy.fcluster

# Cluster observation data using a given metric.
scipy.cluster.hierarchy.fclusterdata

# Convert a linkage matrix generated by MATLAB(TM) to a new
scipy.cluster.hierarchy.from_mlab_linkage

# Calculate inconsistency statistics on a linkage matrix.
scipy.cluster.hierarchy.inconsistent

# Determine if two different cluster assignments are equivalent.
scipy.cluster.hierarchy.is_isomorphic

# Return True if the linkage passed is monotonic.
scipy.cluster.hierarchy.is_monotonic

# Return True if the inconsistency matrix passed is valid.
scipy.cluster.hierarchy.is_valid_im

# Check the validity of a linkage matrix.
scipy.cluster.hierarchy.is_valid_linkage

# Return the root nodes in a hierarchical clustering.
scipy.cluster.hierarchy.leaders

# Return a list of leaf node ids.
scipy.cluster.hierarchy.leaves_list

# Perform hierarchical/agglomerative clustering.
scipy.cluster.hierarchy.linkage

# Return the maximum statistic for each non-singleton cluster and its
scipy.cluster.hierarchy.maxRstat

# Return the maximum distance between any non-singleton cluster.
scipy.cluster.hierarchy.maxdists

# Return the maximum inconsistency coefficient for each
scipy.cluster.hierarchy.maxinconsts

# Perform median/WPGMC linkage.
scipy.cluster.hierarchy.median

# Return the number of original observations of the linkage matrix passed.
scipy.cluster.hierarchy.num_obs_linkage

# Given a linkage matrix Z and distance, reorder the cut tree.
scipy.cluster.hierarchy.optimal_leaf_ordering

# Set list of matplotlib color codes for use by dendrogram.
scipy.cluster.hierarchy.set_link_color_palette

# Perform single/min/nearest linkage on the condensed distance matrix ``y``.
scipy.cluster.hierarchy.single

# Convert a linkage matrix to a MATLAB(TM) compatible one.
scipy.cluster.hierarchy.to_mlab_linkage

# Convert a linkage matrix into an easy-to-use tree object.
scipy.cluster.hierarchy.to_tree

# Perform Ward's linkage on a condensed distance matrix.
scipy.cluster.hierarchy.ward

# Perform weighted/WPGMA linkage on the condensed distance matrix.
scipy.cluster.hierarchy.weighted

# Performs k-means on a set of observation vectors forming k clusters.
scipy.cluster.vq.kmeans

# Classify a set of observations into k clusters using the k-means algorithm.
scipy.cluster.vq.kmeans2

# Assign codes from a code book to observations.
scipy.cluster.vq.vq

# Normalize a group of observations on a per feature basis.
scipy.cluster.vq.whiten

# Accessing a constant no longer in current CODATA data set
scipy.constants._codata.ConstantWarning

# Return list of physical_constant keys containing a given string.
scipy.constants._codata.find

# dict() -> new empty dictionary
scipy.constants._codata.physical_constants

# Relative precision in physical_constants indexed by key
scipy.constants._codata.precision

# Unit in physical_constants indexed by key
scipy.constants._codata.unit

# Value in physical_constants indexed by key
scipy.constants._codata.value

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Avogadro

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Boltzmann

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Btu

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Btu_IT

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Btu_th

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.G

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Julian_year

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.N_A

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Planck

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.R

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Rydberg

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Stefan_Boltzmann

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.Wien

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.acre

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.alpha

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.angstrom

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.arcmin

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.arcminute

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.arcsec

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.arcsecond

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.astronomical_unit

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.atm

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.atmosphere

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.atomic_mass

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.atto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.au

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.bar

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.barrel

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.bbl

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.blob

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.c

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.calorie

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.calorie_IT

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.calorie_th

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.carat

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.centi

# Convert from a temperature scale to another one among Celsius, Kelvin,
scipy.constants._constants.convert_temperature

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.day

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.deci

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.degree

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.degree_Fahrenheit

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.deka

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.dyn

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.dyne

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.e

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.eV

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.electron_mass

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.electron_volt

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.elementary_charge

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.epsilon_0

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.erg

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.exa

# int([x]) -> integer
scipy.constants._constants.exbi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.femto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.fermi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.fine_structure

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.fluid_ounce

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.fluid_ounce_US

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.fluid_ounce_imp

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.foot

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.g

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.gallon

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.gallon_US

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.gallon_imp

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.gas_constant

# int([x]) -> integer
scipy.constants._constants.gibi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.giga

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.golden

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.golden_ratio

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.grain

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.gram

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.gravitational_constant

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.h

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.hbar

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.hectare

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.hecto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.horsepower

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.hour

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.hp

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.inch

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.k

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.kgf

# int([x]) -> integer
scipy.constants._constants.kibi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.kilo

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.kilogram_force

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.kmh

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.knot

# Convert wavelength to optical frequency
scipy.constants._constants.lambda2nu

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.lb

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.lbf

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.light_year

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.liter

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.litre

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.long_ton

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.m_e

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.m_n

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.m_p

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.m_u

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mach

# int([x]) -> integer
scipy.constants._constants.mebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mega

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.metric_ton

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.micro

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.micron

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mil

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mile

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.milli

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.minute

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mmHg

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mph

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.mu_0

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.nano

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.nautical_mile

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.neutron_mass

# Convert optical frequency to wavelength.
scipy.constants._constants.nu2lambda

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.ounce

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.oz

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.parsec

# int([x]) -> integer
scipy.constants._constants.pebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.peta

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.pi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.pico

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.point

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.pound

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.pound_force

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.proton_mass

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.psi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.pt

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.quecto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.quetta

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.ronna

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.ronto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.short_ton

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.sigma

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.slinch

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.slug

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.speed_of_light

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.speed_of_sound

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.stone

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.survey_foot

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.survey_mile

# int([x]) -> integer
scipy.constants._constants.tebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.tera

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.ton_TNT

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.torr

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.troy_ounce

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.troy_pound

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.u

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.week

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.yard

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.year

# int([x]) -> integer
scipy.constants._constants.yobi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.yocto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.yotta

# int([x]) -> integer
scipy.constants._constants.zebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.zepto

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.zero_Celsius

# Convert a string or number to a floating-point number, if possible.
scipy.constants._constants.zetta

# Accessing a constant no longer in current CODATA data set
scipy.constants.codata.ConstantWarning

# Convert a string or number to a floating-point number, if possible.
scipy.constants.codata.c

# Return list of physical_constant keys containing a given string.
scipy.constants.codata.find

# str(object='') -> str
scipy.constants.codata.k

# dict() -> new empty dictionary
scipy.constants.codata.physical_constants

# Relative precision in physical_constants indexed by key
scipy.constants.codata.precision

# Unit in physical_constants indexed by key
scipy.constants.codata.unit

# Value in physical_constants indexed by key
scipy.constants.codata.value

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Avogadro

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Boltzmann

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Btu

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Btu_IT

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Btu_th

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.G

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Julian_year

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.N_A

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Planck

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.R

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Rydberg

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Stefan_Boltzmann

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.Wien

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.acre

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.alpha

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.angstrom

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.arcmin

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.arcminute

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.arcsec

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.arcsecond

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.astronomical_unit

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.atm

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.atmosphere

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.atomic_mass

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.atto

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.au

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.bar

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.barrel

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.bbl

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.blob

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.c

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.calorie

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.calorie_IT

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.calorie_th

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.carat

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.centi

# Convert from a temperature scale to another one among Celsius, Kelvin,
scipy.constants.constants.convert_temperature

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.day

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.deci

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.degree

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.degree_Fahrenheit

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.deka

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.dyn

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.dyne

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.e

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.eV

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.electron_mass

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.electron_volt

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.elementary_charge

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.epsilon_0

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.erg

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.exa

# int([x]) -> integer
scipy.constants.constants.exbi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.femto

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.fermi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.fine_structure

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.fluid_ounce

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.fluid_ounce_US

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.fluid_ounce_imp

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.foot

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.g

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.gallon

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.gallon_US

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.gallon_imp

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.gas_constant

# int([x]) -> integer
scipy.constants.constants.gibi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.giga

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.golden

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.golden_ratio

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.grain

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.gram

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.gravitational_constant

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.h

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.hbar

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.hectare

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.hecto

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.horsepower

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.hour

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.hp

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.inch

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.k

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.kgf

# int([x]) -> integer
scipy.constants.constants.kibi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.kilo

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.kilogram_force

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.kmh

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.knot

# Convert wavelength to optical frequency
scipy.constants.constants.lambda2nu

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.lb

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.lbf

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.light_year

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.liter

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.litre

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.long_ton

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.m_e

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.m_n

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.m_p

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.m_u

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mach

# int([x]) -> integer
scipy.constants.constants.mebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mega

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.metric_ton

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.micro

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.micron

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mil

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mile

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.milli

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.minute

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mmHg

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mph

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.mu_0

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.nano

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.nautical_mile

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.neutron_mass

# Convert optical frequency to wavelength.
scipy.constants.constants.nu2lambda

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.ounce

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.oz

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.parsec

# int([x]) -> integer
scipy.constants.constants.pebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.peta

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.pi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.pico

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.point

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.pound

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.pound_force

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.proton_mass

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.psi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.pt

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.short_ton

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.sigma

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.slinch

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.slug

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.speed_of_light

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.speed_of_sound

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.stone

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.survey_foot

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.survey_mile

# int([x]) -> integer
scipy.constants.constants.tebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.tera

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.ton_TNT

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.torr

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.troy_ounce

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.troy_pound

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.u

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.week

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.yard

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.year

# int([x]) -> integer
scipy.constants.constants.yobi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.yocto

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.yotta

# int([x]) -> integer
scipy.constants.constants.zebi

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.zepto

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.zero_Celsius

# Convert a string or number to a floating-point number, if possible.
scipy.constants.constants.zetta

# Command-line parsing library
scipy.datasets._download_all.argparse

# Utility method to download all the dataset files
scipy.datasets._download_all.download_all

scipy.datasets._download_all.main

# The type of the None singleton.
scipy.datasets._download_all.pooch

# array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
scipy.datasets._fetchers.array

# Get an 8-bit grayscale bit-depth, 512 x 512 derived image for easy
scipy.datasets._fetchers.ascent

# The type of the None singleton.
scipy.datasets._fetchers.data_fetcher

# Load an electrocardiogram as an example for a 1-D signal.
scipy.datasets._fetchers.electrocardiogram

# Get a 1024 x 768, color image of a raccoon face.
scipy.datasets._fetchers.face

scipy.datasets._fetchers.fetch_data

# frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)
scipy.datasets._fetchers.frombuffer

# Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.
scipy.datasets._fetchers.load

# The type of the None singleton.
scipy.datasets._fetchers.pooch

# dict() -> new empty dictionary
scipy.datasets._fetchers.registry

# dict() -> new empty dictionary
scipy.datasets._fetchers.registry_urls

# This module provides access to some objects used or maintained by the
scipy.datasets._fetchers.sys

# dict() -> new empty dictionary
scipy.datasets._registry.method_files_map

# dict() -> new empty dictionary
scipy.datasets._registry.registry

# dict() -> new empty dictionary
scipy.datasets._registry.registry_urls

# Cleans the scipy datasets cache directory.
scipy.datasets._utils.clear_cache

# dict() -> new empty dictionary
scipy.datasets._utils.method_files_map

# OS routines for NT or Posix depending on what system we're on.
scipy.datasets._utils.os

# Utilities for determining application-specific dirs.
scipy.datasets._utils.platformdirs

# Utility functions for copying and archiving files and directory trees.
scipy.datasets._utils.shutil

# Get the array API compatible namespace for the arrays xs.
scipy.differentiate._differentiate.array_namespace

# Evaluate the derivative of a elementwise, real scalar function numerically.
scipy.differentiate._differentiate.derivative

scipy.differentiate._differentiate.eim

# Evaluate the Hessian of a function numerically.
scipy.differentiate._differentiate.hessian

# Evaluate the Jacobian of a function numerically.
scipy.differentiate._differentiate.jacobian

# NumPy
scipy.differentiate._differentiate.np

# Python part of the warnings subsystem.
scipy.differentiate._differentiate.warnings

# Copies an array.
scipy.differentiate._differentiate.xp_copy

# Promotes elements of *args to result dtype, ignoring `None`s.
scipy.differentiate._differentiate.xp_promote

# Extra array functions built on top of the array API standard.
scipy.differentiate._differentiate.xpx

# Register a backend for permanent use.
scipy.fft._backend.register_backend

# Context manager to set the backend within a fixed scope.
scipy.fft._backend.set_backend

# Sets the global fft backend
scipy.fft._backend.set_global_backend

# Context manager to skip a backend within a fixed scope.
scipy.fft._backend.skip_backend

# `uarray` provides functions for generating multimethods that dispatch to
scipy.fft._backend.ua

# A utility class which marks an argument with a specific dispatch type.
scipy.fft._basic.Dispatchable

# Compute the 1-D discrete Fourier Transform.
scipy.fft._basic.fft

# Compute the 2-D discrete Fourier Transform
scipy.fft._basic.fft2

# Compute the N-D discrete Fourier Transform.
scipy.fft._basic.fftn

# Generates a multimethod.
scipy.fft._basic.generate_multimethod

# Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
scipy.fft._basic.hfft

# Compute the 2-D FFT of a Hermitian complex array.
scipy.fft._basic.hfft2

# Compute the N-D FFT of Hermitian symmetric complex input, i.e., a
scipy.fft._basic.hfftn

# Compute the 1-D inverse discrete Fourier Transform.
scipy.fft._basic.ifft

# Compute the 2-D inverse discrete Fourier Transform.
scipy.fft._basic.ifft2

# Compute the N-D inverse discrete Fourier Transform.
scipy.fft._basic.ifftn

# Compute the inverse FFT of a signal that has Hermitian symmetry.
scipy.fft._basic.ihfft

# Compute the 2-D inverse FFT of a real spectrum.
scipy.fft._basic.ihfft2

# Compute the N-D inverse discrete Fourier Transform for a real
scipy.fft._basic.ihfftn

# Computes the inverse of `rfft`.
scipy.fft._basic.irfft

# Computes the inverse of `rfft2`
scipy.fft._basic.irfft2

# Computes the inverse of `rfftn`
scipy.fft._basic.irfftn

# NumPy
scipy.fft._basic.np

# Compute the 1-D discrete Fourier Transform for real input.
scipy.fft._basic.rfft

# Compute the 2-D FFT of a real array.
scipy.fft._basic.rfft2

# Compute the N-D discrete Fourier Transform for real input.
scipy.fft._basic.rfftn

# Get the array API compatible namespace for the arrays xs.
scipy.fft._basic_backend.array_namespace

# Build an unordered collection of unique elements.
scipy.fft._basic_backend.complex_funcs

scipy.fft._basic_backend.fft

scipy.fft._basic_backend.fft2

scipy.fft._basic_backend.fftn

scipy.fft._basic_backend.hfft

scipy.fft._basic_backend.hfft2

scipy.fft._basic_backend.hfftn

scipy.fft._basic_backend.ifft

scipy.fft._basic_backend.ifft2

scipy.fft._basic_backend.ifftn

scipy.fft._basic_backend.ihfft

scipy.fft._basic_backend.ihfft2

scipy.fft._basic_backend.ihfftn

scipy.fft._basic_backend.irfft

scipy.fft._basic_backend.irfft2

scipy.fft._basic_backend.irfftn

scipy.fft._basic_backend.is_complex

# Returns True if `xp` is a NumPy namespace.
scipy.fft._basic_backend.is_numpy

# NumPy
scipy.fft._basic_backend.np

scipy.fft._basic_backend.rfft

scipy.fft._basic_backend.rfft2

scipy.fft._basic_backend.rfftn

scipy.fft._basic_backend.xp_float_to_complex

scipy.fft._basic_backend.xp_unsupported_param_msg

# Backend that just prints the __ua_function__ arguments
scipy.fft._debug_backends.EchoBackend

# Backend that uses numpy.fft
scipy.fft._debug_backends.NumPyBackend

# NumPy
scipy.fft._debug_backends.np

# Compute the fast Hankel transform.
scipy.fft._fftlog.fht

# Return optimal offset for a fast Hankel transform.
scipy.fft._fftlog.fhtoffset

# Compute the inverse fast Hankel transform.
scipy.fft._fftlog.ifht

scipy.fft._fftlog_backend.fht

# Return optimal offset for a fast Hankel transform.
scipy.fft._fftlog_backend.fhtoffset

scipy.fft._fftlog_backend.ifht

# Get the array API compatible namespace for the arrays xs.
scipy.fft._helper.array_namespace

# Return the Discrete Fourier Transform sample frequencies.
scipy.fft._helper.fftfreq

# Shift the zero-frequency component to the center of the spectrum.
scipy.fft._helper.fftshift

# The inverse of `fftshift`. Although identical for even-length `x`, the
scipy.fft._helper.ifftshift

# Get useful information from live Python objects.
scipy.fft._helper.inspect

# Least-recently-used cache decorator.
scipy.fft._helper.lru_cache

# Find the next fast size of input data to ``fft``, for zero-padding, etc.
scipy.fft._helper.next_fast_len

# NumPy
scipy.fft._helper.np

# Find the previous fast size of input data to ``fft``.
scipy.fft._helper.prev_fast_len

# Return the Discrete Fourier Transform sample frequencies
scipy.fft._helper.rfftfreq

# Update a wrapper function to look like the wrapped function
scipy.fft._helper.update_wrapper

# Return discrete Fourier transform of real or complex sequence.
scipy.fft._pocketfft.basic.c2c

# Return multidimensional discrete Fourier transform.
scipy.fft._pocketfft.basic.c2cn

# Return inverse discrete Fourier transform of real sequence x.
scipy.fft._pocketfft.basic.c2r

# Multidimensional inverse discrete fourier transform with real output
scipy.fft._pocketfft.basic.c2rn

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.fft

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.fftn

# functools.py - Tools for working with functions and callable objects
scipy.fft._pocketfft.basic.functools

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.hfft

# 2-D discrete Fourier transform of a Hermitian sequence
scipy.fft._pocketfft.basic.hfft2

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.hfftn

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.ifft

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.ifftn

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.ihfft

# 2-D discrete inverse Fourier transform of a Hermitian sequence
scipy.fft._pocketfft.basic.ihfft2

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.ihfftn

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.irfft

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.irfft_fftpack

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.irfftn

# NumPy
scipy.fft._pocketfft.basic.np

# Fast Fourier and Hartley transforms.
scipy.fft._pocketfft.basic.pfft

# Discrete Fourier transform of a real sequence.
scipy.fft._pocketfft.basic.r2c

# Return multidimensional discrete Fourier transform of real input
scipy.fft._pocketfft.basic.r2cn

# FFT of a real sequence, returning fftpack half complex format
scipy.fft._pocketfft.basic.r2r_fftpack

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.rfft

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.rfft_fftpack

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.basic.rfftn

# Returns the default number of workers within the current context
scipy.fft._pocketfft.helper.get_workers

# Returns a good length to pad an FFT to.
scipy.fft._pocketfft.helper.good_size

# Returns the largest FFT length less than target length.
scipy.fft._pocketfft.helper.prev_good_size

# Context manager for the default number of workers used in `scipy.fft`
scipy.fft._pocketfft.helper.set_workers

# c2c(a: numpy.ndarray, axes: object = None, forward: bool = True, inorm: int = 0, out: object = None, nthreads: int = 1) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.c2c

# c2r(a: numpy.ndarray, axes: object = None, lastsize: int = 0, forward: bool = True, inorm: int = 0, out: object = None, nthreads: int = 1) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.c2r

# dct(a: numpy.ndarray, type: int, axes: object = None, inorm: int = 0, out: object = None, nthreads: int = 1, ortho: object = None) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.dct

# dst(a: numpy.ndarray, type: int, axes: object = None, inorm: int = 0, out: object = None, nthreads: int = 1, ortho: object = None) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.dst

# genuine_hartley(a: numpy.ndarray, axes: object = None, inorm: int = 0, out: object = None, nthreads: int = 1) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.genuine_hartley

# Returns a good length to pad an FFT to.
scipy.fft._pocketfft.pypocketfft.good_size

# Returns the largest FFT length less than target length.
scipy.fft._pocketfft.pypocketfft.prev_good_size

# r2c(a: numpy.ndarray, axes: object = None, forward: bool = True, inorm: int = 0, out: object = None, nthreads: int = 1) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.r2c

# r2r_fftpack(a: numpy.ndarray, axes: object, real2hermitian: bool, forward: bool, inorm: int = 0, out: object = None, nthreads: int = 1) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.r2r_fftpack

# separable_hartley(a: numpy.ndarray, axes: object = None, inorm: int = 0, out: object = None, nthreads: int = 1) -> numpy.ndarray
scipy.fft._pocketfft.pypocketfft.separable_hartley

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.dct

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.dctn

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.dst

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.dstn

# functools.py - Tools for working with functions and callable objects
scipy.fft._pocketfft.realtransforms.functools

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.idct

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.idctn

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.idst

# Create a new function with partial application of the given arguments
scipy.fft._pocketfft.realtransforms.idstn

# NumPy
scipy.fft._pocketfft.realtransforms.np

# Fast Fourier and Hartley transforms.
scipy.fft._pocketfft.realtransforms.pfft

# Return the Discrete Cosine Transform of arbitrary type sequence x.
scipy.fft._realtransforms.dct

# Return multidimensional Discrete Cosine Transform along the specified axes.
scipy.fft._realtransforms.dctn

# Return the Discrete Sine Transform of arbitrary type sequence x.
scipy.fft._realtransforms.dst

# Return multidimensional Discrete Sine Transform along the specified axes.
scipy.fft._realtransforms.dstn

# Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.
scipy.fft._realtransforms.idct

# Return multidimensional Inverse Discrete Cosine Transform along the specified axes.
scipy.fft._realtransforms.idctn

# Return the Inverse Discrete Sine Transform of an arbitrary type sequence.
scipy.fft._realtransforms.idst

# Return multidimensional Inverse Discrete Sine Transform along the specified axes.
scipy.fft._realtransforms.idstn

scipy.fft._realtransforms_backend.dct

scipy.fft._realtransforms_backend.dctn

scipy.fft._realtransforms_backend.dst

scipy.fft._realtransforms_backend.dstn

scipy.fft._realtransforms_backend.idct

scipy.fft._realtransforms_backend.idctn

scipy.fft._realtransforms_backend.idst

scipy.fft._realtransforms_backend.idstn

# Return discrete Fourier transform of real or complex sequence.
scipy.fftpack._basic.fft

# 2-D discrete Fourier transform.
scipy.fftpack._basic.fft2

# Return multidimensional discrete Fourier transform.
scipy.fftpack._basic.fftn

# Return discrete inverse Fourier transform of real or complex sequence.
scipy.fftpack._basic.ifft

# 2-D discrete inverse Fourier transform of real or complex sequence.
scipy.fftpack._basic.ifft2

# Return inverse multidimensional discrete Fourier transform.
scipy.fftpack._basic.ifftn

# Return inverse discrete Fourier transform of real sequence x.
scipy.fftpack._basic.irfft

# Discrete Fourier transform of a real sequence.
scipy.fftpack._basic.rfft

# Return the Discrete Fourier Transform sample frequencies.
scipy.fftpack._helper.fftfreq

# Shift the zero-frequency component to the center of the spectrum.
scipy.fftpack._helper.fftshift

# The inverse of `fftshift`. Although identical for even-length `x`, the
scipy.fftpack._helper.ifftshift

# Find the next fast size of input data to `fft`, for zero-padding, etc.
scipy.fftpack._helper.next_fast_len

# DFT sample frequencies (for usage with rfft, irfft).
scipy.fftpack._helper.rfftfreq

# Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence.
scipy.fftpack._pseudo_diffs.cc_diff

# Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence.
scipy.fftpack._pseudo_diffs.cs_diff

# Return kth derivative (or integral) of a periodic sequence x.
scipy.fftpack._pseudo_diffs.diff

# Return Hilbert transform of a periodic sequence x.
scipy.fftpack._pseudo_diffs.hilbert

# Return inverse Hilbert transform of a periodic sequence x.
scipy.fftpack._pseudo_diffs.ihilbert

# Return inverse h-Tilbert transform of a periodic sequence x.
scipy.fftpack._pseudo_diffs.itilbert

# Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.
scipy.fftpack._pseudo_diffs.sc_diff

# Shift periodic sequence x by a: y(u) = x(u+a).
scipy.fftpack._pseudo_diffs.shift

# Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.
scipy.fftpack._pseudo_diffs.ss_diff

# Return h-Tilbert transform of a periodic sequence x.
scipy.fftpack._pseudo_diffs.tilbert

# Return the Discrete Cosine Transform of arbitrary type sequence x.
scipy.fftpack._realtransforms.dct

# Return multidimensional Discrete Cosine Transform along the specified axes.
scipy.fftpack._realtransforms.dctn

# Return the Discrete Sine Transform of arbitrary type sequence x.
scipy.fftpack._realtransforms.dst

# Return multidimensional Discrete Sine Transform along the specified axes.
scipy.fftpack._realtransforms.dstn

# Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.
scipy.fftpack._realtransforms.idct

# Return multidimensional Discrete Cosine Transform along the specified axes.
scipy.fftpack._realtransforms.idctn

# Return the Inverse Discrete Sine Transform of an arbitrary type sequence.
scipy.fftpack._realtransforms.idst

# Return multidimensional Discrete Sine Transform along the specified axes.
scipy.fftpack._realtransforms.idstn

# Return discrete Fourier transform of real or complex sequence.
scipy.fftpack.basic.fft

# 2-D discrete Fourier transform.
scipy.fftpack.basic.fft2

# Return multidimensional discrete Fourier transform.
scipy.fftpack.basic.fftn

# Return discrete inverse Fourier transform of real or complex sequence.
scipy.fftpack.basic.ifft

# 2-D discrete inverse Fourier transform of real or complex sequence.
scipy.fftpack.basic.ifft2

# Return inverse multidimensional discrete Fourier transform.
scipy.fftpack.basic.ifftn

# Return inverse discrete Fourier transform of real sequence x.
scipy.fftpack.basic.irfft

# Discrete Fourier transform of a real sequence.
scipy.fftpack.basic.rfft

# y = convolve(x,omega,[swap_real_imag,overwrite_x])
scipy.fftpack.convolve.convolve

# y = convolve_z(x,omega_real,omega_imag,[overwrite_x])
scipy.fftpack.convolve.convolve_z

scipy.fftpack.convolve.destroy_convolve_cache

# omega = init_convolution_kernel(n,kernel_func,[d,zero_nyquist,kernel_func_extra_args])
scipy.fftpack.convolve.init_convolution_kernel

# Return the Discrete Fourier Transform sample frequencies.
scipy.fftpack.helper.fftfreq

# Shift the zero-frequency component to the center of the spectrum.
scipy.fftpack.helper.fftshift

# The inverse of `fftshift`. Although identical for even-length `x`, the
scipy.fftpack.helper.ifftshift

# Find the next fast size of input data to `fft`, for zero-padding, etc.
scipy.fftpack.helper.next_fast_len

# DFT sample frequencies (for usage with rfft, irfft).
scipy.fftpack.helper.rfftfreq

# Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence.
scipy.fftpack.pseudo_diffs.cc_diff

scipy.fftpack.pseudo_diffs.convolve

# Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence.
scipy.fftpack.pseudo_diffs.cs_diff

# Return kth derivative (or integral) of a periodic sequence x.
scipy.fftpack.pseudo_diffs.diff

# Return Hilbert transform of a periodic sequence x.
scipy.fftpack.pseudo_diffs.hilbert

# Return inverse Hilbert transform of a periodic sequence x.
scipy.fftpack.pseudo_diffs.ihilbert

# Return inverse h-Tilbert transform of a periodic sequence x.
scipy.fftpack.pseudo_diffs.itilbert

# Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.
scipy.fftpack.pseudo_diffs.sc_diff

# Shift periodic sequence x by a: y(u) = x(u+a).
scipy.fftpack.pseudo_diffs.shift

# Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.
scipy.fftpack.pseudo_diffs.ss_diff

# Return h-Tilbert transform of a periodic sequence x.
scipy.fftpack.pseudo_diffs.tilbert

# Return the Discrete Cosine Transform of arbitrary type sequence x.
scipy.fftpack.realtransforms.dct

# Return multidimensional Discrete Cosine Transform along the specified axes.
scipy.fftpack.realtransforms.dctn

# Return the Discrete Sine Transform of arbitrary type sequence x.
scipy.fftpack.realtransforms.dst

# Return multidimensional Discrete Sine Transform along the specified axes.
scipy.fftpack.realtransforms.dstn

# Return the Inverse Discrete Cosine Transform of an arbitrary type sequence.
scipy.fftpack.realtransforms.idct

# Return multidimensional Discrete Cosine Transform along the specified axes.
scipy.fftpack.realtransforms.idctn

# Return the Inverse Discrete Sine Transform of an arbitrary type sequence.
scipy.fftpack.realtransforms.idst

# Return multidimensional Discrete Sine Transform along the specified axes.
scipy.fftpack.realtransforms.idstn

scipy.integrate._bvp.BVPResult

# Double-precision floating-point number type, compatible with Python
scipy.integrate._bvp.EPS

# Represents the optimization result.
scipy.integrate._bvp.OptimizeResult

# dict() -> new empty dictionary
scipy.integrate._bvp.TERMINATION_MESSAGES

# Evaluate collocation residuals.
scipy.integrate._bvp.collocation_fun

# Compute indices for the collocation system Jacobian construction.
scipy.integrate._bvp.compute_jac_indices

# Construct the Jacobian of the collocation system.
scipy.integrate._bvp.construct_global_jac

# A sparse matrix in COOrdinate format.
scipy.integrate._bvp.coo_matrix

# Create a cubic spline given values and derivatives.
scipy.integrate._bvp.create_spline

# Compressed Sparse Column matrix.
scipy.integrate._bvp.csc_matrix

# Estimate derivatives of boundary conditions with forward differences.
scipy.integrate._bvp.estimate_bc_jac

# Estimate derivatives of an ODE system rhs with forward differences.
scipy.integrate._bvp.estimate_fun_jac

# Estimate rms values of collocation residuals using Lobatto quadrature.
scipy.integrate._bvp.estimate_rms_residuals

# Insert nodes into a mesh.
scipy.integrate._bvp.modify_mesh

# NumPy
scipy.integrate._bvp.np

# Compute the (Moore-Penrose) pseudo-inverse of a matrix.
scipy.integrate._bvp.pinv

# Create the function and the Jacobian for the collocation system.
scipy.integrate._bvp.prepare_sys

scipy.integrate._bvp.print_iteration_header

scipy.integrate._bvp.print_iteration_progress

# Solve a boundary value problem for a system of ODEs.
scipy.integrate._bvp.solve_bvp

# Solve the nonlinear collocation system by a Newton method.
scipy.integrate._bvp.solve_newton

# Compute the LU decomposition of a sparse, square matrix.
scipy.integrate._bvp.splu

# Stacked matrix multiply: out[i,:,:] = np.dot(a[i,:,:], b[i,:,:]).
scipy.integrate._bvp.stacked_matmul

# Issue a warning, or maybe ignore it or raise an exception.
scipy.integrate._bvp.warn

# Wrap functions for unified usage in the solver.
scipy.integrate._bvp.wrap_functions

# Adaptive cubature of multidimensional array-valued function.
scipy.integrate._cubature.cubature

# x,y,iwork,idid = dop853(fcn,x,y,xend,rtol,atol,solout,iout,work,iwork,[fcn_extra_args,overwrite_y,solout_extra_args])
scipy.integrate._dop.dop853

# x,y,iwork,idid = dopri5(fcn,x,y,xend,rtol,atol,solout,iout,work,iwork,[fcn_extra_args,overwrite_y,solout_extra_args])
scipy.integrate._dop.dopri5

# intvar : 'i'-scalar
scipy.integrate._dop.types

# Constant value interpolator.
scipy.integrate._ivp.base.ConstantDenseOutput

# Base class for local interpolant over step made by an ODE solver.
scipy.integrate._ivp.base.DenseOutput

# Base class for ODE solvers.
scipy.integrate._ivp.base.OdeSolver

# Helper function for checking arguments common to all solvers.
scipy.integrate._ivp.base.check_arguments

# NumPy
scipy.integrate._ivp.base.np

# Implicit method based on backward-differentiation formulas.
scipy.integrate._ivp.bdf.BDF

scipy.integrate._ivp.bdf.BdfDenseOutput

# Base class for local interpolant over step made by an ODE solver.
scipy.integrate._ivp.bdf.DenseOutput

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.bdf.EPS

# int([x]) -> integer
scipy.integrate._ivp.bdf.MAX_FACTOR

# int([x]) -> integer
scipy.integrate._ivp.bdf.MAX_ORDER

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.bdf.MIN_FACTOR

# int([x]) -> integer
scipy.integrate._ivp.bdf.NEWTON_MAXITER

# Base class for ODE solvers.
scipy.integrate._ivp.bdf.OdeSolver

# Change differences array in-place when step size is changed.
scipy.integrate._ivp.bdf.change_D

# Compute the matrix for changing the differences array.
scipy.integrate._ivp.bdf.compute_R

# Compressed Sparse Column matrix.
scipy.integrate._ivp.bdf.csc_matrix

# Sparse matrix of chosen shape with ones on the kth diagonal and zeros elsewhere.
scipy.integrate._ivp.bdf.eye

# Group columns of a 2-D matrix for sparse finite differencing [1]_.
scipy.integrate._ivp.bdf.group_columns

# Is `x` of a sparse array or sparse matrix type?
scipy.integrate._ivp.bdf.issparse

# Compute pivoted LU decomposition of a matrix.
scipy.integrate._ivp.bdf.lu_factor

# Solve an equation system, a x = b, given the LU factorization of a
scipy.integrate._ivp.bdf.lu_solve

# Compute RMS norm.
scipy.integrate._ivp.bdf.norm

# NumPy
scipy.integrate._ivp.bdf.np

# Finite differences Jacobian approximation tailored for ODE solvers.
scipy.integrate._ivp.bdf.num_jac

# Empirically select a good initial step.
scipy.integrate._ivp.bdf.select_initial_step

# Solve the algebraic system resulting from BDF method.
scipy.integrate._ivp.bdf.solve_bdf_system

# Compute the LU decomposition of a sparse, square matrix.
scipy.integrate._ivp.bdf.splu

# Assert that first_step is valid and return it.
scipy.integrate._ivp.bdf.validate_first_step

# Assert that max_Step is valid and return it.
scipy.integrate._ivp.bdf.validate_max_step

# Validate tolerance values.
scipy.integrate._ivp.bdf.validate_tol

# Display a warning for extraneous keyword arguments.
scipy.integrate._ivp.bdf.warn_extraneous

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.common.EPS

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.common.NUM_JAC_DIFF_BIG

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.common.NUM_JAC_DIFF_REJECT

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.common.NUM_JAC_DIFF_SMALL

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.common.NUM_JAC_FACTOR_DECREASE

# int([x]) -> integer
scipy.integrate._ivp.common.NUM_JAC_FACTOR_INCREASE

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.common.NUM_JAC_MIN_FACTOR

# Continuous ODE solution.
scipy.integrate._ivp.common.OdeSolution

# A sparse matrix in COOrdinate format.
scipy.integrate._ivp.common.coo_matrix

# Return the indices and values of the nonzero elements of a matrix
scipy.integrate._ivp.common.find

# make an iterator that returns consecutive keys and groups from the iterable
scipy.integrate._ivp.common.groupby

# Compute RMS norm.
scipy.integrate._ivp.common.norm

# NumPy
scipy.integrate._ivp.common.np

# Finite differences Jacobian approximation tailored for ODE solvers.
scipy.integrate._ivp.common.num_jac

# Empirically select a good initial step.
scipy.integrate._ivp.common.select_initial_step

# Assert that first_step is valid and return it.
scipy.integrate._ivp.common.validate_first_step

# Assert that max_Step is valid and return it.
scipy.integrate._ivp.common.validate_max_step

# Validate tolerance values.
scipy.integrate._ivp.common.validate_tol

# Issue a warning, or maybe ignore it or raise an exception.
scipy.integrate._ivp.common.warn

# Display a warning for extraneous keyword arguments.
scipy.integrate._ivp.common.warn_extraneous

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.dop853_coefficients.A

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.dop853_coefficients.B

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.dop853_coefficients.C

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.dop853_coefficients.D

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.dop853_coefficients.E3

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.dop853_coefficients.E5

# int([x]) -> integer
scipy.integrate._ivp.dop853_coefficients.INTERPOLATOR_POWER

# int([x]) -> integer
scipy.integrate._ivp.dop853_coefficients.N_STAGES

# int([x]) -> integer
scipy.integrate._ivp.dop853_coefficients.N_STAGES_EXTENDED

# NumPy
scipy.integrate._ivp.dop853_coefficients.np

# Implicit method based on backward-differentiation formulas.
scipy.integrate._ivp.ivp.BDF

# Explicit Runge-Kutta method of order 8.
scipy.integrate._ivp.ivp.DOP853

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.ivp.EPS

# Adams/BDF method with automatic stiffness detection and switching.
scipy.integrate._ivp.ivp.LSODA

# dict() -> new empty dictionary
scipy.integrate._ivp.ivp.MESSAGES

# dict() -> new empty dictionary
scipy.integrate._ivp.ivp.METHODS

scipy.integrate._ivp.ivp.OdeResult

# Continuous ODE solution.
scipy.integrate._ivp.ivp.OdeSolution

# Base class for ODE solvers.
scipy.integrate._ivp.ivp.OdeSolver

# Represents the optimization result.
scipy.integrate._ivp.ivp.OptimizeResult

# Explicit Runge-Kutta method of order 3(2).
scipy.integrate._ivp.ivp.RK23

# Explicit Runge-Kutta method of order 5(4).
scipy.integrate._ivp.ivp.RK45

# Implicit Runge-Kutta method of Radau IIA family of order 5.
scipy.integrate._ivp.ivp.Radau

# Find which event occurred during an integration step.
scipy.integrate._ivp.ivp.find_active_events

# Helper function to handle events.
scipy.integrate._ivp.ivp.handle_events

# Get useful information from live Python objects.
scipy.integrate._ivp.ivp.inspect

# NumPy
scipy.integrate._ivp.ivp.np

# Standardize event functions and extract attributes.
scipy.integrate._ivp.ivp.prepare_events

# Solve an equation corresponding to an ODE event.
scipy.integrate._ivp.ivp.solve_event_equation

# Solve an initial value problem for a system of ODEs.
scipy.integrate._ivp.ivp.solve_ivp

# Base class for local interpolant over step made by an ODE solver.
scipy.integrate._ivp.lsoda.DenseOutput

# Adams/BDF method with automatic stiffness detection and switching.
scipy.integrate._ivp.lsoda.LSODA

scipy.integrate._ivp.lsoda.LsodaDenseOutput

# Base class for ODE solvers.
scipy.integrate._ivp.lsoda.OdeSolver

# NumPy
scipy.integrate._ivp.lsoda.np

# A generic interface class to numeric integrators.
scipy.integrate._ivp.lsoda.ode

# Assert that first_step is valid and return it.
scipy.integrate._ivp.lsoda.validate_first_step

# Validate tolerance values.
scipy.integrate._ivp.lsoda.validate_tol

# Display a warning for extraneous keyword arguments.
scipy.integrate._ivp.lsoda.warn_extraneous

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.C

# Base class for local interpolant over step made by an ODE solver.
scipy.integrate._ivp.radau.DenseOutput

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.E

# Double-precision floating-point number type, compatible with Python
scipy.integrate._ivp.radau.EPS

# int([x]) -> integer
scipy.integrate._ivp.radau.MAX_FACTOR

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.radau.MIN_FACTOR

# Create a complex number from a string or numbers.
scipy.integrate._ivp.radau.MU_COMPLEX

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.radau.MU_REAL

# int([x]) -> integer
scipy.integrate._ivp.radau.NEWTON_MAXITER

# Base class for ODE solvers.
scipy.integrate._ivp.radau.OdeSolver

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.P

# Implicit Runge-Kutta method of Radau IIA family of order 5.
scipy.integrate._ivp.radau.Radau

scipy.integrate._ivp.radau.RadauDenseOutput

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.radau.S6

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.T

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.TI

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.TI_COMPLEX

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.integrate._ivp.radau.TI_REAL

# Compressed Sparse Column matrix.
scipy.integrate._ivp.radau.csc_matrix

# Sparse matrix of chosen shape with ones on the kth diagonal and zeros elsewhere.
scipy.integrate._ivp.radau.eye

# Group columns of a 2-D matrix for sparse finite differencing [1]_.
scipy.integrate._ivp.radau.group_columns

# Is `x` of a sparse array or sparse matrix type?
scipy.integrate._ivp.radau.issparse

# Compute pivoted LU decomposition of a matrix.
scipy.integrate._ivp.radau.lu_factor

# Solve an equation system, a x = b, given the LU factorization of a
scipy.integrate._ivp.radau.lu_solve

# Compute RMS norm.
scipy.integrate._ivp.radau.norm

# NumPy
scipy.integrate._ivp.radau.np

# Finite differences Jacobian approximation tailored for ODE solvers.
scipy.integrate._ivp.radau.num_jac

# Predict by which factor to increase/decrease the step size.
scipy.integrate._ivp.radau.predict_factor

# Empirically select a good initial step.
scipy.integrate._ivp.radau.select_initial_step

# Solve the collocation system.
scipy.integrate._ivp.radau.solve_collocation_system

# Compute the LU decomposition of a sparse, square matrix.
scipy.integrate._ivp.radau.splu

# Assert that first_step is valid and return it.
scipy.integrate._ivp.radau.validate_first_step

# Assert that max_Step is valid and return it.
scipy.integrate._ivp.radau.validate_max_step

# Validate tolerance values.
scipy.integrate._ivp.radau.validate_tol

# Display a warning for extraneous keyword arguments.
scipy.integrate._ivp.radau.warn_extraneous

# Explicit Runge-Kutta method of order 8.
scipy.integrate._ivp.rk.DOP853

# Base class for local interpolant over step made by an ODE solver.
scipy.integrate._ivp.rk.DenseOutput

scipy.integrate._ivp.rk.Dop853DenseOutput

# int([x]) -> integer
scipy.integrate._ivp.rk.MAX_FACTOR

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.rk.MIN_FACTOR

# Base class for ODE solvers.
scipy.integrate._ivp.rk.OdeSolver

# Explicit Runge-Kutta method of order 3(2).
scipy.integrate._ivp.rk.RK23

# Explicit Runge-Kutta method of order 5(4).
scipy.integrate._ivp.rk.RK45

scipy.integrate._ivp.rk.RkDenseOutput

# Base class for explicit Runge-Kutta methods.
scipy.integrate._ivp.rk.RungeKutta

# Convert a string or number to a floating-point number, if possible.
scipy.integrate._ivp.rk.SAFETY

scipy.integrate._ivp.rk.dop853_coefficients

# Compute RMS norm.
scipy.integrate._ivp.rk.norm

# NumPy
scipy.integrate._ivp.rk.np

# Perform a single Runge-Kutta step.
scipy.integrate._ivp.rk.rk_step

# Empirically select a good initial step.
scipy.integrate._ivp.rk.select_initial_step

# Assert that first_step is valid and return it.
scipy.integrate._ivp.rk.validate_first_step

# Assert that max_Step is valid and return it.
scipy.integrate._ivp.rk.validate_max_step

# Validate tolerance values.
scipy.integrate._ivp.rk.validate_tol

# Display a warning for extraneous keyword arguments.
scipy.integrate._ivp.rk.warn_extraneous

# Lebedev quadrature.
scipy.integrate._lebedev.lebedev_rule

# y,t,istate = lsoda(f,y,t,tout,rtol,atol,itask,istate,rwork,iwork,jac,jt,[f_extra_args,overwrite_y,jac_extra_args])
scipy.integrate._lsoda.lsoda

# intvar : 'i'-scalar
scipy.integrate._lsoda.types

# A wrapper of ode for complex systems.
scipy.integrate._ode.complex_ode

# A generic interface class to numeric integrators.
scipy.integrate._ode.ode

scipy.integrate._odepack.error

# [y,{infodict,}istate] = odeint(fun, y0, t, args=(), Dfun=None, col_deriv=0, ml=, mu=, full_output=0, rtol=, atol=, tcrit=, h0=0.0, hmax=0.0, hmin=0.0, ixpr=0.0, mxstep=0.0, mxhnil=0, mxordn=0, mxords=0)
scipy.integrate._odepack.odeint

# Warning raised during the execution of `odeint`.
scipy.integrate._odepack_py.ODEintWarning

# Integrate a system of ordinary differential equations.
scipy.integrate._odepack_py.odeint

# Argument transform from (-oo, oo) to (-1, 1)
scipy.integrate._quad_vec.DoubleInfiniteFunc

scipy.integrate._quad_vec.LRUDict

# Parallelisation wrapper for working with map-like callables, such as
scipy.integrate._quad_vec.MapWrapper

# Argument transform from (start, +-oo) to (0, 1)
scipy.integrate._quad_vec.SemiInfiniteFunc

# This module implements specialized container datatypes providing
scipy.integrate._quad_vec.collections

# Generic (shallow and deep) copying operations.
scipy.integrate._quad_vec.copy

# functools.py - Tools for working with functions and callable objects
scipy.integrate._quad_vec.functools

# Heap queue algorithm (a.k.a. priority queue).
scipy.integrate._quad_vec.heapq

# NumPy
scipy.integrate._quad_vec.np

# Adaptive integration of a vector-valued function.
scipy.integrate._quad_vec.quad_vec

# This module provides access to some objects used or maintained by the
scipy.integrate._quad_vec.sys

scipy.integrate._quadpack.error

# Warning on issues during integration.
scipy.integrate._quadpack_py.IntegrationWarning

# Compute a double integral.
scipy.integrate._quadpack_py.dblquad

# Integration over multiple variables.
scipy.integrate._quadpack_py.nquad

# Compute a definite integral.
scipy.integrate._quadpack_py.quad

# Compute a triple (definite) integral.
scipy.integrate._quadpack_py.tplquad

# Cumulatively integrate y(x) using the composite Simpson's 1/3 rule.
scipy.integrate._quadrature.cumulative_simpson

# Cumulatively integrate y(x) using the composite trapezoidal rule.
scipy.integrate._quadrature.cumulative_trapezoid

# Compute a definite integral using fixed-order Gaussian quadrature.
scipy.integrate._quadrature.fixed_quad

# Return weights and error coefficient for Newton-Cotes integration.
scipy.integrate._quadrature.newton_cotes

# Compute an integral in N-dimensions using Quasi-Monte Carlo quadrature.
scipy.integrate._quadrature.qmc_quad

# Romberg integration using samples of a function.
scipy.integrate._quadrature.romb

# Integrate y(x) using samples along the given axis and the composite
scipy.integrate._quadrature.simpson

# Integrate along the given axis using the composite trapezoidal rule.
scipy.integrate._quadrature.trapezoid

# A rule implemented as the weighted sum of function evaluations at fixed nodes.
scipy.integrate._rules._base.FixedRule

# A cubature rule with error estimate given by the difference between two underlying
scipy.integrate._rules._base.NestedFixedRule

# Find the n-dimensional cubature rule constructed from the Cartesian product of 1-D
scipy.integrate._rules._base.ProductNestedFixed

# Base class for numerical integration algorithms (cubatures).
scipy.integrate._rules._base.Rule

# Get the array API compatible namespace for the arrays xs.
scipy.integrate._rules._base.array_namespace

scipy.integrate._rules._base.cached_property

# Return the total number of elements of x.
scipy.integrate._rules._base.xp_size

# Gauss-Kronrod quadrature.
scipy.integrate._rules._gauss_kronrod.GaussKronrodQuadrature

# Gauss-Legendre quadrature.
scipy.integrate._rules._gauss_kronrod.GaussLegendreQuadrature

# A cubature rule with error estimate given by the difference between two underlying
scipy.integrate._rules._gauss_kronrod.NestedFixedRule

# Get the array API compatible namespace for the arrays xs.
scipy.integrate._rules._gauss_kronrod.array_namespace

scipy.integrate._rules._gauss_kronrod.cached_property

scipy.integrate._rules._gauss_kronrod.np_compat

# A rule implemented as the weighted sum of function evaluations at fixed nodes.
scipy.integrate._rules._gauss_legendre.FixedRule

# Gauss-Legendre quadrature.
scipy.integrate._rules._gauss_legendre.GaussLegendreQuadrature

# Get the array API compatible namespace for the arrays xs.
scipy.integrate._rules._gauss_legendre.array_namespace

scipy.integrate._rules._gauss_legendre.cached_property

scipy.integrate._rules._gauss_legendre.np_compat

# Gauss-Legendre quadrature.
scipy.integrate._rules._gauss_legendre.roots_legendre

# Genz-Malik cubature.
scipy.integrate._rules._genz_malik.GenzMalikCubature

# A cubature rule with error estimate given by the difference between two underlying
scipy.integrate._rules._genz_malik.NestedFixedRule

# Get the array API compatible namespace for the arrays xs.
scipy.integrate._rules._genz_malik.array_namespace

scipy.integrate._rules._genz_malik.cached_property

# Functional tools for creating and using iterators.
scipy.integrate._rules._genz_malik.itertools

# This module provides access to the mathematical functions
scipy.integrate._rules._genz_malik.math

scipy.integrate._rules._genz_malik.np_compat

# Evaluate a convergent finite or infinite series.
scipy.integrate._tanhsinh.nsum

# banded5x5(t,y,f,[n])
scipy.integrate._test_odeint_banded.banded5x5

# banded5x5_bjac(t,y,ml,mu,bjac,[n,nrowpd])
scipy.integrate._test_odeint_banded.banded5x5_bjac

# banded5x5_jac(t,y,ml,mu,jac,[n,nrowpd])
scipy.integrate._test_odeint_banded.banded5x5_jac

# nst,nfe,nje = banded5x5_solve(y,nsteps,dt,jt)
scipy.integrate._test_odeint_banded.banded5x5_solve

# jac = getbands()
scipy.integrate._test_odeint_banded.getbands

# bands : 'd'-array(4,5)
scipy.integrate._test_odeint_banded.jac

# y,t,istate = dvode(f,jac,y,t,tout,rtol,atol,itask,istate,rwork,iwork,mf,[f_extra_args,jac_extra_args,overwrite_y])
scipy.integrate._vode.dvode

# intvar : 'i'-scalar
scipy.integrate._vode.types

# y,t,istate = zvode(f,jac,y,t,tout,rtol,atol,itask,istate,zwork,rwork,iwork,mf,[f_extra_args,jac_extra_args,overwrite_y])
scipy.integrate._vode.zvode

# y,t,istate = lsoda(f,y,t,tout,rtol,atol,itask,istate,rwork,iwork,jac,jt,[f_extra_args,overwrite_y,jac_extra_args])
scipy.integrate.lsoda.lsoda

# Warning raised during the execution of `odeint`.
scipy.integrate.odepack.ODEintWarning

# Integrate a system of ordinary differential equations.
scipy.integrate.odepack.odeint

# Warning on issues during integration.
scipy.integrate.quadpack.IntegrationWarning

# Compute a double integral.
scipy.integrate.quadpack.dblquad

# Integration over multiple variables.
scipy.integrate.quadpack.nquad

# Compute a definite integral.
scipy.integrate.quadpack.quad

# Compute a triple (definite) integral.
scipy.integrate.quadpack.tplquad

# AAA real or complex rational approximation.
scipy.interpolate._bary_rational.AAA

# Floater-Hormann barycentric rational interpolator (C∞ smooth on real axis).
scipy.interpolate._bary_rational.FloaterHormannInterpolator

# Univariate spline in the B-spline basis.
scipy.interpolate._bsplines.BSpline

# Create an interpolating B-spline with specified degree and boundary conditions.
scipy.interpolate._bsplines.make_interp_spline

# Create a smoothing B-spline satisfying the Least SQuares (LSQ) criterion.
scipy.interpolate._bsplines.make_lsq_spline

# Create a smoothing B-spline satisfying the Generalized Cross Validation (GCV) criterion.
scipy.interpolate._bsplines.make_smoothing_spline

# Akima "visually pleasing" interpolator (C1 smooth).
scipy.interpolate._cubic.Akima1DInterpolator

# Piecewise cubic interpolator to fit values and first derivatives (C1 smooth).
scipy.interpolate._cubic.CubicHermiteSpline

# Piecewise cubic interpolator to fit values (C2 smooth).
scipy.interpolate._cubic.CubicSpline

# PCHIP shape-preserving interpolator (C1 smooth).
scipy.interpolate._cubic.PchipInterpolator

# Convenience function for pchip interpolation.
scipy.interpolate._cubic.pchip_interpolate

# z,ier = bispeu(tx,ty,c,kx,ky,x,y)
scipy.interpolate._dfitpack.bispeu

# z,ier = bispev(tx,ty,c,kx,ky,x,y)
scipy.interpolate._dfitpack.bispev

# n,c,fp,ier = curfit(iopt,x,y,w,t,wrk,iwrk,[xb,xe,k,s])
scipy.interpolate._dfitpack.curfit

# dblint = dblint(tx,ty,c,kx,ky,xb,xe,yb,ye)
scipy.interpolate._dfitpack.dblint

# ier = fpchec(x,t,k)
scipy.interpolate._dfitpack.fpchec

# x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier = fpcurf0(x,y,k,[w,xb,xe,s,nest])
scipy.interpolate._dfitpack.fpcurf0

# x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier = fpcurf1(x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier,[overwrite_x,overwrite_y,overwrite_w,overwrite_t,overwrite_c,overwrite_fpint,overwrite_nrdata])
scipy.interpolate._dfitpack.fpcurf1

# x,y,w,xb,xe,k,s,n,t,c,fp,fpint,nrdata,ier = fpcurfm1(x,y,k,t,[w,xb,xe,overwrite_t])
scipy.interpolate._dfitpack.fpcurfm1

# n,c,fp,ier = parcur(iopt,ipar,idim,u,x,w,ub,ue,t,wrk,iwrk,[k,s])
scipy.interpolate._dfitpack.parcur

# z,ier = parder(tx,ty,c,kx,ky,nux,nuy,x,y)
scipy.interpolate._dfitpack.parder

# z,ier = pardeu(tx,ty,c,kx,ky,nux,nuy,x,y)
scipy.interpolate._dfitpack.pardeu

# newc,ier = pardtc(tx,ty,c,kx,ky,nux,nuy)
scipy.interpolate._dfitpack.pardtc

# n,c,fp,ier = percur(iopt,x,y,w,t,wrk,iwrk,[k,s])
scipy.interpolate._dfitpack.percur

# nx,tx,ny,ty,c,fp,ier = regrid_smth(x,y,z,[xb,xe,yb,ye,kx,ky,s,maxit])
scipy.interpolate._dfitpack.regrid_smth

# nu,tu,nv,tv,c,fp,ier = regrid_smth_spher(iopt,ider,u,v,r,[r0,r1,s])
scipy.interpolate._dfitpack.regrid_smth_spher

# d,ier = spalde(t,c,k1,x)
scipy.interpolate._dfitpack.spalde

# tt,tp,c,fp,ier = spherfit_lsq(teta,phi,r,tt,tp,[w,eps,overwrite_tt,overwrite_tp])
scipy.interpolate._dfitpack.spherfit_lsq

# nt,tt,np,tp,c,fp,ier = spherfit_smth(teta,phi,r,[w,s,eps])
scipy.interpolate._dfitpack.spherfit_smth

# y,ier = splder(t,c,k,x,[nu,e])
scipy.interpolate._dfitpack.splder

# y,ier = splev(t,c,k,x,[e])
scipy.interpolate._dfitpack.splev

# splint,wrk = splint(t,c,k,a,b)
scipy.interpolate._dfitpack.splint

# zero,m,ier = sproot(t,c,[mest])
scipy.interpolate._dfitpack.sproot

# tx,ty,c,fp,ier = surfit_lsq(x,y,z,nx,tx,ny,ty,[w,xb,xe,yb,ye,kx,ky,eps,lwrk2,overwrite_tx,overwrite_ty])
scipy.interpolate._dfitpack.surfit_lsq

# nx,tx,ny,ty,c,fp,wrk1,ier = surfit_smth(x,y,z,[w,xb,xe,yb,ye,kx,ky,s,nxest,nyest,eps,lwrk2])
scipy.interpolate._dfitpack.surfit_smth

# intvar : 'i'-scalar
scipy.interpolate._dfitpack.types

# (m, k+1) array of non-zero b-splines
scipy.interpolate._dierckx.data_matrix

# Evaluate the ``k+1`` B-splines which are non-zero on interval ``m``. 
scipy.interpolate._dierckx.evaluate_all_bspl

# Evaluate an N-dim tensor product spline or its derivative.
scipy.interpolate._dierckx.evaluate_ndbspline

# Evaluate a spline in the B-spline basis. 
scipy.interpolate._dierckx.evaluate_spline

# Find an interval such that t[interval] <= xval < t[interval+1]. 
scipy.interpolate._dierckx.find_interval

# backsubstitution, triangular matrix
scipy.interpolate._dierckx.fpback

# fpknot replacement
scipy.interpolate._dierckx.fpknot

# row-by-row QR triangularization
scipy.interpolate._dierckx.qr_reduce

scipy.interpolate._fitpack.error

# Base class for bivariate splines.
scipy.interpolate._fitpack2.BivariateSpline

# 1-D interpolating spline for a given set of data points.
scipy.interpolate._fitpack2.InterpolatedUnivariateSpline

# Weighted least-squares bivariate spline approximation.
scipy.interpolate._fitpack2.LSQBivariateSpline

# Weighted least-squares bivariate spline approximation in spherical
scipy.interpolate._fitpack2.LSQSphereBivariateSpline

# 1-D spline with explicit internal knots.
scipy.interpolate._fitpack2.LSQUnivariateSpline

# Bivariate spline approximation over a rectangular mesh.
scipy.interpolate._fitpack2.RectBivariateSpline

# Bivariate spline approximation over a rectangular mesh on a sphere.
scipy.interpolate._fitpack2.RectSphereBivariateSpline

# Smooth bivariate spline approximation.
scipy.interpolate._fitpack2.SmoothBivariateSpline

# Smooth bivariate spline approximation in spherical coordinates.
scipy.interpolate._fitpack2.SmoothSphereBivariateSpline

# 1-D smoothing spline fit to a given set of data points.
scipy.interpolate._fitpack2.UnivariateSpline

# Evaluate a bivariate B-spline and its derivatives.
scipy.interpolate._fitpack_impl.bisplev

# Find a bivariate B-spline representation of a surface.
scipy.interpolate._fitpack_impl.bisplrep

scipy.interpolate._fitpack_impl.insert

scipy.interpolate._fitpack_impl.spalde

scipy.interpolate._fitpack_impl.splantider

scipy.interpolate._fitpack_impl.splder

scipy.interpolate._fitpack_impl.splev

scipy.interpolate._fitpack_impl.splint

scipy.interpolate._fitpack_impl.splprep

scipy.interpolate._fitpack_impl.splrep

scipy.interpolate._fitpack_impl.sproot

# Evaluate a bivariate B-spline and its derivatives.
scipy.interpolate._fitpack_py.bisplev

# Find a bivariate B-spline representation of a surface.
scipy.interpolate._fitpack_py.bisplrep

# Insert knots into a B-spline.
scipy.interpolate._fitpack_py.insert

# Evaluate a B-spline and all its derivatives at one point (or set of points) up
scipy.interpolate._fitpack_py.spalde

# Compute the spline for the antiderivative (integral) of a given spline.
scipy.interpolate._fitpack_py.splantider

# Compute the spline representation of the derivative of a given spline
scipy.interpolate._fitpack_py.splder

# Evaluate a B-spline or its derivatives.
scipy.interpolate._fitpack_py.splev

# Evaluate the definite integral of a B-spline between two given points.
scipy.interpolate._fitpack_py.splint

# Find the B-spline representation of an N-D curve.
scipy.interpolate._fitpack_py.splprep

# Find the B-spline representation of a 1-D curve.
scipy.interpolate._fitpack_py.splrep

# Find the roots of a cubic B-spline.
scipy.interpolate._fitpack_py.sproot

# Univariate spline in the B-spline basis.
scipy.interpolate._fitpack_repro.BSpline

scipy.interpolate._fitpack_repro.Bunch

# The r.h.s. of ``f(p) = s``.
scipy.interpolate._fitpack_repro.F

# int([x]) -> integer
scipy.interpolate._fitpack_repro.MAXIT

# Convert a string or number to a floating-point number, if possible.
scipy.interpolate._fitpack_repro.TOL

# Add a new knot.
scipy.interpolate._fitpack_repro.add_knot

# Discontinuity matrix: jumps of k-th derivatives of b-splines at internal knots.
scipy.interpolate._fitpack_repro.disc

# Check consistency of the data vector `x` and the knot vector `t`.
scipy.interpolate._fitpack_repro.fpcheck

# The root of r(p) = (u*p + v) / (p + w) given three points and values,
scipy.interpolate._fitpack_repro.fprati

# Generate knot vectors until the Least SQuares (LSQ) criterion is satified.
scipy.interpolate._fitpack_repro.generate_knots

# Create an interpolating B-spline with specified degree and boundary conditions.
scipy.interpolate._fitpack_repro.make_interp_spline

# Create a smoothing parametric B-spline curve with bounded error, minimizing derivative jumps.
scipy.interpolate._fitpack_repro.make_splprep

# Create a smoothing B-spline function with bounded error, minimizing derivative jumps.
scipy.interpolate._fitpack_repro.make_splrep

# NumPy
scipy.interpolate._fitpack_repro.np

# Operator interface.
scipy.interpolate._fitpack_repro.operator

scipy.interpolate._fitpack_repro.prodd

# Solve `f(p) = 0` using a rational function approximation.
scipy.interpolate._fitpack_repro.root_rati

# Python part of the warnings subsystem.
scipy.interpolate._fitpack_repro.warnings

# Piecewise cubic, C1 smooth, curvature-minimizing interpolator in N=2 dimensions.
scipy.interpolate._interpnd.CloughTocher2DInterpolator

scipy.interpolate._interpnd.GradientEstimationWarning

# LinearNDInterpolator(points, values, fill_value=np.nan, rescale=False)
scipy.interpolate._interpnd.LinearNDInterpolator

# Common routines for interpolators.
scipy.interpolate._interpnd.NDInterpolatorBase

scipy.interpolate._interpnd.estimate_gradients_2d_global

# NumPy
scipy.interpolate._interpnd.np

# Wrappers for Qhull triangulation, plus some additional N-D geometry utilities
scipy.interpolate._interpnd.qhull

# Python part of the warnings subsystem.
scipy.interpolate._interpnd.warnings

# Piecewise polynomial in the Bernstein basis.
scipy.interpolate._interpolate.BPoly

# Piecewise tensor product polynomial
scipy.interpolate._interpolate.NdPPoly

# Piecewise polynomial in the power basis.
scipy.interpolate._interpolate.PPoly

# Interpolate a 1-D function (legacy).
scipy.interpolate._interpolate.interp1d

# interp2d(x, y, z, kind='linear', copy=True, bounds_error=False,
scipy.interpolate._interpolate.interp2d

# Return a Lagrange interpolating polynomial.
scipy.interpolate._interpolate.lagrange

# Tensor product spline object.
scipy.interpolate._ndbspline.NdBSpline

# Piecewise cubic, C1 smooth, curvature-minimizing interpolator in N=2 dimensions.
scipy.interpolate._ndgriddata.CloughTocher2DInterpolator

# LinearNDInterpolator(points, values, fill_value=np.nan, rescale=False)
scipy.interpolate._ndgriddata.LinearNDInterpolator

# Nearest-neighbor interpolator in N > 1 dimensions.
scipy.interpolate._ndgriddata.NearestNDInterpolator

# Convenience function for interpolating unstructured data in multiple dimensions.
scipy.interpolate._ndgriddata.griddata

# Return Pade approximation to a polynomial as the ratio of two polynomials.
scipy.interpolate._pade.pade

# Barycentric (Lagrange with improved stability) interpolator (C∞ smooth).
scipy.interpolate._polyint.BarycentricInterpolator

# Krogh interpolator (C∞ smooth).
scipy.interpolate._polyint.KroghInterpolator

# Estimate the Taylor polynomial of f at x by polynomial fitting.
scipy.interpolate._polyint.approximate_taylor_polynomial

# Convenience function for barycentric interpolation.
scipy.interpolate._polyint.barycentric_interpolate

# Convenience function for Krogh interpolation.
scipy.interpolate._polyint.krogh_interpolate

# Evaluate a piecewise polynomial.
scipy.interpolate._ppoly.evaluate

# Evaluate a piecewise polynomial in the Bernstein basis.
scipy.interpolate._ppoly.evaluate_bernstein

# Evaluate a piecewise tensor-product polynomial.
scipy.interpolate._ppoly.evaluate_nd

# Make a piecewise polynomial continuously differentiable to given order.
scipy.interpolate._ppoly.fix_continuity

# Compute integral over a piecewise polynomial.
scipy.interpolate._ppoly.integrate

# NumPy
scipy.interpolate._ppoly.np

# Compute real roots of a real-valued piecewise polynomial function.
scipy.interpolate._ppoly.real_roots

# Rbf(*args, **kwargs)
scipy.interpolate._rbf.Rbf

# Radial basis function interpolator in N ≥ 1 dimensions.
scipy.interpolate._rbfinterp.RBFInterpolator

# Interpolator of specified order on a rectilinear grid in N ≥ 1 dimensions.
scipy.interpolate._rgi.RegularGridInterpolator

# Multidimensional interpolation on regular or rectilinear grids.
scipy.interpolate._rgi.interpn

scipy.interpolate._rgi_cython.evaluate_linear_2d

scipy.interpolate._rgi_cython.find_indices

# NumPy
scipy.interpolate._rgi_cython.np

# d,ier = spalde(t,c,k1,x)
scipy.interpolate.dfitpack.spalde

# y,ier = splder(t,c,k,x,[nu,e])
scipy.interpolate.dfitpack.splder

# y,ier = splev(t,c,k,x,[e])
scipy.interpolate.dfitpack.splev

# splint,wrk = splint(t,c,k,a,b)
scipy.interpolate.dfitpack.splint

# zero,m,ier = sproot(t,c,[mest])
scipy.interpolate.dfitpack.sproot

# Univariate spline in the B-spline basis.
scipy.interpolate.fitpack.BSpline

# Evaluate a bivariate B-spline and its derivatives.
scipy.interpolate.fitpack.bisplev

# Find a bivariate B-spline representation of a surface.
scipy.interpolate.fitpack.bisplrep

# Insert knots into a B-spline.
scipy.interpolate.fitpack.insert

# Evaluate a B-spline and all its derivatives at one point (or set of points) up
scipy.interpolate.fitpack.spalde

# Compute the spline for the antiderivative (integral) of a given spline.
scipy.interpolate.fitpack.splantider

# Compute the spline representation of the derivative of a given spline
scipy.interpolate.fitpack.splder

# Evaluate a B-spline or its derivatives.
scipy.interpolate.fitpack.splev

# Evaluate the definite integral of a B-spline between two given points.
scipy.interpolate.fitpack.splint

# Find the B-spline representation of an N-D curve.
scipy.interpolate.fitpack.splprep

# Find the B-spline representation of a 1-D curve.
scipy.interpolate.fitpack.splrep

# Find the roots of a cubic B-spline.
scipy.interpolate.fitpack.sproot

# Base class for bivariate splines.
scipy.interpolate.fitpack2.BivariateSpline

# 1-D interpolating spline for a given set of data points.
scipy.interpolate.fitpack2.InterpolatedUnivariateSpline

# Weighted least-squares bivariate spline approximation.
scipy.interpolate.fitpack2.LSQBivariateSpline

# Weighted least-squares bivariate spline approximation in spherical
scipy.interpolate.fitpack2.LSQSphereBivariateSpline

# 1-D spline with explicit internal knots.
scipy.interpolate.fitpack2.LSQUnivariateSpline

# Bivariate spline approximation over a rectangular mesh.
scipy.interpolate.fitpack2.RectBivariateSpline

# Bivariate spline approximation over a rectangular mesh on a sphere.
scipy.interpolate.fitpack2.RectSphereBivariateSpline

# Smooth bivariate spline approximation.
scipy.interpolate.fitpack2.SmoothBivariateSpline

# Smooth bivariate spline approximation in spherical coordinates.
scipy.interpolate.fitpack2.SmoothSphereBivariateSpline

# 1-D smoothing spline fit to a given set of data points.
scipy.interpolate.fitpack2.UnivariateSpline

# Piecewise cubic, C1 smooth, curvature-minimizing interpolator in N=2 dimensions.
scipy.interpolate.interpnd.CloughTocher2DInterpolator

scipy.interpolate.interpnd.GradientEstimationWarning

# LinearNDInterpolator(points, values, fill_value=np.nan, rescale=False)
scipy.interpolate.interpnd.LinearNDInterpolator

# Common routines for interpolators.
scipy.interpolate.interpnd.NDInterpolatorBase

scipy.interpolate.interpnd.estimate_gradients_2d_global

# Piecewise polynomial in the Bernstein basis.
scipy.interpolate.interpolate.BPoly

# Univariate spline in the B-spline basis.
scipy.interpolate.interpolate.BSpline

# Piecewise tensor product polynomial
scipy.interpolate.interpolate.NdPPoly

# Piecewise polynomial in the power basis.
scipy.interpolate.interpolate.PPoly

# Bivariate spline approximation over a rectangular mesh.
scipy.interpolate.interpolate.RectBivariateSpline

# Interpolator of specified order on a rectilinear grid in N ≥ 1 dimensions.
scipy.interpolate.interpolate.RegularGridInterpolator

# Interpolate a 1-D function (legacy).
scipy.interpolate.interpolate.interp1d

# interp2d(x, y, z, kind='linear', copy=True, bounds_error=False,
scipy.interpolate.interpolate.interp2d

# Multidimensional interpolation on regular or rectilinear grids.
scipy.interpolate.interpolate.interpn

# Return a Lagrange interpolating polynomial.
scipy.interpolate.interpolate.lagrange

# Create an interpolating B-spline with specified degree and boundary conditions.
scipy.interpolate.interpolate.make_interp_spline

# Piecewise cubic, C1 smooth, curvature-minimizing interpolator in N=2 dimensions.
scipy.interpolate.ndgriddata.CloughTocher2DInterpolator

# LinearNDInterpolator(points, values, fill_value=np.nan, rescale=False)
scipy.interpolate.ndgriddata.LinearNDInterpolator

# Nearest-neighbor interpolator in N > 1 dimensions.
scipy.interpolate.ndgriddata.NearestNDInterpolator

# Convenience function for interpolating unstructured data in multiple dimensions.
scipy.interpolate.ndgriddata.griddata

# Barycentric (Lagrange with improved stability) interpolator (C∞ smooth).
scipy.interpolate.polyint.BarycentricInterpolator

# Krogh interpolator (C∞ smooth).
scipy.interpolate.polyint.KroghInterpolator

# Estimate the Taylor polynomial of f at x by polynomial fitting.
scipy.interpolate.polyint.approximate_taylor_polynomial

# Convenience function for barycentric interpolation.
scipy.interpolate.polyint.barycentric_interpolate

# Convenience function for Krogh interpolation.
scipy.interpolate.polyint.krogh_interpolate

# Rbf(*args, **kwargs)
scipy.interpolate.rbf.Rbf

scipy.io._fast_matrix_market._fmm_core.header

# open_read_file(arg0: str, arg1: int) -> scipy.io._fast_matrix_market._fmm_core._read_cursor
scipy.io._fast_matrix_market._fmm_core.open_read_file

# open_read_stream(arg0: io.BytesIO, arg1: int) -> scipy.io._fast_matrix_market._fmm_core._read_cursor
scipy.io._fast_matrix_market._fmm_core.open_read_stream

# open_write_file(arg0: str, arg1: scipy.io._fast_matrix_market._fmm_core.header, arg2: int, arg3: int) -> scipy.io._fast_matrix_market._fmm_core._write_cursor
scipy.io._fast_matrix_market._fmm_core.open_write_file

# open_write_stream(arg0: io.BytesIO, arg1: scipy.io._fast_matrix_market._fmm_core.header, arg2: int, arg3: int) -> scipy.io._fast_matrix_market._fmm_core._write_cursor
scipy.io._fast_matrix_market._fmm_core.open_write_stream

# read_body_array(*args, **kwargs)
scipy.io._fast_matrix_market._fmm_core.read_body_array

# read_body_coo(*args, **kwargs)
scipy.io._fast_matrix_market._fmm_core.read_body_coo

# write_body_array(*args, **kwargs)
scipy.io._fast_matrix_market._fmm_core.write_body_array

# write_body_coo(*args, **kwargs)
scipy.io._fast_matrix_market._fmm_core.write_body_coo

# Indicates that the file ended properly.
scipy.io._fortran.FortranEOFError

# A file object for unformatted sequential files from Fortran code.
scipy.io._fortran.FortranFile

# Indicates that the file ended mid-record.
scipy.io._fortran.FortranFormattingError

scipy.io._harwell_boeing._fortran_format_parser.BadFortranFormat

scipy.io._harwell_boeing._fortran_format_parser.ExpFormat

# Parser for Fortran format strings. The parse method returns a *Format
scipy.io._harwell_boeing._fortran_format_parser.FortranFormatParser

scipy.io._harwell_boeing._fortran_format_parser.IntFormat

# Read HB-format file.
scipy.io._harwell_boeing.hb.hb_read

# Write HB-format file.
scipy.io._harwell_boeing.hb.hb_write

# Read an IDL .sav file.
scipy.io._idl.readsav

scipy.io._mmio.MMFile

# Return size and storage parameters from Matrix Market file-like 'source'.
scipy.io._mmio.mminfo

# Reads the contents of a Matrix Market file-like 'source' into a matrix.
scipy.io._mmio.mmread

# Writes the sparse or dense array `a` to Matrix Market file-like `target`.
scipy.io._mmio.mmwrite

# A file object for NetCDF data.
scipy.io._netcdf.netcdf_file

# A data object for netcdf files.
scipy.io._netcdf.netcdf_variable

# a = read_unformatted_double(m,n,k,filename)
scipy.io._test_fortran.read_unformatted_double

# a = read_unformatted_int(m,n,k,filename)
scipy.io._test_fortran.read_unformatted_int

# a,b = read_unformatted_mixed(m,n,k,filename)
scipy.io._test_fortran.read_unformatted_mixed

scipy.io.arff._arffread.ArffError

# Small container to keep useful information on a ARFF dataset.
scipy.io.arff._arffread.MetaData

scipy.io.arff._arffread.ParseArffError

# Read an arff file.
scipy.io.arff._arffread.loadarff

scipy.io.arff.arffread.ArffError

# Small container to keep useful information on a ARFF dataset.
scipy.io.arff.arffread.MetaData

scipy.io.arff.arffread.ParseArffError

# Read an arff file.
scipy.io.arff.arffread.loadarff

# Read HB-format file.
scipy.io.harwell_boeing.hb_read

# Write HB-format file.
scipy.io.harwell_boeing.hb_write

# Read an IDL .sav file.
scipy.io.idl.readsav

# dict() -> new empty dictionary
scipy.io.matlab._byteordercodes.aliases

# str(object='') -> str
scipy.io.matlab._byteordercodes.native_code

# str(object='') -> str
scipy.io.matlab._byteordercodes.swapped_code

# Returns True when the argument is true, False otherwise.
scipy.io.matlab._byteordercodes.sys_is_le

# Convert various order codings to NumPy format.
scipy.io.matlab._byteordercodes.to_numpy_code

# Load MATLAB file.
scipy.io.matlab._mio.loadmat

# Save a dictionary of names and arrays into a MATLAB-style .mat file.
scipy.io.matlab._mio.savemat

# List variables inside a MATLAB file.
scipy.io.matlab._mio.whosmat

# Reader for Mat4 files
scipy.io.matlab._mio4.MatFile4Reader

# Class for writing matlab 4 format files
scipy.io.matlab._mio4.MatFile4Writer

# Returns True when the argument is true, False otherwise.
scipy.io.matlab._mio4.SYS_LITTLE_ENDIAN

scipy.io.matlab._mio4.VarHeader4

# Class to read matlab 4 variables
scipy.io.matlab._mio4.VarReader4

scipy.io.matlab._mio4.VarWriter4

# Make ``arr`` exactly two dimensional
scipy.io.matlab._mio4.arr_to_2d

# dict() -> new empty dictionary
scipy.io.matlab._mio4.mclass_info

# dict() -> new empty dictionary
scipy.io.matlab._mio4.mdtypes_template

# int([x]) -> integer
scipy.io.matlab._mio4.miDOUBLE

# int([x]) -> integer
scipy.io.matlab._mio4.miINT16

# int([x]) -> integer
scipy.io.matlab._mio4.miINT32

# int([x]) -> integer
scipy.io.matlab._mio4.miSINGLE

# int([x]) -> integer
scipy.io.matlab._mio4.miUINT16

# int([x]) -> integer
scipy.io.matlab._mio4.miUINT8

# int([x]) -> integer
scipy.io.matlab._mio4.mxCHAR_CLASS

# int([x]) -> integer
scipy.io.matlab._mio4.mxFULL_CLASS

# int([x]) -> integer
scipy.io.matlab._mio4.mxSPARSE_CLASS

# dict() -> new empty dictionary
scipy.io.matlab._mio4.np_to_mtypes

# dict() -> new empty dictionary
scipy.io.matlab._mio4.order_codes

# Buffered I/O implementation using an in-memory bytes buffer.
scipy.io.matlab._mio5.BytesIO

# Class to indicate presence of empty matlab struct on output
scipy.io.matlab._mio5.EmptyStructMarker

# dict() -> new empty dictionary
scipy.io.matlab._mio5.MDTYPES

# Reader for Mat 5 mat files
scipy.io.matlab._mio5.MatFile5Reader

# Class for writing mat5 files
scipy.io.matlab._mio5.MatFile5Writer

# Base object for reading mat files
scipy.io.matlab._mio5.MatFileReader

# Exception indicating a read issue.
scipy.io.matlab._mio5.MatReadError

# Warning class for read issues.
scipy.io.matlab._mio5.MatReadWarning

# Exception indicating a write issue.
scipy.io.matlab._mio5.MatWriteError

# Warning class for write issues.
scipy.io.matlab._mio5.MatWriteWarning

# Subclass for a MATLAB function.
scipy.io.matlab._mio5.MatlabFunction

# Subclass of ndarray to signal this is a matlab object.
scipy.io.matlab._mio5.MatlabObject

# DType class corresponding to the scalar type and dtype of the same name.
scipy.io.matlab._mio5.NDT_ARRAY_FLAGS

# DType class corresponding to the scalar type and dtype of the same name.
scipy.io.matlab._mio5.NDT_FILE_HDR

# DType class corresponding to the scalar type and dtype of the same name.
scipy.io.matlab._mio5.NDT_TAG_FULL

# DType class corresponding to the scalar type and dtype of the same name.
scipy.io.matlab._mio5.NDT_TAG_SMALL

# dict() -> new empty dictionary
scipy.io.matlab._mio5.NP_TO_MTYPES

# dict() -> new empty dictionary
scipy.io.matlab._mio5.NP_TO_MXTYPES

# Initialize from file reader object
scipy.io.matlab._mio5.VarReader5

# Generic matlab matrix writing class
scipy.io.matlab._mio5.VarWriter5

# File-like object uncompressing bytes from a zlib compressed stream.
scipy.io.matlab._mio5.ZlibInputStream

# Return dtype for given number of items per element
scipy.io.matlab._mio5.arr_dtype_number

# Convert string array to char array
scipy.io.matlab._mio5.arr_to_chars

scipy.io.matlab._mio5.docfiller

# Placeholder for holding read data from structs.
scipy.io.matlab._mio5.mat_struct

# Determine equivalent MATLAB dimensions for given array
scipy.io.matlab._mio5.matdims

# This module provides access to the mathematical functions
scipy.io.matlab._mio5.math

# dict() -> new empty dictionary
scipy.io.matlab._mio5.mclass_info

# int([x]) -> integer
scipy.io.matlab._mio5.miCOMPRESSED

# int([x]) -> integer
scipy.io.matlab._mio5.miINT8

# int([x]) -> integer
scipy.io.matlab._mio5.miMATRIX

# int([x]) -> integer
scipy.io.matlab._mio5.miUINT32

# int([x]) -> integer
scipy.io.matlab._mio5.miUTF8

# int([x]) -> integer
scipy.io.matlab._mio5.mxCELL_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5.mxCHAR_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5.mxDOUBLE_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5.mxOBJECT_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5.mxSPARSE_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5.mxSTRUCT_CLASS

# str(object='') -> str
scipy.io.matlab._mio5.native_code

# NumPy
scipy.io.matlab._mio5.np

# OS routines for NT or Posix depending on what system we're on.
scipy.io.matlab._mio5.os

# Generic get of byte stream data of known type
scipy.io.matlab._mio5.read_dtype

# SciPy: A scientific computing package for Python
scipy.io.matlab._mio5.scipy

# str(object='') -> str
scipy.io.matlab._mio5.swapped_code

# This module provides access to some objects used or maintained by the
scipy.io.matlab._mio5.sys

# This module provides various functions to manipulate time values.
scipy.io.matlab._mio5.time

# Convert input object ``source`` to something we can write
scipy.io.matlab._mio5.to_writeable

# Pull variables out of mat 5 file as a sequence of mat file objects
scipy.io.matlab._mio5.varmats_from_mat

# Python part of the warnings subsystem.
scipy.io.matlab._mio5.warnings

# The functions in this module allow compression and decompression using the
scipy.io.matlab._mio5.zlib

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.MDTYPES

# Subclass for a MATLAB function.
scipy.io.matlab._mio5_params.MatlabFunction

# Subclass of ndarray to signal this is a matlab object.
scipy.io.matlab._mio5_params.MatlabObject

# Subclass for a MATLAB opaque matrix.
scipy.io.matlab._mio5_params.MatlabOpaque

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.NP_TO_MTYPES

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.NP_TO_MXTYPES

# DType class corresponding to the scalar type and dtype of the same name.
scipy.io.matlab._mio5_params.OPAQUE_DTYPE

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.codecs_template

# Placeholder for holding read data from structs.
scipy.io.matlab._mio5_params.mat_struct

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.mclass_dtypes_template

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.mclass_info

# dict() -> new empty dictionary
scipy.io.matlab._mio5_params.mdtypes_template

# int([x]) -> integer
scipy.io.matlab._mio5_params.miCOMPRESSED

# int([x]) -> integer
scipy.io.matlab._mio5_params.miDOUBLE

# int([x]) -> integer
scipy.io.matlab._mio5_params.miINT16

# int([x]) -> integer
scipy.io.matlab._mio5_params.miINT32

# int([x]) -> integer
scipy.io.matlab._mio5_params.miINT64

# int([x]) -> integer
scipy.io.matlab._mio5_params.miINT8

# int([x]) -> integer
scipy.io.matlab._mio5_params.miMATRIX

# int([x]) -> integer
scipy.io.matlab._mio5_params.miSINGLE

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUINT16

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUINT32

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUINT64

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUINT8

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUTF16

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUTF32

# int([x]) -> integer
scipy.io.matlab._mio5_params.miUTF8

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxCELL_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxCHAR_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxDOUBLE_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxFUNCTION_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxINT16_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxINT32_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxINT64_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxINT8_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxOBJECT_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxOBJECT_CLASS_FROM_MATRIX_H

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxOPAQUE_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxSINGLE_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxSPARSE_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxSTRUCT_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxUINT16_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxUINT32_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxUINT64_CLASS

# int([x]) -> integer
scipy.io.matlab._mio5_params.mxUINT8_CLASS

scipy.io.matlab._mio5_utils.VarHeader5

# Initialize from file reader object
scipy.io.matlab._mio5_utils.VarReader5

scipy.io.matlab._mio5_utils.byteswap_u4

# Convert final axis of char array to strings
scipy.io.matlab._mio5_utils.chars_to_strings

# Compressed Sparse Column array.
scipy.io.matlab._mio5_utils.csc_array

# Constants and classes for matlab 5 read and write
scipy.io.matlab._mio5_utils.mio5p

# NumPy
scipy.io.matlab._mio5_utils.np

# Shallow copy operation on arbitrary Python objects.
scipy.io.matlab._mio5_utils.pycopy

# Return squeezed element
scipy.io.matlab._mio5_utils.squeeze_element

# str(object='') -> str
scipy.io.matlab._mio5_utils.swapped_code

# This module provides access to some objects used or maintained by the
scipy.io.matlab._mio5_utils.sys

# Convert final axis of char array to strings
scipy.io.matlab._mio_utils.chars_to_strings

# NumPy
scipy.io.matlab._mio_utils.np

# Return squeezed element
scipy.io.matlab._mio_utils.squeeze_element

# Exception indicating a read issue.
scipy.io.matlab._miobase.MatReadError

# Warning class for read issues.
scipy.io.matlab._miobase.MatReadWarning

# Exception indicating a write issue.
scipy.io.matlab._miobase.MatWriteError

# Warning class for write issues.
scipy.io.matlab._miobase.MatWriteWarning

# int([x]) -> integer
scipy.io.matlab._streams.BLOCK_SIZE

scipy.io.matlab._streams.GenericStream

# File-like object uncompressing bytes from a zlib compressed stream.
scipy.io.matlab._streams.ZlibInputStream

# Make stream of correct type for file-like `fobj`
scipy.io.matlab._streams.make_stream

# The functions in this module allow compression and decompression using the
scipy.io.matlab._streams.zlib

# Load MATLAB file.
scipy.io.matlab.mio.loadmat

# Save a dictionary of names and arrays into a MATLAB-style .mat file.
scipy.io.matlab.mio.savemat

# List variables inside a MATLAB file.
scipy.io.matlab.mio.whosmat

# Exception indicating a read issue.
scipy.io.matlab.mio5.MatReadError

# Warning class for read issues.
scipy.io.matlab.mio5.MatReadWarning

# Exception indicating a write issue.
scipy.io.matlab.mio5.MatWriteError

# Subclass for a MATLAB function.
scipy.io.matlab.mio5.MatlabFunction

# Subclass of ndarray to signal this is a matlab object.
scipy.io.matlab.mio5.MatlabObject

# Placeholder for holding read data from structs.
scipy.io.matlab.mio5.mat_struct

# Pull variables out of mat 5 file as a sequence of mat file objects
scipy.io.matlab.mio5.varmats_from_mat

# Subclass for a MATLAB function.
scipy.io.matlab.mio5_params.MatlabFunction

# Subclass of ndarray to signal this is a matlab object.
scipy.io.matlab.mio5_params.MatlabObject

# Subclass for a MATLAB opaque matrix.
scipy.io.matlab.mio5_params.MatlabOpaque

# Placeholder for holding read data from structs.
scipy.io.matlab.mio5_params.mat_struct

# Exception indicating a read issue.
scipy.io.matlab.miobase.MatReadError

# Warning class for read issues.
scipy.io.matlab.miobase.MatReadWarning

# Exception indicating a write issue.
scipy.io.matlab.miobase.MatWriteError

# Return size and storage parameters from Matrix Market file-like 'source'.
scipy.io.mmio.mminfo

# Reads the contents of a Matrix Market file-like 'source' into a matrix.
scipy.io.mmio.mmread

# Writes the sparse or dense array `a` to Matrix Market file-like `target`.
scipy.io.mmio.mmwrite

# A file object for NetCDF data.
scipy.io.netcdf.netcdf_file

# A data object for netcdf files.
scipy.io.netcdf.netcdf_variable

scipy.io.wavfile.WavFileWarning

# Open a WAV file.
scipy.io.wavfile.read

# Write a NumPy array as a WAV file.
scipy.io.wavfile.write

# Compute the determinant of a matrix
scipy.linalg._basic.det

# Compute the inverse of a matrix.
scipy.linalg._basic.inv

# Compute least-squares solution to the equation ``a @ x = b``.
scipy.linalg._basic.lstsq

# Efficient Toeplitz Matrix-Matrix Multiplication using FFT
scipy.linalg._basic.matmul_toeplitz

# Compute a diagonal similarity transformation for row/column balancing.
scipy.linalg._basic.matrix_balance

# Compute the (Moore-Penrose) pseudo-inverse of a matrix.
scipy.linalg._basic.pinv

# Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.
scipy.linalg._basic.pinvh

# Solve the equation ``a @ x = b`` for  ``x``,
scipy.linalg._basic.solve

# Solve the equation ``a @ x = b`` for ``x``, where ``a`` is the banded matrix
scipy.linalg._basic.solve_banded

# Solve the equation ``C @ x = b`` for ``x``, where ``C`` is a
scipy.linalg._basic.solve_circulant

# Solve the equation ``T @ x = b`` for ``x``, where ``T`` is a Toeplitz
scipy.linalg._basic.solve_toeplitz

# Solve the equation ``a @ x = b`` for ``x``, where `a` is a triangular matrix.
scipy.linalg._basic.solve_triangular

# Solve the equation ``a @ x = b`` for ``x``,  where ``a`` is the 
scipy.linalg._basic.solveh_banded

# bandwidth(a)
scipy.linalg._cythonized_array_utils.bandwidth

# ishermitian(a, atol=None, rtol=None)
scipy.linalg._cythonized_array_utils.ishermitian

# issymmetric(a, atol=None, rtol=None)
scipy.linalg._cythonized_array_utils.issymmetric

# Converts complex eigenvalues ``w`` and eigenvectors ``v`` to real
scipy.linalg._decomp.cdf2rdf

# Solve an ordinary or generalized eigenvalue problem of a square matrix.
scipy.linalg._decomp.eig

# Solve real symmetric or complex Hermitian band matrix eigenvalue problem.
scipy.linalg._decomp.eig_banded

# Solve a standard or generalized eigenvalue problem for a complex
scipy.linalg._decomp.eigh

# Solve eigenvalue problem for a real symmetric tridiagonal matrix.
scipy.linalg._decomp.eigh_tridiagonal

# Compute eigenvalues from an ordinary or generalized eigenvalue problem.
scipy.linalg._decomp.eigvals

# Solve real symmetric or complex Hermitian band matrix eigenvalue problem.
scipy.linalg._decomp.eigvals_banded

# Solves a standard or generalized eigenvalue problem for a complex
scipy.linalg._decomp.eigvalsh

# Solve eigenvalue problem for a real symmetric tridiagonal matrix.
scipy.linalg._decomp.eigvalsh_tridiagonal

# Compute Hessenberg form of a matrix.
scipy.linalg._decomp.hessenberg

# Compute the Cholesky decomposition of a matrix, to use in cho_solve
scipy.linalg._decomp_cholesky.cho_factor

# Solve the linear equations A x = b, given the Cholesky factorization of A.
scipy.linalg._decomp_cholesky.cho_solve

# Solve the linear equations ``A x = b``, given the Cholesky factorization of
scipy.linalg._decomp_cholesky.cho_solve_banded

# Compute the Cholesky decomposition of a matrix.
scipy.linalg._decomp_cholesky.cholesky

# Cholesky decompose a banded Hermitian positive-definite matrix
scipy.linalg._decomp_cholesky.cholesky_banded

# Compute the cosine-sine (CS) decomposition of an orthogonal/unitary matrix.
scipy.linalg._decomp_cossin.cossin

scipy.linalg._decomp_interpolative.idd_diffsnorm

scipy.linalg._decomp_interpolative.idd_estrank

scipy.linalg._decomp_interpolative.idd_id2svd

scipy.linalg._decomp_interpolative.idd_reconid

scipy.linalg._decomp_interpolative.idd_snorm

scipy.linalg._decomp_interpolative.iddp_aid

scipy.linalg._decomp_interpolative.iddp_asvd

scipy.linalg._decomp_interpolative.iddp_id

# This is a minimal version of ?GEQP3 from LAPACK with an
scipy.linalg._decomp_interpolative.iddp_qrpiv

scipy.linalg._decomp_interpolative.iddp_rid

scipy.linalg._decomp_interpolative.iddp_rsvd

# a is overwritten
scipy.linalg._decomp_interpolative.iddp_svd

scipy.linalg._decomp_interpolative.iddr_aid

scipy.linalg._decomp_interpolative.iddr_asvd

scipy.linalg._decomp_interpolative.iddr_id

scipy.linalg._decomp_interpolative.iddr_qrpiv

scipy.linalg._decomp_interpolative.iddr_rid

scipy.linalg._decomp_interpolative.iddr_rsvd

scipy.linalg._decomp_interpolative.iddr_svd

scipy.linalg._decomp_interpolative.idz_diffsnorm

scipy.linalg._decomp_interpolative.idz_estrank

scipy.linalg._decomp_interpolative.idz_findrank

scipy.linalg._decomp_interpolative.idz_reconid

scipy.linalg._decomp_interpolative.idz_snorm

scipy.linalg._decomp_interpolative.idzp_aid

scipy.linalg._decomp_interpolative.idzp_asvd

scipy.linalg._decomp_interpolative.idzp_id

scipy.linalg._decomp_interpolative.idzp_qrpiv

scipy.linalg._decomp_interpolative.idzp_rid

scipy.linalg._decomp_interpolative.idzp_rsvd

scipy.linalg._decomp_interpolative.idzp_svd

scipy.linalg._decomp_interpolative.idzr_aid

scipy.linalg._decomp_interpolative.idzr_asvd

scipy.linalg._decomp_interpolative.idzr_id

scipy.linalg._decomp_interpolative.idzr_qrpiv

scipy.linalg._decomp_interpolative.idzr_rid

scipy.linalg._decomp_interpolative.idzr_rsvd

scipy.linalg._decomp_interpolative.idzr_svd

# Computes the LDLt or Bunch-Kaufman factorization of a symmetric/
scipy.linalg._decomp_ldl.ldl

# Compute LU decomposition of a matrix with partial pivoting.
scipy.linalg._decomp_lu.lu

# Compute pivoted LU decomposition of a matrix.
scipy.linalg._decomp_lu.lu_factor

# Solve an equation system, a x = b, given the LU factorization of a
scipy.linalg._decomp_lu.lu_solve

scipy.linalg._decomp_lu_cython.lu_dispatcher

# Compute the polar decomposition.
scipy.linalg._decomp_polar.polar

# Compute QR decomposition of a matrix.
scipy.linalg._decomp_qr.qr

# Calculate the QR decomposition and multiply Q with a matrix.
scipy.linalg._decomp_qr.qr_multiply

# Compute RQ decomposition of a matrix.
scipy.linalg._decomp_qr.rq

# QZ decomposition for a pair of matrices with reordering.
scipy.linalg._decomp_qz.ordqz

# QZ decomposition for generalized eigenvalues of a pair of matrices.
scipy.linalg._decomp_qz.qz

# Convert real Schur form to complex Schur form.
scipy.linalg._decomp_schur.rsf2csf

# Compute Schur decomposition of a matrix.
scipy.linalg._decomp_schur.schur

# Construct the sigma matrix in SVD from singular values and size M, N.
scipy.linalg._decomp_svd.diagsvd

# Construct an orthonormal basis for the null space of A using SVD
scipy.linalg._decomp_svd.null_space

# Construct an orthonormal basis for the range of A using SVD
scipy.linalg._decomp_svd.orth

# Compute the subspace angles between two matrices.
scipy.linalg._decomp_svd.subspace_angles

# Singular Value Decomposition.
scipy.linalg._decomp_svd.svd

# Compute singular values of a matrix.
scipy.linalg._decomp_svd.svdvals

# qr_delete(Q, R, k, int p=1, which='row', overwrite_qr=False, check_finite=True)
scipy.linalg._decomp_update.qr_delete

# qr_insert(Q, R, u, k, which='row', rcond=None, overwrite_qru=False, check_finite=True)
scipy.linalg._decomp_update.qr_insert

# qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)
scipy.linalg._decomp_update.qr_update

# Relative condition number of the matrix exponential in the Frobenius norm.
scipy.linalg._expm_frechet.expm_cond

# Frechet derivative of the matrix exponential of A in the direction E.
scipy.linalg._expm_frechet.expm_frechet

# z = caxpy(x,y,[n,a,offx,incx,offy,incy])
scipy.linalg._fblas.caxpy

# y = ccopy(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.ccopy

# xy = cdotc(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.cdotc

# xy = cdotu(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.cdotu

# yout = cgbmv(m,n,kl,ku,alpha,a,x,[incx,offx,beta,y,incy,offy,trans,overwrite_y])
scipy.linalg._fblas.cgbmv

# c = cgemm(alpha,a,b,[beta,c,trans_a,trans_b,overwrite_c])
scipy.linalg._fblas.cgemm

# y = cgemv(alpha,a,x,[beta,y,offx,incx,offy,incy,trans,overwrite_y])
scipy.linalg._fblas.cgemv

# a = cgerc(alpha,x,y,[incx,incy,a,overwrite_x,overwrite_y,overwrite_a])
scipy.linalg._fblas.cgerc

# a = cgeru(alpha,x,y,[incx,incy,a,overwrite_x,overwrite_y,overwrite_a])
scipy.linalg._fblas.cgeru

# yout = chbmv(k,alpha,a,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.chbmv

# c = chemm(alpha,a,b,[beta,c,side,lower,overwrite_c])
scipy.linalg._fblas.chemm

# y = chemv(alpha,a,x,[beta,y,offx,incx,offy,incy,lower,overwrite_y])
scipy.linalg._fblas.chemv

# a = cher(alpha,x,[lower,incx,offx,n,a,overwrite_a])
scipy.linalg._fblas.cher

# a = cher2(alpha,x,y,[lower,incx,offx,incy,offy,n,a,overwrite_a])
scipy.linalg._fblas.cher2

# c = cher2k(alpha,a,b,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.cher2k

# c = cherk(alpha,a,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.cherk

# yout = chpmv(n,alpha,ap,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.chpmv

# apu = chpr(n,alpha,x,ap,[incx,offx,lower,overwrite_ap])
scipy.linalg._fblas.chpr

# apu = chpr2(n,alpha,x,y,ap,[incx,offx,incy,offy,lower,overwrite_ap])
scipy.linalg._fblas.chpr2

# c,s = crotg(a,b)
scipy.linalg._fblas.crotg

# x = cscal(a,x,[n,offx,incx])
scipy.linalg._fblas.cscal

# yout = cspmv(n,alpha,ap,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.cspmv

# apu = cspr(n,alpha,x,ap,[incx,offx,lower,overwrite_ap])
scipy.linalg._fblas.cspr

# x,y = csrot(x,y,c,s,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._fblas.csrot

# x = csscal(a,x,[n,offx,incx,overwrite_x])
scipy.linalg._fblas.csscal

# x,y = cswap(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.cswap

# c = csymm(alpha,a,b,[beta,c,side,lower,overwrite_c])
scipy.linalg._fblas.csymm

# a = csyr(alpha,x,[lower,incx,offx,n,a,overwrite_a])
scipy.linalg._fblas.csyr

# c = csyr2k(alpha,a,b,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.csyr2k

# c = csyrk(alpha,a,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.csyrk

# xout = ctbmv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ctbmv

# xout = ctbsv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ctbsv

# xout = ctpmv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ctpmv

# xout = ctpsv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ctpsv

# b = ctrmm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.ctrmm

# x = ctrmv(a,x,[offx,incx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ctrmv

# x = ctrsm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.ctrsm

# xout = ctrsv(a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ctrsv

# s = dasum(x,[n,offx,incx])
scipy.linalg._fblas.dasum

# z = daxpy(x,y,[n,a,offx,incx,offy,incy])
scipy.linalg._fblas.daxpy

# y = dcopy(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.dcopy

# xy = ddot(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.ddot

# yout = dgbmv(m,n,kl,ku,alpha,a,x,[incx,offx,beta,y,incy,offy,trans,overwrite_y])
scipy.linalg._fblas.dgbmv

# c = dgemm(alpha,a,b,[beta,c,trans_a,trans_b,overwrite_c])
scipy.linalg._fblas.dgemm

# y = dgemv(alpha,a,x,[beta,y,offx,incx,offy,incy,trans,overwrite_y])
scipy.linalg._fblas.dgemv

# a = dger(alpha,x,y,[incx,incy,a,overwrite_x,overwrite_y,overwrite_a])
scipy.linalg._fblas.dger

# n2 = dnrm2(x,[n,offx,incx])
scipy.linalg._fblas.dnrm2

# x,y = drot(x,y,c,s,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._fblas.drot

# c,s = drotg(a,b)
scipy.linalg._fblas.drotg

# x,y = drotm(x,y,param,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._fblas.drotm

# param = drotmg(d1,d2,x1,y1)
scipy.linalg._fblas.drotmg

# yout = dsbmv(k,alpha,a,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.dsbmv

# x = dscal(a,x,[n,offx,incx])
scipy.linalg._fblas.dscal

# yout = dspmv(n,alpha,ap,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.dspmv

# apu = dspr(n,alpha,x,ap,[incx,offx,lower,overwrite_ap])
scipy.linalg._fblas.dspr

# apu = dspr2(n,alpha,x,y,ap,[incx,offx,incy,offy,lower,overwrite_ap])
scipy.linalg._fblas.dspr2

# x,y = dswap(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.dswap

# c = dsymm(alpha,a,b,[beta,c,side,lower,overwrite_c])
scipy.linalg._fblas.dsymm

# y = dsymv(alpha,a,x,[beta,y,offx,incx,offy,incy,lower,overwrite_y])
scipy.linalg._fblas.dsymv

# a = dsyr(alpha,x,[lower,incx,offx,n,a,overwrite_a])
scipy.linalg._fblas.dsyr

# a = dsyr2(alpha,x,y,[lower,incx,offx,incy,offy,n,a,overwrite_a])
scipy.linalg._fblas.dsyr2

# c = dsyr2k(alpha,a,b,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.dsyr2k

# c = dsyrk(alpha,a,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.dsyrk

# xout = dtbmv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.dtbmv

# xout = dtbsv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.dtbsv

# xout = dtpmv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.dtpmv

# xout = dtpsv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.dtpsv

# b = dtrmm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.dtrmm

# x = dtrmv(a,x,[offx,incx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.dtrmv

# x = dtrsm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.dtrsm

# xout = dtrsv(a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.dtrsv

# s = dzasum(x,[n,offx,incx])
scipy.linalg._fblas.dzasum

# n2 = dznrm2(x,[n,offx,incx])
scipy.linalg._fblas.dznrm2

# k = icamax(x,[n,offx,incx])
scipy.linalg._fblas.icamax

# k = idamax(x,[n,offx,incx])
scipy.linalg._fblas.idamax

# k = isamax(x,[n,offx,incx])
scipy.linalg._fblas.isamax

# k = izamax(x,[n,offx,incx])
scipy.linalg._fblas.izamax

# s = sasum(x,[n,offx,incx])
scipy.linalg._fblas.sasum

# z = saxpy(x,y,[n,a,offx,incx,offy,incy])
scipy.linalg._fblas.saxpy

# s = scasum(x,[n,offx,incx])
scipy.linalg._fblas.scasum

# n2 = scnrm2(x,[n,offx,incx])
scipy.linalg._fblas.scnrm2

# y = scopy(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.scopy

# xy = sdot(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.sdot

# yout = sgbmv(m,n,kl,ku,alpha,a,x,[incx,offx,beta,y,incy,offy,trans,overwrite_y])
scipy.linalg._fblas.sgbmv

# c = sgemm(alpha,a,b,[beta,c,trans_a,trans_b,overwrite_c])
scipy.linalg._fblas.sgemm

# y = sgemv(alpha,a,x,[beta,y,offx,incx,offy,incy,trans,overwrite_y])
scipy.linalg._fblas.sgemv

# a = sger(alpha,x,y,[incx,incy,a,overwrite_x,overwrite_y,overwrite_a])
scipy.linalg._fblas.sger

# n2 = snrm2(x,[n,offx,incx])
scipy.linalg._fblas.snrm2

# x,y = srot(x,y,c,s,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._fblas.srot

# c,s = srotg(a,b)
scipy.linalg._fblas.srotg

# x,y = srotm(x,y,param,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._fblas.srotm

# param = srotmg(d1,d2,x1,y1)
scipy.linalg._fblas.srotmg

# yout = ssbmv(k,alpha,a,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.ssbmv

# x = sscal(a,x,[n,offx,incx])
scipy.linalg._fblas.sscal

# yout = sspmv(n,alpha,ap,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.sspmv

# apu = sspr(n,alpha,x,ap,[incx,offx,lower,overwrite_ap])
scipy.linalg._fblas.sspr

# apu = sspr2(n,alpha,x,y,ap,[incx,offx,incy,offy,lower,overwrite_ap])
scipy.linalg._fblas.sspr2

# x,y = sswap(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.sswap

# c = ssymm(alpha,a,b,[beta,c,side,lower,overwrite_c])
scipy.linalg._fblas.ssymm

# y = ssymv(alpha,a,x,[beta,y,offx,incx,offy,incy,lower,overwrite_y])
scipy.linalg._fblas.ssymv

# a = ssyr(alpha,x,[lower,incx,offx,n,a,overwrite_a])
scipy.linalg._fblas.ssyr

# a = ssyr2(alpha,x,y,[lower,incx,offx,incy,offy,n,a,overwrite_a])
scipy.linalg._fblas.ssyr2

# c = ssyr2k(alpha,a,b,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.ssyr2k

# c = ssyrk(alpha,a,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.ssyrk

# xout = stbmv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.stbmv

# xout = stbsv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.stbsv

# xout = stpmv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.stpmv

# xout = stpsv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.stpsv

# b = strmm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.strmm

# x = strmv(a,x,[offx,incx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.strmv

# x = strsm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.strsm

# xout = strsv(a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.strsv

# z = zaxpy(x,y,[n,a,offx,incx,offy,incy])
scipy.linalg._fblas.zaxpy

# y = zcopy(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.zcopy

# xy = zdotc(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.zdotc

# xy = zdotu(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.zdotu

# x,y = zdrot(x,y,c,s,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._fblas.zdrot

# x = zdscal(a,x,[n,offx,incx,overwrite_x])
scipy.linalg._fblas.zdscal

# yout = zgbmv(m,n,kl,ku,alpha,a,x,[incx,offx,beta,y,incy,offy,trans,overwrite_y])
scipy.linalg._fblas.zgbmv

# c = zgemm(alpha,a,b,[beta,c,trans_a,trans_b,overwrite_c])
scipy.linalg._fblas.zgemm

# y = zgemv(alpha,a,x,[beta,y,offx,incx,offy,incy,trans,overwrite_y])
scipy.linalg._fblas.zgemv

# a = zgerc(alpha,x,y,[incx,incy,a,overwrite_x,overwrite_y,overwrite_a])
scipy.linalg._fblas.zgerc

# a = zgeru(alpha,x,y,[incx,incy,a,overwrite_x,overwrite_y,overwrite_a])
scipy.linalg._fblas.zgeru

# yout = zhbmv(k,alpha,a,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.zhbmv

# c = zhemm(alpha,a,b,[beta,c,side,lower,overwrite_c])
scipy.linalg._fblas.zhemm

# y = zhemv(alpha,a,x,[beta,y,offx,incx,offy,incy,lower,overwrite_y])
scipy.linalg._fblas.zhemv

# a = zher(alpha,x,[lower,incx,offx,n,a,overwrite_a])
scipy.linalg._fblas.zher

# a = zher2(alpha,x,y,[lower,incx,offx,incy,offy,n,a,overwrite_a])
scipy.linalg._fblas.zher2

# c = zher2k(alpha,a,b,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.zher2k

# c = zherk(alpha,a,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.zherk

# yout = zhpmv(n,alpha,ap,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.zhpmv

# apu = zhpr(n,alpha,x,ap,[incx,offx,lower,overwrite_ap])
scipy.linalg._fblas.zhpr

# apu = zhpr2(n,alpha,x,y,ap,[incx,offx,incy,offy,lower,overwrite_ap])
scipy.linalg._fblas.zhpr2

# c,s = zrotg(a,b)
scipy.linalg._fblas.zrotg

# x = zscal(a,x,[n,offx,incx])
scipy.linalg._fblas.zscal

# yout = zspmv(n,alpha,ap,x,[incx,offx,beta,y,incy,offy,lower,overwrite_y])
scipy.linalg._fblas.zspmv

# apu = zspr(n,alpha,x,ap,[incx,offx,lower,overwrite_ap])
scipy.linalg._fblas.zspr

# x,y = zswap(x,y,[n,offx,incx,offy,incy])
scipy.linalg._fblas.zswap

# c = zsymm(alpha,a,b,[beta,c,side,lower,overwrite_c])
scipy.linalg._fblas.zsymm

# a = zsyr(alpha,x,[lower,incx,offx,n,a,overwrite_a])
scipy.linalg._fblas.zsyr

# c = zsyr2k(alpha,a,b,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.zsyr2k

# c = zsyrk(alpha,a,[beta,c,trans,lower,overwrite_c])
scipy.linalg._fblas.zsyrk

# xout = ztbmv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ztbmv

# xout = ztbsv(k,a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ztbsv

# xout = ztpmv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ztpmv

# xout = ztpsv(n,ap,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ztpsv

# b = ztrmm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.ztrmm

# x = ztrmv(a,x,[offx,incx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ztrmv

# x = ztrsm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.linalg._fblas.ztrsm

# xout = ztrsv(a,x,[incx,offx,lower,trans,diag,overwrite_x])
scipy.linalg._fblas.ztrsv

# rcond,info = cgbcon(kl,ku,ab,ipiv,anorm,[norm,ldab])
scipy.linalg._flapack.cgbcon

# lub,piv,x,info = cgbsv(kl,ku,ab,b,[overwrite_ab,overwrite_b])
scipy.linalg._flapack.cgbsv

# lu,ipiv,info = cgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
scipy.linalg._flapack.cgbtrf

# x,info = cgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
scipy.linalg._flapack.cgbtrs

# ba,lo,hi,pivscale,info = cgebal(a,[scale,permute,overwrite_a])
scipy.linalg._flapack.cgebal

# rcond,info = cgecon(a,anorm,[norm])
scipy.linalg._flapack.cgecon

# r,c,rowcnd,colcnd,amax,info = cgeequ(a)
scipy.linalg._flapack.cgeequ

# r,c,rowcnd,colcnd,amax,info = cgeequb(a)
scipy.linalg._flapack.cgeequb

# t,sdim,w,vs,work,info = cgees(cselect,a,[compute_v,sort_t,lwork,cselect_extra_args,overwrite_a])
scipy.linalg._flapack.cgees

# w,vl,vr,info = cgeev(a,[compute_vl,compute_vr,lwork,overwrite_a])
scipy.linalg._flapack.cgeev

# work,info = cgeev_lwork(n,[compute_vl,compute_vr])
scipy.linalg._flapack.cgeev_lwork

# ht,tau,info = cgehrd(a,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.cgehrd

# work,info = cgehrd_lwork(n,[lo,hi])
scipy.linalg._flapack.cgehrd_lwork

# lqr,x,info = cgels(a,b,[trans,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.cgels

# work,info = cgels_lwork(m,n,nrhs,[trans])
scipy.linalg._flapack.cgels_lwork

# x,s,rank,info = cgelsd(a,b,lwork,size_rwork,size_iwork,[cond,overwrite_a,overwrite_b])
scipy.linalg._flapack.cgelsd

# work,rwork,iwork,info = cgelsd_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.cgelsd_lwork

# v,x,s,rank,work,info = cgelss(a,b,[cond,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.cgelss

# work,info = cgelss_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.cgelss_lwork

# v,x,j,rank,info = cgelsy(a,b,jptv,cond,lwork,[overwrite_a,overwrite_b])
scipy.linalg._flapack.cgelsy

# work,info = cgelsy_lwork(m,n,nrhs,cond,[lwork])
scipy.linalg._flapack.cgelsy_lwork

# c,info = cgemqrt(v,t,c,[side,trans,overwrite_c])
scipy.linalg._flapack.cgemqrt

# qr,jpvt,tau,work,info = cgeqp3(a,[lwork,overwrite_a])
scipy.linalg._flapack.cgeqp3

# qr,tau,work,info = cgeqrf(a,[lwork,overwrite_a])
scipy.linalg._flapack.cgeqrf

# work,info = cgeqrf_lwork(m,n)
scipy.linalg._flapack.cgeqrf_lwork

# qr,tau,info = cgeqrfp(a,[lwork,overwrite_a])
scipy.linalg._flapack.cgeqrfp

# work,info = cgeqrfp_lwork(m,n)
scipy.linalg._flapack.cgeqrfp_lwork

# a,t,info = cgeqrt(nb,a,[overwrite_a])
scipy.linalg._flapack.cgeqrt

# qr,tau,work,info = cgerqf(a,[lwork,overwrite_a])
scipy.linalg._flapack.cgerqf

# x,scale = cgesc2(lu,rhs,ipiv,jpiv,[overwrite_rhs])
scipy.linalg._flapack.cgesc2

# u,s,vt,info = cgesdd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.cgesdd

# work,info = cgesdd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.cgesdd_lwork

# lu,piv,x,info = cgesv(a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.cgesv

# u,s,vt,info = cgesvd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.cgesvd

# work,info = cgesvd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.cgesvd_lwork

# as,lu,ipiv,equed,rs,cs,bs,x,rcond,ferr,berr,info = cgesvx(a,b,[fact,trans,af,ipiv,equed,r,c,overwrite_a,overwrite_b])
scipy.linalg._flapack.cgesvx

# lu,ipiv,jpiv,info = cgetc2(a,[overwrite_a])
scipy.linalg._flapack.cgetc2

# lu,piv,info = cgetrf(a,[overwrite_a])
scipy.linalg._flapack.cgetrf

# inv_a,info = cgetri(lu,piv,[lwork,overwrite_lu])
scipy.linalg._flapack.cgetri

# work,info = cgetri_lwork(n)
scipy.linalg._flapack.cgetri_lwork

# x,info = cgetrs(lu,piv,b,[trans,overwrite_b])
scipy.linalg._flapack.cgetrs

# a,b,sdim,alpha,beta,vsl,vsr,work,info = cgges(cselect,a,b,[jobvsl,jobvsr,sort_t,ldvsl,ldvsr,lwork,cselect_extra_args,overwrite_a,overwrite_b])
scipy.linalg._flapack.cgges

# alpha,beta,vl,vr,work,info = cggev(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.cggev

# t,r,res,x,info = cgglse(a,b,c,d,[lwork,overwrite_a,overwrite_b,overwrite_c,overwrite_d])
scipy.linalg._flapack.cgglse

# work,info = cgglse_lwork(m,n,p)
scipy.linalg._flapack.cgglse_lwork

# rcond,info = cgtcon(dl,d,du,du2,ipiv,anorm,[norm])
scipy.linalg._flapack.cgtcon

# du2,d,du,x,info = cgtsv(dl,d,du,b,[overwrite_dl,overwrite_d,overwrite_du,overwrite_b])
scipy.linalg._flapack.cgtsv

# dlf,df,duf,du2,ipiv,x,rcond,ferr,berr,info = cgtsvx(dl,d,du,b,[fact,trans,dlf,df,duf,du2,ipiv])
scipy.linalg._flapack.cgtsvx

# dl,d,du,du2,ipiv,info = cgttrf(dl,d,du,[overwrite_dl,overwrite_d,overwrite_du])
scipy.linalg._flapack.cgttrf

# x,info = cgttrs(dl,d,du,du2,ipiv,b,[trans,overwrite_b])
scipy.linalg._flapack.cgttrs

# w,z,info = chbevd(ab,[compute_v,lower,ldab,lrwork,liwork,overwrite_ab])
scipy.linalg._flapack.chbevd

# w,z,m,ifail,info = chbevx(ab,vl,vu,il,iu,[ldab,compute_v,range,lower,abstol,mmax,overwrite_ab])
scipy.linalg._flapack.chbevx

# rcond,info = checon(a,ipiv,anorm,[lower])
scipy.linalg._flapack.checon

# s,scond,amax,info = cheequb(a,[lower])
scipy.linalg._flapack.cheequb

# w,v,info = cheev(a,[compute_v,lower,lwork,overwrite_a])
scipy.linalg._flapack.cheev

# work,info = cheev_lwork(n,[lower])
scipy.linalg._flapack.cheev_lwork

# w,v,info = cheevd(a,[compute_v,lower,lwork,liwork,lrwork,overwrite_a])
scipy.linalg._flapack.cheevd

# work,iwork,rwork,info = cheevd_lwork(n,[compute_v,lower])
scipy.linalg._flapack.cheevd_lwork

# w,z,m,isuppz,info = cheevr(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,lrwork,liwork,overwrite_a])
scipy.linalg._flapack.cheevr

# work,rwork,iwork,info = cheevr_lwork(n,[lower])
scipy.linalg._flapack.cheevr_lwork

# w,z,m,ifail,info = cheevx(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,overwrite_a])
scipy.linalg._flapack.cheevx

# work,info = cheevx_lwork(n,[lower])
scipy.linalg._flapack.cheevx_lwork

# c,info = chegst(a,b,[itype,lower,overwrite_a])
scipy.linalg._flapack.chegst

# w,v,info = chegv(a,b,[itype,jobz,uplo,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.chegv

# work,info = chegv_lwork(n,[uplo])
scipy.linalg._flapack.chegv_lwork

# w,v,info = chegvd(a,b,[itype,jobz,uplo,lwork,lrwork,liwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.chegvd

# w,z,m,ifail,info = chegvx(a,b,[itype,jobz,range,uplo,vl,vu,il,iu,abstol,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.chegvx

# work,info = chegvx_lwork(n,[uplo])
scipy.linalg._flapack.chegvx_lwork

# uduh,ipiv,x,info = chesv(a,b,[lwork,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.chesv

# work,info = chesv_lwork(n,[lower])
scipy.linalg._flapack.chesv_lwork

# uduh,ipiv,x,rcond,ferr,berr,info = chesvx(a,b,[af,ipiv,lwork,factored,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.chesvx

# work,info = chesvx_lwork(n,[lower])
scipy.linalg._flapack.chesvx_lwork

# c,d,e,tau,info = chetrd(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.chetrd

# work,info = chetrd_lwork(n,[lower])
scipy.linalg._flapack.chetrd_lwork

# ldu,ipiv,info = chetrf(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.chetrf

# work,info = chetrf_lwork(n,[lower])
scipy.linalg._flapack.chetrf_lwork

# inv_a,info = chetri(a,ipiv,[lower,overwrite_a])
scipy.linalg._flapack.chetri

# x,info = chetrs(a,ipiv,b,[lower,overwrite_b])
scipy.linalg._flapack.chetrs

# cout = chfrk(n,k,alpha,a,beta,c,[transr,uplo,trans,overwrite_c])
scipy.linalg._flapack.chfrk

# n2 = clangb(norm,kl,ku,ab,[ldab])
scipy.linalg._flapack.clangb

# n2 = clange(norm,a)
scipy.linalg._flapack.clange

# n2 = clantr(norm,a,[uplo,diag])
scipy.linalg._flapack.clantr

# c = clarf(v,tau,c,work,[side,incv,overwrite_c])
scipy.linalg._flapack.clarf

# alpha,x,tau = clarfg(n,alpha,x,[incx,overwrite_x])
scipy.linalg._flapack.clarfg

# cs,sn,r = clartg(f,g)
scipy.linalg._flapack.clartg

# a = claswp(a,piv,[k1,k2,off,inc,overwrite_a])
scipy.linalg._flapack.claswp

# a,info = clauum(c,[lower,overwrite_c])
scipy.linalg._flapack.clauum

# c,x,info = cpbsv(ab,b,[lower,ldab,overwrite_ab,overwrite_b])
scipy.linalg._flapack.cpbsv

# c,info = cpbtrf(ab,[lower,ldab,overwrite_ab])
scipy.linalg._flapack.cpbtrf

# x,info = cpbtrs(ab,b,[lower,ldab,overwrite_b])
scipy.linalg._flapack.cpbtrs

# achol,info = cpftrf(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.cpftrf

# ainv,info = cpftri(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.cpftri

# x,info = cpftrs(n,a,b,[transr,uplo,overwrite_b])
scipy.linalg._flapack.cpftrs

# rcond,info = cpocon(a,anorm,[uplo])
scipy.linalg._flapack.cpocon

# c,x,info = cposv(a,b,[lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.cposv

# a_s,lu,equed,s,b_s,x,rcond,ferr,berr,info = cposvx(a,b,[fact,af,equed,s,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.cposvx

# c,info = cpotrf(a,[lower,clean,overwrite_a])
scipy.linalg._flapack.cpotrf

# inv_a,info = cpotri(c,[lower,overwrite_c])
scipy.linalg._flapack.cpotri

# x,info = cpotrs(c,b,[lower,overwrite_b])
scipy.linalg._flapack.cpotrs

# rcond,info = cppcon(n,ap,anorm,[lower])
scipy.linalg._flapack.cppcon

# x,info = cppsv(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.cppsv

# ul,info = cpptrf(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.cpptrf

# uli,info = cpptri(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.cpptri

# x,info = cpptrs(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.cpptrs

# c,piv,rank_c,info = cpstf2(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.cpstf2

# c,piv,rank_c,info = cpstrf(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.cpstrf

# d,e,z,info = cpteqr(d,e,z,[compute_z,overwrite_d,overwrite_e,overwrite_z])
scipy.linalg._flapack.cpteqr

# d,du,x,info = cptsv(d,e,b,[overwrite_d,overwrite_e,overwrite_b])
scipy.linalg._flapack.cptsv

# df,ef,x,rcond,ferr,berr,info = cptsvx(d,e,b,[fact,df,ef])
scipy.linalg._flapack.cptsvx

# d,e,info = cpttrf(d,e,[overwrite_d,overwrite_e])
scipy.linalg._flapack.cpttrf

# x,info = cpttrs(d,e,b,[lower,overwrite_b])
scipy.linalg._flapack.cpttrs

# x,y = crot(x,y,c,s,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._flapack.crot

# rcond,info = csycon(a,ipiv,anorm,[lower])
scipy.linalg._flapack.csycon

# a,e,info = csyconv(a,ipiv,[lower,way,overwrite_a])
scipy.linalg._flapack.csyconv

# s,scond,amax,info = csyequb(a,[lower])
scipy.linalg._flapack.csyequb

# udut,ipiv,x,info = csysv(a,b,[lwork,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.csysv

# work,info = csysv_lwork(n,[lower])
scipy.linalg._flapack.csysv_lwork

# a_s,udut,ipiv,b_s,x,rcond,ferr,berr,info = csysvx(a,b,[af,ipiv,lwork,factored,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.csysvx

# work,info = csysvx_lwork(n,[lower])
scipy.linalg._flapack.csysvx_lwork

# ldu,ipiv,info = csytf2(a,[lower,overwrite_a])
scipy.linalg._flapack.csytf2

# ldu,ipiv,info = csytrf(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.csytrf

# work,info = csytrf_lwork(n,[lower])
scipy.linalg._flapack.csytrf_lwork

# inv_a,info = csytri(a,ipiv,[lower,overwrite_a])
scipy.linalg._flapack.csytri

# x,info = csytrs(a,ipiv,b,[lower,overwrite_b])
scipy.linalg._flapack.csytrs

# x,info = ctbtrs(ab,b,[uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.ctbtrs

# x = ctfsm(alpha,a,b,[transr,side,uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.ctfsm

# ap,info = ctfttp(n,arf,[transr,uplo])
scipy.linalg._flapack.ctfttp

# a,info = ctfttr(n,arf,[transr,uplo])
scipy.linalg._flapack.ctfttr

# a,b,q,z,info = ctgexc(a,b,q,z,ifst,ilst,[wantq,wantz,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.ctgexc

# as,bs,alpha,beta,qs,zs,m,pl,pr,dif,info = ctgsen(select,a,b,q,z,[ijob,wantq,wantz,lwork,liwork,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.ctgsen

# work,iwork,info = ctgsen_lwork(select,a,b,[ijob])
scipy.linalg._flapack.ctgsen_lwork

# a,b,info = ctpmqrt(l,v,t,a,b,[side,trans,overwrite_a,overwrite_b])
scipy.linalg._flapack.ctpmqrt

# a,b,t,info = ctpqrt(l,nb,a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.ctpqrt

# arf,info = ctpttf(n,ap,[transr,uplo])
scipy.linalg._flapack.ctpttf

# a,info = ctpttr(n,ap,[uplo])
scipy.linalg._flapack.ctpttr

# rcond,info = ctrcon(a,[norm,uplo,diag])
scipy.linalg._flapack.ctrcon

# a,q,info = ctrexc(a,q,ifst,ilst,[wantq,overwrite_a,overwrite_q])
scipy.linalg._flapack.ctrexc

# ts,qs,w,m,s,sep,info = ctrsen(select,t,q,[job,wantq,lwork,overwrite_t,overwrite_q])
scipy.linalg._flapack.ctrsen

# work,info = ctrsen_lwork(select,t,[job])
scipy.linalg._flapack.ctrsen_lwork

# x,scale,info = ctrsyl(a,b,c,[trana,tranb,isgn,overwrite_c])
scipy.linalg._flapack.ctrsyl

# inv_c,info = ctrtri(c,[lower,unitdiag,overwrite_c])
scipy.linalg._flapack.ctrtri

# x,info = ctrtrs(a,b,[lower,trans,unitdiag,lda,overwrite_b])
scipy.linalg._flapack.ctrtrs

# arf,info = ctrttf(a,[transr,uplo])
scipy.linalg._flapack.ctrttf

# ap,info = ctrttp(a,[uplo])
scipy.linalg._flapack.ctrttp

# rz,tau,info = ctzrzf(a,[lwork,overwrite_a])
scipy.linalg._flapack.ctzrzf

# work,info = ctzrzf_lwork(m,n)
scipy.linalg._flapack.ctzrzf_lwork

# cs11,cs12,cs21,cs22,theta,u1,u2,v1t,v2t,info = cuncsd(x11,x12,x21,x22,[compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,lwork,lrwork,overwrite_x11,overwrite_x12,overwrite_x21,overwrite_x22])
scipy.linalg._flapack.cuncsd

# work,rwork,info = cuncsd_lwork(m,p,q)
scipy.linalg._flapack.cuncsd_lwork

# ht,info = cunghr(a,tau,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.cunghr

# work,info = cunghr_lwork(n,[lo,hi])
scipy.linalg._flapack.cunghr_lwork

# q,work,info = cungqr(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.cungqr

# q,work,info = cungrq(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.cungrq

# cq,work,info = cunmqr(side,trans,a,tau,c,lwork,[overwrite_c])
scipy.linalg._flapack.cunmqr

# cq,info = cunmrz(a,tau,c,[side,trans,lwork,overwrite_c])
scipy.linalg._flapack.cunmrz

# work,info = cunmrz_lwork(m,n,[side,trans])
scipy.linalg._flapack.cunmrz_lwork

# rcond,info = dgbcon(kl,ku,ab,ipiv,anorm,[norm,ldab])
scipy.linalg._flapack.dgbcon

# lub,piv,x,info = dgbsv(kl,ku,ab,b,[overwrite_ab,overwrite_b])
scipy.linalg._flapack.dgbsv

# lu,ipiv,info = dgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
scipy.linalg._flapack.dgbtrf

# x,info = dgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
scipy.linalg._flapack.dgbtrs

# ba,lo,hi,pivscale,info = dgebal(a,[scale,permute,overwrite_a])
scipy.linalg._flapack.dgebal

# rcond,info = dgecon(a,anorm,[norm])
scipy.linalg._flapack.dgecon

# r,c,rowcnd,colcnd,amax,info = dgeequ(a)
scipy.linalg._flapack.dgeequ

# r,c,rowcnd,colcnd,amax,info = dgeequb(a)
scipy.linalg._flapack.dgeequb

# t,sdim,wr,wi,vs,work,info = dgees(dselect,a,[compute_v,sort_t,lwork,dselect_extra_args,overwrite_a])
scipy.linalg._flapack.dgees

# wr,wi,vl,vr,info = dgeev(a,[compute_vl,compute_vr,lwork,overwrite_a])
scipy.linalg._flapack.dgeev

# work,info = dgeev_lwork(n,[compute_vl,compute_vr])
scipy.linalg._flapack.dgeev_lwork

# ht,tau,info = dgehrd(a,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.dgehrd

# work,info = dgehrd_lwork(n,[lo,hi])
scipy.linalg._flapack.dgehrd_lwork

# sva,u,v,workout,iworkout,info = dgejsv(a,[joba,jobu,jobv,jobr,jobt,jobp,lwork,overwrite_a])
scipy.linalg._flapack.dgejsv

# lqr,x,info = dgels(a,b,[trans,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.dgels

# work,info = dgels_lwork(m,n,nrhs,[trans])
scipy.linalg._flapack.dgels_lwork

# x,s,rank,info = dgelsd(a,b,lwork,size_iwork,[cond,overwrite_a,overwrite_b])
scipy.linalg._flapack.dgelsd

# work,iwork,info = dgelsd_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.dgelsd_lwork

# v,x,s,rank,work,info = dgelss(a,b,[cond,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.dgelss

# work,info = dgelss_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.dgelss_lwork

# v,x,j,rank,info = dgelsy(a,b,jptv,cond,lwork,[overwrite_a,overwrite_b])
scipy.linalg._flapack.dgelsy

# work,info = dgelsy_lwork(m,n,nrhs,cond,[lwork])
scipy.linalg._flapack.dgelsy_lwork

# c,info = dgemqrt(v,t,c,[side,trans,overwrite_c])
scipy.linalg._flapack.dgemqrt

# qr,jpvt,tau,work,info = dgeqp3(a,[lwork,overwrite_a])
scipy.linalg._flapack.dgeqp3

# qr,tau,work,info = dgeqrf(a,[lwork,overwrite_a])
scipy.linalg._flapack.dgeqrf

# work,info = dgeqrf_lwork(m,n)
scipy.linalg._flapack.dgeqrf_lwork

# qr,tau,info = dgeqrfp(a,[lwork,overwrite_a])
scipy.linalg._flapack.dgeqrfp

# work,info = dgeqrfp_lwork(m,n)
scipy.linalg._flapack.dgeqrfp_lwork

# a,t,info = dgeqrt(nb,a,[overwrite_a])
scipy.linalg._flapack.dgeqrt

# qr,tau,work,info = dgerqf(a,[lwork,overwrite_a])
scipy.linalg._flapack.dgerqf

# x,scale = dgesc2(lu,rhs,ipiv,jpiv,[overwrite_rhs])
scipy.linalg._flapack.dgesc2

# u,s,vt,info = dgesdd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.dgesdd

# work,info = dgesdd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.dgesdd_lwork

# lu,piv,x,info = dgesv(a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.dgesv

# u,s,vt,info = dgesvd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.dgesvd

# work,info = dgesvd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.dgesvd_lwork

# as,lu,ipiv,equed,rs,cs,bs,x,rcond,ferr,berr,info = dgesvx(a,b,[fact,trans,af,ipiv,equed,r,c,overwrite_a,overwrite_b])
scipy.linalg._flapack.dgesvx

# lu,ipiv,jpiv,info = dgetc2(a,[overwrite_a])
scipy.linalg._flapack.dgetc2

# lu,piv,info = dgetrf(a,[overwrite_a])
scipy.linalg._flapack.dgetrf

# inv_a,info = dgetri(lu,piv,[lwork,overwrite_lu])
scipy.linalg._flapack.dgetri

# work,info = dgetri_lwork(n)
scipy.linalg._flapack.dgetri_lwork

# x,info = dgetrs(lu,piv,b,[trans,overwrite_b])
scipy.linalg._flapack.dgetrs

# a,b,sdim,alphar,alphai,beta,vsl,vsr,work,info = dgges(dselect,a,b,[jobvsl,jobvsr,sort_t,ldvsl,ldvsr,lwork,dselect_extra_args,overwrite_a,overwrite_b])
scipy.linalg._flapack.dgges

# alphar,alphai,beta,vl,vr,work,info = dggev(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.dggev

# t,r,res,x,info = dgglse(a,b,c,d,[lwork,overwrite_a,overwrite_b,overwrite_c,overwrite_d])
scipy.linalg._flapack.dgglse

# work,info = dgglse_lwork(m,n,p)
scipy.linalg._flapack.dgglse_lwork

# rcond,info = dgtcon(dl,d,du,du2,ipiv,anorm,[norm])
scipy.linalg._flapack.dgtcon

# du2,d,du,x,info = dgtsv(dl,d,du,b,[overwrite_dl,overwrite_d,overwrite_du,overwrite_b])
scipy.linalg._flapack.dgtsv

# dlf,df,duf,du2,ipiv,x,rcond,ferr,berr,info = dgtsvx(dl,d,du,b,[fact,trans,dlf,df,duf,du2,ipiv])
scipy.linalg._flapack.dgtsvx

# dl,d,du,du2,ipiv,info = dgttrf(dl,d,du,[overwrite_dl,overwrite_d,overwrite_du])
scipy.linalg._flapack.dgttrf

# x,info = dgttrs(dl,d,du,du2,ipiv,b,[trans,overwrite_b])
scipy.linalg._flapack.dgttrs

# x = dlamch(cmach)
scipy.linalg._flapack.dlamch

# n2 = dlangb(norm,kl,ku,ab,[ldab])
scipy.linalg._flapack.dlangb

# n2 = dlange(norm,a)
scipy.linalg._flapack.dlange

# n2 = dlantr(norm,a,[uplo,diag])
scipy.linalg._flapack.dlantr

# c = dlarf(v,tau,c,work,[side,incv,overwrite_c])
scipy.linalg._flapack.dlarf

# alpha,x,tau = dlarfg(n,alpha,x,[incx,overwrite_x])
scipy.linalg._flapack.dlarfg

# cs,sn,r = dlartg(f,g)
scipy.linalg._flapack.dlartg

# delta,sigma,work,info = dlasd4(i,d,z,[rho])
scipy.linalg._flapack.dlasd4

# a = dlaswp(a,piv,[k1,k2,off,inc,overwrite_a])
scipy.linalg._flapack.dlaswp

# a,info = dlauum(c,[lower,overwrite_c])
scipy.linalg._flapack.dlauum

# cs11,cs12,cs21,cs22,theta,u1,u2,v1t,v2t,info = dorcsd(x11,x12,x21,x22,[compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,lwork,overwrite_x11,overwrite_x12,overwrite_x21,overwrite_x22])
scipy.linalg._flapack.dorcsd

# work,info = dorcsd_lwork(m,p,q)
scipy.linalg._flapack.dorcsd_lwork

# ht,info = dorghr(a,tau,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.dorghr

# work,info = dorghr_lwork(n,[lo,hi])
scipy.linalg._flapack.dorghr_lwork

# q,work,info = dorgqr(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.dorgqr

# q,work,info = dorgrq(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.dorgrq

# cq,work,info = dormqr(side,trans,a,tau,c,lwork,[overwrite_c])
scipy.linalg._flapack.dormqr

# cq,info = dormrz(a,tau,c,[side,trans,lwork,overwrite_c])
scipy.linalg._flapack.dormrz

# work,info = dormrz_lwork(m,n,[side,trans])
scipy.linalg._flapack.dormrz_lwork

# c,x,info = dpbsv(ab,b,[lower,ldab,overwrite_ab,overwrite_b])
scipy.linalg._flapack.dpbsv

# c,info = dpbtrf(ab,[lower,ldab,overwrite_ab])
scipy.linalg._flapack.dpbtrf

# x,info = dpbtrs(ab,b,[lower,ldab,overwrite_b])
scipy.linalg._flapack.dpbtrs

# achol,info = dpftrf(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.dpftrf

# ainv,info = dpftri(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.dpftri

# x,info = dpftrs(n,a,b,[transr,uplo,overwrite_b])
scipy.linalg._flapack.dpftrs

# rcond,info = dpocon(a,anorm,[uplo])
scipy.linalg._flapack.dpocon

# c,x,info = dposv(a,b,[lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.dposv

# a_s,lu,equed,s,b_s,x,rcond,ferr,berr,info = dposvx(a,b,[fact,af,equed,s,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.dposvx

# c,info = dpotrf(a,[lower,clean,overwrite_a])
scipy.linalg._flapack.dpotrf

# inv_a,info = dpotri(c,[lower,overwrite_c])
scipy.linalg._flapack.dpotri

# x,info = dpotrs(c,b,[lower,overwrite_b])
scipy.linalg._flapack.dpotrs

# rcond,info = dppcon(n,ap,anorm,[lower])
scipy.linalg._flapack.dppcon

# x,info = dppsv(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.dppsv

# ul,info = dpptrf(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.dpptrf

# uli,info = dpptri(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.dpptri

# x,info = dpptrs(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.dpptrs

# c,piv,rank_c,info = dpstf2(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.dpstf2

# c,piv,rank_c,info = dpstrf(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.dpstrf

# d,e,z,info = dpteqr(d,e,z,[compute_z,overwrite_d,overwrite_e,overwrite_z])
scipy.linalg._flapack.dpteqr

# d,du,x,info = dptsv(d,e,b,[overwrite_d,overwrite_e,overwrite_b])
scipy.linalg._flapack.dptsv

# df,ef,x,rcond,ferr,berr,info = dptsvx(d,e,b,[fact,df,ef])
scipy.linalg._flapack.dptsvx

# d,e,info = dpttrf(d,e,[overwrite_d,overwrite_e])
scipy.linalg._flapack.dpttrf

# x,info = dpttrs(d,e,b,[overwrite_b])
scipy.linalg._flapack.dpttrs

# w,z,info = dsbev(ab,[compute_v,lower,ldab,overwrite_ab])
scipy.linalg._flapack.dsbev

# w,z,info = dsbevd(ab,[compute_v,lower,ldab,liwork,overwrite_ab])
scipy.linalg._flapack.dsbevd

# w,z,m,ifail,info = dsbevx(ab,vl,vu,il,iu,[ldab,compute_v,range,lower,abstol,mmax,overwrite_ab])
scipy.linalg._flapack.dsbevx

# cout = dsfrk(n,k,alpha,a,beta,c,[transr,uplo,trans,overwrite_c])
scipy.linalg._flapack.dsfrk

# m,w,iblock,isplit,info = dstebz(d,e,range,vl,vu,il,iu,tol,order)
scipy.linalg._flapack.dstebz

# z,info = dstein(d,e,w,iblock,isplit)
scipy.linalg._flapack.dstein

# m,w,z,info = dstemr(d,e,range,vl,vu,il,iu,[compute_v,lwork,liwork,overwrite_d])
scipy.linalg._flapack.dstemr

# work,iwork,info = dstemr_lwork(d,e,range,vl,vu,il,iu,[compute_v,overwrite_d,overwrite_e])
scipy.linalg._flapack.dstemr_lwork

# vals,info = dsterf(d,e,[overwrite_d,overwrite_e])
scipy.linalg._flapack.dsterf

# vals,z,info = dstev(d,e,[compute_v,overwrite_d,overwrite_e])
scipy.linalg._flapack.dstev

# vals,z,info = dstevd(d,e,[compute_v,lwork,liwork,overwrite_d,overwrite_e])
scipy.linalg._flapack.dstevd

# rcond,info = dsycon(a,ipiv,anorm,[lower])
scipy.linalg._flapack.dsycon

# a,e,info = dsyconv(a,ipiv,[lower,way,overwrite_a])
scipy.linalg._flapack.dsyconv

# s,scond,amax,info = dsyequb(a,[lower])
scipy.linalg._flapack.dsyequb

# w,v,info = dsyev(a,[compute_v,lower,lwork,overwrite_a])
scipy.linalg._flapack.dsyev

# work,info = dsyev_lwork(n,[lower])
scipy.linalg._flapack.dsyev_lwork

# w,v,info = dsyevd(a,[compute_v,lower,lwork,liwork,overwrite_a])
scipy.linalg._flapack.dsyevd

# work,iwork,info = dsyevd_lwork(n,[compute_v,lower])
scipy.linalg._flapack.dsyevd_lwork

# w,z,m,isuppz,info = dsyevr(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,liwork,overwrite_a])
scipy.linalg._flapack.dsyevr

# work,iwork,info = dsyevr_lwork(n,[lower])
scipy.linalg._flapack.dsyevr_lwork

# w,z,m,ifail,info = dsyevx(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,overwrite_a])
scipy.linalg._flapack.dsyevx

# work,info = dsyevx_lwork(n,[lower])
scipy.linalg._flapack.dsyevx_lwork

# c,info = dsygst(a,b,[itype,lower,overwrite_a])
scipy.linalg._flapack.dsygst

# w,v,info = dsygv(a,b,[itype,jobz,uplo,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.dsygv

# work,info = dsygv_lwork(n,[uplo])
scipy.linalg._flapack.dsygv_lwork

# w,v,info = dsygvd(a,b,[itype,jobz,uplo,lwork,liwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.dsygvd

# w,z,m,ifail,info = dsygvx(a,b,[itype,jobz,range,uplo,vl,vu,il,iu,abstol,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.dsygvx

# work,info = dsygvx_lwork(n,[uplo])
scipy.linalg._flapack.dsygvx_lwork

# udut,ipiv,x,info = dsysv(a,b,[lwork,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.dsysv

# work,info = dsysv_lwork(n,[lower])
scipy.linalg._flapack.dsysv_lwork

# a_s,udut,ipiv,b_s,x,rcond,ferr,berr,info = dsysvx(a,b,[af,ipiv,lwork,factored,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.dsysvx

# work,info = dsysvx_lwork(n,[lower])
scipy.linalg._flapack.dsysvx_lwork

# ldu,ipiv,info = dsytf2(a,[lower,overwrite_a])
scipy.linalg._flapack.dsytf2

# c,d,e,tau,info = dsytrd(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.dsytrd

# work,info = dsytrd_lwork(n,[lower])
scipy.linalg._flapack.dsytrd_lwork

# ldu,ipiv,info = dsytrf(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.dsytrf

# work,info = dsytrf_lwork(n,[lower])
scipy.linalg._flapack.dsytrf_lwork

# inv_a,info = dsytri(a,ipiv,[lower,overwrite_a])
scipy.linalg._flapack.dsytri

# x,info = dsytrs(a,ipiv,b,[lower,overwrite_b])
scipy.linalg._flapack.dsytrs

# x,info = dtbtrs(ab,b,[uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.dtbtrs

# x = dtfsm(alpha,a,b,[transr,side,uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.dtfsm

# ap,info = dtfttp(n,arf,[transr,uplo])
scipy.linalg._flapack.dtfttp

# a,info = dtfttr(n,arf,[transr,uplo])
scipy.linalg._flapack.dtfttr

# a,b,q,z,work,info = dtgexc(a,b,q,z,ifst,ilst,[wantq,wantz,lwork,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.dtgexc

# as,bs,alphar,alphai,beta,qs,zs,m,pl,pr,dif,info = dtgsen(select,a,b,q,z,[ijob,wantq,wantz,lwork,liwork,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.dtgsen

# work,iwork,info = dtgsen_lwork(select,a,[ijob])
scipy.linalg._flapack.dtgsen_lwork

# r,l,scale,dif,info = dtgsyl(a,b,c,d,e,f,[trans,ijob,lwork,overwrite_c,overwrite_f])
scipy.linalg._flapack.dtgsyl

# a,b,info = dtpmqrt(l,v,t,a,b,[side,trans,overwrite_a,overwrite_b])
scipy.linalg._flapack.dtpmqrt

# a,b,t,info = dtpqrt(l,nb,a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.dtpqrt

# arf,info = dtpttf(n,ap,[transr,uplo])
scipy.linalg._flapack.dtpttf

# a,info = dtpttr(n,ap,[uplo])
scipy.linalg._flapack.dtpttr

# rcond,info = dtrcon(a,[norm,uplo,diag])
scipy.linalg._flapack.dtrcon

# a,q,info = dtrexc(a,q,ifst,ilst,[wantq,overwrite_a,overwrite_q])
scipy.linalg._flapack.dtrexc

# ts,qs,wr,wi,m,s,sep,info = dtrsen(select,t,q,[job,wantq,lwork,liwork,overwrite_t,overwrite_q])
scipy.linalg._flapack.dtrsen

# work,iwork,info = dtrsen_lwork(select,t,[job])
scipy.linalg._flapack.dtrsen_lwork

# x,scale,info = dtrsyl(a,b,c,[trana,tranb,isgn,overwrite_c])
scipy.linalg._flapack.dtrsyl

# inv_c,info = dtrtri(c,[lower,unitdiag,overwrite_c])
scipy.linalg._flapack.dtrtri

# x,info = dtrtrs(a,b,[lower,trans,unitdiag,lda,overwrite_b])
scipy.linalg._flapack.dtrtrs

# arf,info = dtrttf(a,[transr,uplo])
scipy.linalg._flapack.dtrttf

# ap,info = dtrttp(a,[uplo])
scipy.linalg._flapack.dtrttp

# rz,tau,info = dtzrzf(a,[lwork,overwrite_a])
scipy.linalg._flapack.dtzrzf

# work,info = dtzrzf_lwork(m,n)
scipy.linalg._flapack.dtzrzf_lwork

# major,minor,patch = ilaver()
scipy.linalg._flapack.ilaver

# rcond,info = sgbcon(kl,ku,ab,ipiv,anorm,[norm,ldab])
scipy.linalg._flapack.sgbcon

# lub,piv,x,info = sgbsv(kl,ku,ab,b,[overwrite_ab,overwrite_b])
scipy.linalg._flapack.sgbsv

# lu,ipiv,info = sgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
scipy.linalg._flapack.sgbtrf

# x,info = sgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
scipy.linalg._flapack.sgbtrs

# ba,lo,hi,pivscale,info = sgebal(a,[scale,permute,overwrite_a])
scipy.linalg._flapack.sgebal

# rcond,info = sgecon(a,anorm,[norm])
scipy.linalg._flapack.sgecon

# r,c,rowcnd,colcnd,amax,info = sgeequ(a)
scipy.linalg._flapack.sgeequ

# r,c,rowcnd,colcnd,amax,info = sgeequb(a)
scipy.linalg._flapack.sgeequb

# t,sdim,wr,wi,vs,work,info = sgees(sselect,a,[compute_v,sort_t,lwork,sselect_extra_args,overwrite_a])
scipy.linalg._flapack.sgees

# wr,wi,vl,vr,info = sgeev(a,[compute_vl,compute_vr,lwork,overwrite_a])
scipy.linalg._flapack.sgeev

# work,info = sgeev_lwork(n,[compute_vl,compute_vr])
scipy.linalg._flapack.sgeev_lwork

# ht,tau,info = sgehrd(a,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.sgehrd

# work,info = sgehrd_lwork(n,[lo,hi])
scipy.linalg._flapack.sgehrd_lwork

# sva,u,v,workout,iworkout,info = sgejsv(a,[joba,jobu,jobv,jobr,jobt,jobp,lwork,overwrite_a])
scipy.linalg._flapack.sgejsv

# lqr,x,info = sgels(a,b,[trans,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.sgels

# work,info = sgels_lwork(m,n,nrhs,[trans])
scipy.linalg._flapack.sgels_lwork

# x,s,rank,info = sgelsd(a,b,lwork,size_iwork,[cond,overwrite_a,overwrite_b])
scipy.linalg._flapack.sgelsd

# work,iwork,info = sgelsd_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.sgelsd_lwork

# v,x,s,rank,work,info = sgelss(a,b,[cond,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.sgelss

# work,info = sgelss_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.sgelss_lwork

# v,x,j,rank,info = sgelsy(a,b,jptv,cond,lwork,[overwrite_a,overwrite_b])
scipy.linalg._flapack.sgelsy

# work,info = sgelsy_lwork(m,n,nrhs,cond,[lwork])
scipy.linalg._flapack.sgelsy_lwork

# c,info = sgemqrt(v,t,c,[side,trans,overwrite_c])
scipy.linalg._flapack.sgemqrt

# qr,jpvt,tau,work,info = sgeqp3(a,[lwork,overwrite_a])
scipy.linalg._flapack.sgeqp3

# qr,tau,work,info = sgeqrf(a,[lwork,overwrite_a])
scipy.linalg._flapack.sgeqrf

# work,info = sgeqrf_lwork(m,n)
scipy.linalg._flapack.sgeqrf_lwork

# qr,tau,info = sgeqrfp(a,[lwork,overwrite_a])
scipy.linalg._flapack.sgeqrfp

# work,info = sgeqrfp_lwork(m,n)
scipy.linalg._flapack.sgeqrfp_lwork

# a,t,info = sgeqrt(nb,a,[overwrite_a])
scipy.linalg._flapack.sgeqrt

# qr,tau,work,info = sgerqf(a,[lwork,overwrite_a])
scipy.linalg._flapack.sgerqf

# x,scale = sgesc2(lu,rhs,ipiv,jpiv,[overwrite_rhs])
scipy.linalg._flapack.sgesc2

# u,s,vt,info = sgesdd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.sgesdd

# work,info = sgesdd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.sgesdd_lwork

# lu,piv,x,info = sgesv(a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.sgesv

# u,s,vt,info = sgesvd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.sgesvd

# work,info = sgesvd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.sgesvd_lwork

# as,lu,ipiv,equed,rs,cs,bs,x,rcond,ferr,berr,info = sgesvx(a,b,[fact,trans,af,ipiv,equed,r,c,overwrite_a,overwrite_b])
scipy.linalg._flapack.sgesvx

# lu,ipiv,jpiv,info = sgetc2(a,[overwrite_a])
scipy.linalg._flapack.sgetc2

# lu,piv,info = sgetrf(a,[overwrite_a])
scipy.linalg._flapack.sgetrf

# inv_a,info = sgetri(lu,piv,[lwork,overwrite_lu])
scipy.linalg._flapack.sgetri

# work,info = sgetri_lwork(n)
scipy.linalg._flapack.sgetri_lwork

# x,info = sgetrs(lu,piv,b,[trans,overwrite_b])
scipy.linalg._flapack.sgetrs

# a,b,sdim,alphar,alphai,beta,vsl,vsr,work,info = sgges(sselect,a,b,[jobvsl,jobvsr,sort_t,ldvsl,ldvsr,lwork,sselect_extra_args,overwrite_a,overwrite_b])
scipy.linalg._flapack.sgges

# alphar,alphai,beta,vl,vr,work,info = sggev(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.sggev

# t,r,res,x,info = sgglse(a,b,c,d,[lwork,overwrite_a,overwrite_b,overwrite_c,overwrite_d])
scipy.linalg._flapack.sgglse

# work,info = sgglse_lwork(m,n,p)
scipy.linalg._flapack.sgglse_lwork

# rcond,info = sgtcon(dl,d,du,du2,ipiv,anorm,[norm])
scipy.linalg._flapack.sgtcon

# du2,d,du,x,info = sgtsv(dl,d,du,b,[overwrite_dl,overwrite_d,overwrite_du,overwrite_b])
scipy.linalg._flapack.sgtsv

# dlf,df,duf,du2,ipiv,x,rcond,ferr,berr,info = sgtsvx(dl,d,du,b,[fact,trans,dlf,df,duf,du2,ipiv])
scipy.linalg._flapack.sgtsvx

# dl,d,du,du2,ipiv,info = sgttrf(dl,d,du,[overwrite_dl,overwrite_d,overwrite_du])
scipy.linalg._flapack.sgttrf

# x,info = sgttrs(dl,d,du,du2,ipiv,b,[trans,overwrite_b])
scipy.linalg._flapack.sgttrs

# x = slamch(cmach)
scipy.linalg._flapack.slamch

# n2 = slangb(norm,kl,ku,ab,[ldab])
scipy.linalg._flapack.slangb

# n2 = slange(norm,a)
scipy.linalg._flapack.slange

# n2 = slantr(norm,a,[uplo,diag])
scipy.linalg._flapack.slantr

# c = slarf(v,tau,c,work,[side,incv,overwrite_c])
scipy.linalg._flapack.slarf

# alpha,x,tau = slarfg(n,alpha,x,[incx,overwrite_x])
scipy.linalg._flapack.slarfg

# cs,sn,r = slartg(f,g)
scipy.linalg._flapack.slartg

# delta,sigma,work,info = slasd4(i,d,z,[rho])
scipy.linalg._flapack.slasd4

# a = slaswp(a,piv,[k1,k2,off,inc,overwrite_a])
scipy.linalg._flapack.slaswp

# a,info = slauum(c,[lower,overwrite_c])
scipy.linalg._flapack.slauum

# cs11,cs12,cs21,cs22,theta,u1,u2,v1t,v2t,info = sorcsd(x11,x12,x21,x22,[compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,lwork,overwrite_x11,overwrite_x12,overwrite_x21,overwrite_x22])
scipy.linalg._flapack.sorcsd

# work,info = sorcsd_lwork(m,p,q)
scipy.linalg._flapack.sorcsd_lwork

# ht,info = sorghr(a,tau,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.sorghr

# work,info = sorghr_lwork(n,[lo,hi])
scipy.linalg._flapack.sorghr_lwork

# q,work,info = sorgqr(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.sorgqr

# q,work,info = sorgrq(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.sorgrq

# cq,work,info = sormqr(side,trans,a,tau,c,lwork,[overwrite_c])
scipy.linalg._flapack.sormqr

# cq,info = sormrz(a,tau,c,[side,trans,lwork,overwrite_c])
scipy.linalg._flapack.sormrz

# work,info = sormrz_lwork(m,n,[side,trans])
scipy.linalg._flapack.sormrz_lwork

# c,x,info = spbsv(ab,b,[lower,ldab,overwrite_ab,overwrite_b])
scipy.linalg._flapack.spbsv

# c,info = spbtrf(ab,[lower,ldab,overwrite_ab])
scipy.linalg._flapack.spbtrf

# x,info = spbtrs(ab,b,[lower,ldab,overwrite_b])
scipy.linalg._flapack.spbtrs

# achol,info = spftrf(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.spftrf

# ainv,info = spftri(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.spftri

# x,info = spftrs(n,a,b,[transr,uplo,overwrite_b])
scipy.linalg._flapack.spftrs

# rcond,info = spocon(a,anorm,[uplo])
scipy.linalg._flapack.spocon

# c,x,info = sposv(a,b,[lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.sposv

# a_s,lu,equed,s,b_s,x,rcond,ferr,berr,info = sposvx(a,b,[fact,af,equed,s,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.sposvx

# c,info = spotrf(a,[lower,clean,overwrite_a])
scipy.linalg._flapack.spotrf

# inv_a,info = spotri(c,[lower,overwrite_c])
scipy.linalg._flapack.spotri

# x,info = spotrs(c,b,[lower,overwrite_b])
scipy.linalg._flapack.spotrs

# rcond,info = sppcon(n,ap,anorm,[lower])
scipy.linalg._flapack.sppcon

# x,info = sppsv(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.sppsv

# ul,info = spptrf(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.spptrf

# uli,info = spptri(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.spptri

# x,info = spptrs(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.spptrs

# c,piv,rank_c,info = spstf2(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.spstf2

# c,piv,rank_c,info = spstrf(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.spstrf

# d,e,z,info = spteqr(d,e,z,[compute_z,overwrite_d,overwrite_e,overwrite_z])
scipy.linalg._flapack.spteqr

# d,du,x,info = sptsv(d,e,b,[overwrite_d,overwrite_e,overwrite_b])
scipy.linalg._flapack.sptsv

# df,ef,x,rcond,ferr,berr,info = sptsvx(d,e,b,[fact,df,ef])
scipy.linalg._flapack.sptsvx

# d,e,info = spttrf(d,e,[overwrite_d,overwrite_e])
scipy.linalg._flapack.spttrf

# x,info = spttrs(d,e,b,[overwrite_b])
scipy.linalg._flapack.spttrs

# w,z,info = ssbev(ab,[compute_v,lower,ldab,overwrite_ab])
scipy.linalg._flapack.ssbev

# w,z,info = ssbevd(ab,[compute_v,lower,ldab,liwork,overwrite_ab])
scipy.linalg._flapack.ssbevd

# w,z,m,ifail,info = ssbevx(ab,vl,vu,il,iu,[ldab,compute_v,range,lower,abstol,mmax,overwrite_ab])
scipy.linalg._flapack.ssbevx

# cout = ssfrk(n,k,alpha,a,beta,c,[transr,uplo,trans,overwrite_c])
scipy.linalg._flapack.ssfrk

# m,w,iblock,isplit,info = sstebz(d,e,range,vl,vu,il,iu,tol,order)
scipy.linalg._flapack.sstebz

# z,info = sstein(d,e,w,iblock,isplit)
scipy.linalg._flapack.sstein

# m,w,z,info = sstemr(d,e,range,vl,vu,il,iu,[compute_v,lwork,liwork,overwrite_d])
scipy.linalg._flapack.sstemr

# work,iwork,info = sstemr_lwork(d,e,range,vl,vu,il,iu,[compute_v,overwrite_d,overwrite_e])
scipy.linalg._flapack.sstemr_lwork

# vals,info = ssterf(d,e,[overwrite_d,overwrite_e])
scipy.linalg._flapack.ssterf

# vals,z,info = sstev(d,e,[compute_v,overwrite_d,overwrite_e])
scipy.linalg._flapack.sstev

# vals,z,info = sstevd(d,e,[compute_v,lwork,liwork,overwrite_d,overwrite_e])
scipy.linalg._flapack.sstevd

# rcond,info = ssycon(a,ipiv,anorm,[lower])
scipy.linalg._flapack.ssycon

# a,e,info = ssyconv(a,ipiv,[lower,way,overwrite_a])
scipy.linalg._flapack.ssyconv

# s,scond,amax,info = ssyequb(a,[lower])
scipy.linalg._flapack.ssyequb

# w,v,info = ssyev(a,[compute_v,lower,lwork,overwrite_a])
scipy.linalg._flapack.ssyev

# work,info = ssyev_lwork(n,[lower])
scipy.linalg._flapack.ssyev_lwork

# w,v,info = ssyevd(a,[compute_v,lower,lwork,liwork,overwrite_a])
scipy.linalg._flapack.ssyevd

# work,iwork,info = ssyevd_lwork(n,[compute_v,lower])
scipy.linalg._flapack.ssyevd_lwork

# w,z,m,isuppz,info = ssyevr(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,liwork,overwrite_a])
scipy.linalg._flapack.ssyevr

# work,iwork,info = ssyevr_lwork(n,[lower])
scipy.linalg._flapack.ssyevr_lwork

# w,z,m,ifail,info = ssyevx(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,overwrite_a])
scipy.linalg._flapack.ssyevx

# work,info = ssyevx_lwork(n,[lower])
scipy.linalg._flapack.ssyevx_lwork

# c,info = ssygst(a,b,[itype,lower,overwrite_a])
scipy.linalg._flapack.ssygst

# w,v,info = ssygv(a,b,[itype,jobz,uplo,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.ssygv

# work,info = ssygv_lwork(n,[uplo])
scipy.linalg._flapack.ssygv_lwork

# w,v,info = ssygvd(a,b,[itype,jobz,uplo,lwork,liwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.ssygvd

# w,z,m,ifail,info = ssygvx(a,b,[itype,jobz,range,uplo,vl,vu,il,iu,abstol,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.ssygvx

# work,info = ssygvx_lwork(n,[uplo])
scipy.linalg._flapack.ssygvx_lwork

# udut,ipiv,x,info = ssysv(a,b,[lwork,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.ssysv

# work,info = ssysv_lwork(n,[lower])
scipy.linalg._flapack.ssysv_lwork

# a_s,udut,ipiv,b_s,x,rcond,ferr,berr,info = ssysvx(a,b,[af,ipiv,lwork,factored,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.ssysvx

# work,info = ssysvx_lwork(n,[lower])
scipy.linalg._flapack.ssysvx_lwork

# ldu,ipiv,info = ssytf2(a,[lower,overwrite_a])
scipy.linalg._flapack.ssytf2

# c,d,e,tau,info = ssytrd(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.ssytrd

# work,info = ssytrd_lwork(n,[lower])
scipy.linalg._flapack.ssytrd_lwork

# ldu,ipiv,info = ssytrf(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.ssytrf

# work,info = ssytrf_lwork(n,[lower])
scipy.linalg._flapack.ssytrf_lwork

# inv_a,info = ssytri(a,ipiv,[lower,overwrite_a])
scipy.linalg._flapack.ssytri

# x,info = ssytrs(a,ipiv,b,[lower,overwrite_b])
scipy.linalg._flapack.ssytrs

# x,info = stbtrs(ab,b,[uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.stbtrs

# x = stfsm(alpha,a,b,[transr,side,uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.stfsm

# ap,info = stfttp(n,arf,[transr,uplo])
scipy.linalg._flapack.stfttp

# a,info = stfttr(n,arf,[transr,uplo])
scipy.linalg._flapack.stfttr

# a,b,q,z,work,info = stgexc(a,b,q,z,ifst,ilst,[wantq,wantz,lwork,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.stgexc

# as,bs,alphar,alphai,beta,qs,zs,m,pl,pr,dif,info = stgsen(select,a,b,q,z,[ijob,wantq,wantz,lwork,liwork,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.stgsen

# work,iwork,info = stgsen_lwork(select,a,[ijob])
scipy.linalg._flapack.stgsen_lwork

# r,l,scale,dif,info = stgsyl(a,b,c,d,e,f,[trans,ijob,lwork,overwrite_c,overwrite_f])
scipy.linalg._flapack.stgsyl

# a,b,info = stpmqrt(l,v,t,a,b,[side,trans,overwrite_a,overwrite_b])
scipy.linalg._flapack.stpmqrt

# a,b,t,info = stpqrt(l,nb,a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.stpqrt

# arf,info = stpttf(n,ap,[transr,uplo])
scipy.linalg._flapack.stpttf

# a,info = stpttr(n,ap,[uplo])
scipy.linalg._flapack.stpttr

# rcond,info = strcon(a,[norm,uplo,diag])
scipy.linalg._flapack.strcon

# a,q,info = strexc(a,q,ifst,ilst,[wantq,overwrite_a,overwrite_q])
scipy.linalg._flapack.strexc

# ts,qs,wr,wi,m,s,sep,info = strsen(select,t,q,[job,wantq,lwork,liwork,overwrite_t,overwrite_q])
scipy.linalg._flapack.strsen

# work,iwork,info = strsen_lwork(select,t,[job])
scipy.linalg._flapack.strsen_lwork

# x,scale,info = strsyl(a,b,c,[trana,tranb,isgn,overwrite_c])
scipy.linalg._flapack.strsyl

# inv_c,info = strtri(c,[lower,unitdiag,overwrite_c])
scipy.linalg._flapack.strtri

# x,info = strtrs(a,b,[lower,trans,unitdiag,lda,overwrite_b])
scipy.linalg._flapack.strtrs

# arf,info = strttf(a,[transr,uplo])
scipy.linalg._flapack.strttf

# ap,info = strttp(a,[uplo])
scipy.linalg._flapack.strttp

# rz,tau,info = stzrzf(a,[lwork,overwrite_a])
scipy.linalg._flapack.stzrzf

# work,info = stzrzf_lwork(m,n)
scipy.linalg._flapack.stzrzf_lwork

# rcond,info = zgbcon(kl,ku,ab,ipiv,anorm,[norm,ldab])
scipy.linalg._flapack.zgbcon

# lub,piv,x,info = zgbsv(kl,ku,ab,b,[overwrite_ab,overwrite_b])
scipy.linalg._flapack.zgbsv

# lu,ipiv,info = zgbtrf(ab,kl,ku,[m,n,ldab,overwrite_ab])
scipy.linalg._flapack.zgbtrf

# x,info = zgbtrs(ab,kl,ku,b,ipiv,[trans,n,ldab,ldb,overwrite_b])
scipy.linalg._flapack.zgbtrs

# ba,lo,hi,pivscale,info = zgebal(a,[scale,permute,overwrite_a])
scipy.linalg._flapack.zgebal

# rcond,info = zgecon(a,anorm,[norm])
scipy.linalg._flapack.zgecon

# r,c,rowcnd,colcnd,amax,info = zgeequ(a)
scipy.linalg._flapack.zgeequ

# r,c,rowcnd,colcnd,amax,info = zgeequb(a)
scipy.linalg._flapack.zgeequb

# t,sdim,w,vs,work,info = zgees(zselect,a,[compute_v,sort_t,lwork,zselect_extra_args,overwrite_a])
scipy.linalg._flapack.zgees

# w,vl,vr,info = zgeev(a,[compute_vl,compute_vr,lwork,overwrite_a])
scipy.linalg._flapack.zgeev

# work,info = zgeev_lwork(n,[compute_vl,compute_vr])
scipy.linalg._flapack.zgeev_lwork

# ht,tau,info = zgehrd(a,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.zgehrd

# work,info = zgehrd_lwork(n,[lo,hi])
scipy.linalg._flapack.zgehrd_lwork

# lqr,x,info = zgels(a,b,[trans,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.zgels

# work,info = zgels_lwork(m,n,nrhs,[trans])
scipy.linalg._flapack.zgels_lwork

# x,s,rank,info = zgelsd(a,b,lwork,size_rwork,size_iwork,[cond,overwrite_a,overwrite_b])
scipy.linalg._flapack.zgelsd

# work,rwork,iwork,info = zgelsd_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.zgelsd_lwork

# v,x,s,rank,work,info = zgelss(a,b,[cond,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.zgelss

# work,info = zgelss_lwork(m,n,nrhs,[cond,lwork])
scipy.linalg._flapack.zgelss_lwork

# v,x,j,rank,info = zgelsy(a,b,jptv,cond,lwork,[overwrite_a,overwrite_b])
scipy.linalg._flapack.zgelsy

# work,info = zgelsy_lwork(m,n,nrhs,cond,[lwork])
scipy.linalg._flapack.zgelsy_lwork

# c,info = zgemqrt(v,t,c,[side,trans,overwrite_c])
scipy.linalg._flapack.zgemqrt

# qr,jpvt,tau,work,info = zgeqp3(a,[lwork,overwrite_a])
scipy.linalg._flapack.zgeqp3

# qr,tau,work,info = zgeqrf(a,[lwork,overwrite_a])
scipy.linalg._flapack.zgeqrf

# work,info = zgeqrf_lwork(m,n)
scipy.linalg._flapack.zgeqrf_lwork

# qr,tau,info = zgeqrfp(a,[lwork,overwrite_a])
scipy.linalg._flapack.zgeqrfp

# work,info = zgeqrfp_lwork(m,n)
scipy.linalg._flapack.zgeqrfp_lwork

# a,t,info = zgeqrt(nb,a,[overwrite_a])
scipy.linalg._flapack.zgeqrt

# qr,tau,work,info = zgerqf(a,[lwork,overwrite_a])
scipy.linalg._flapack.zgerqf

# x,scale = zgesc2(lu,rhs,ipiv,jpiv,[overwrite_rhs])
scipy.linalg._flapack.zgesc2

# u,s,vt,info = zgesdd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.zgesdd

# work,info = zgesdd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.zgesdd_lwork

# lu,piv,x,info = zgesv(a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.zgesv

# u,s,vt,info = zgesvd(a,[compute_uv,full_matrices,lwork,overwrite_a])
scipy.linalg._flapack.zgesvd

# work,info = zgesvd_lwork(m,n,[compute_uv,full_matrices])
scipy.linalg._flapack.zgesvd_lwork

# as,lu,ipiv,equed,rs,cs,bs,x,rcond,ferr,berr,info = zgesvx(a,b,[fact,trans,af,ipiv,equed,r,c,overwrite_a,overwrite_b])
scipy.linalg._flapack.zgesvx

# lu,ipiv,jpiv,info = zgetc2(a,[overwrite_a])
scipy.linalg._flapack.zgetc2

# lu,piv,info = zgetrf(a,[overwrite_a])
scipy.linalg._flapack.zgetrf

# inv_a,info = zgetri(lu,piv,[lwork,overwrite_lu])
scipy.linalg._flapack.zgetri

# work,info = zgetri_lwork(n)
scipy.linalg._flapack.zgetri_lwork

# x,info = zgetrs(lu,piv,b,[trans,overwrite_b])
scipy.linalg._flapack.zgetrs

# a,b,sdim,alpha,beta,vsl,vsr,work,info = zgges(zselect,a,b,[jobvsl,jobvsr,sort_t,ldvsl,ldvsr,lwork,zselect_extra_args,overwrite_a,overwrite_b])
scipy.linalg._flapack.zgges

# alpha,beta,vl,vr,work,info = zggev(a,b,[compute_vl,compute_vr,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.zggev

# t,r,res,x,info = zgglse(a,b,c,d,[lwork,overwrite_a,overwrite_b,overwrite_c,overwrite_d])
scipy.linalg._flapack.zgglse

# work,info = zgglse_lwork(m,n,p)
scipy.linalg._flapack.zgglse_lwork

# rcond,info = zgtcon(dl,d,du,du2,ipiv,anorm,[norm])
scipy.linalg._flapack.zgtcon

# du2,d,du,x,info = zgtsv(dl,d,du,b,[overwrite_dl,overwrite_d,overwrite_du,overwrite_b])
scipy.linalg._flapack.zgtsv

# dlf,df,duf,du2,ipiv,x,rcond,ferr,berr,info = zgtsvx(dl,d,du,b,[fact,trans,dlf,df,duf,du2,ipiv])
scipy.linalg._flapack.zgtsvx

# dl,d,du,du2,ipiv,info = zgttrf(dl,d,du,[overwrite_dl,overwrite_d,overwrite_du])
scipy.linalg._flapack.zgttrf

# x,info = zgttrs(dl,d,du,du2,ipiv,b,[trans,overwrite_b])
scipy.linalg._flapack.zgttrs

# w,z,info = zhbevd(ab,[compute_v,lower,ldab,lrwork,liwork,overwrite_ab])
scipy.linalg._flapack.zhbevd

# w,z,m,ifail,info = zhbevx(ab,vl,vu,il,iu,[ldab,compute_v,range,lower,abstol,mmax,overwrite_ab])
scipy.linalg._flapack.zhbevx

# rcond,info = zhecon(a,ipiv,anorm,[lower])
scipy.linalg._flapack.zhecon

# s,scond,amax,info = zheequb(a,[lower])
scipy.linalg._flapack.zheequb

# w,v,info = zheev(a,[compute_v,lower,lwork,overwrite_a])
scipy.linalg._flapack.zheev

# work,info = zheev_lwork(n,[lower])
scipy.linalg._flapack.zheev_lwork

# w,v,info = zheevd(a,[compute_v,lower,lwork,liwork,lrwork,overwrite_a])
scipy.linalg._flapack.zheevd

# work,iwork,rwork,info = zheevd_lwork(n,[compute_v,lower])
scipy.linalg._flapack.zheevd_lwork

# w,z,m,isuppz,info = zheevr(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,lrwork,liwork,overwrite_a])
scipy.linalg._flapack.zheevr

# work,rwork,iwork,info = zheevr_lwork(n,[lower])
scipy.linalg._flapack.zheevr_lwork

# w,z,m,ifail,info = zheevx(a,[compute_v,range,lower,vl,vu,il,iu,abstol,lwork,overwrite_a])
scipy.linalg._flapack.zheevx

# work,info = zheevx_lwork(n,[lower])
scipy.linalg._flapack.zheevx_lwork

# c,info = zhegst(a,b,[itype,lower,overwrite_a])
scipy.linalg._flapack.zhegst

# w,v,info = zhegv(a,b,[itype,jobz,uplo,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.zhegv

# work,info = zhegv_lwork(n,[uplo])
scipy.linalg._flapack.zhegv_lwork

# w,v,info = zhegvd(a,b,[itype,jobz,uplo,lwork,lrwork,liwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.zhegvd

# w,z,m,ifail,info = zhegvx(a,b,[itype,jobz,range,uplo,vl,vu,il,iu,abstol,lwork,overwrite_a,overwrite_b])
scipy.linalg._flapack.zhegvx

# work,info = zhegvx_lwork(n,[uplo])
scipy.linalg._flapack.zhegvx_lwork

# uduh,ipiv,x,info = zhesv(a,b,[lwork,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.zhesv

# work,info = zhesv_lwork(n,[lower])
scipy.linalg._flapack.zhesv_lwork

# uduh,ipiv,x,rcond,ferr,berr,info = zhesvx(a,b,[af,ipiv,lwork,factored,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.zhesvx

# work,info = zhesvx_lwork(n,[lower])
scipy.linalg._flapack.zhesvx_lwork

# c,d,e,tau,info = zhetrd(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.zhetrd

# work,info = zhetrd_lwork(n,[lower])
scipy.linalg._flapack.zhetrd_lwork

# ldu,ipiv,info = zhetrf(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.zhetrf

# work,info = zhetrf_lwork(n,[lower])
scipy.linalg._flapack.zhetrf_lwork

# inv_a,info = zhetri(a,ipiv,[lower,overwrite_a])
scipy.linalg._flapack.zhetri

# x,info = zhetrs(a,ipiv,b,[lower,overwrite_b])
scipy.linalg._flapack.zhetrs

# cout = zhfrk(n,k,alpha,a,beta,c,[transr,uplo,trans,overwrite_c])
scipy.linalg._flapack.zhfrk

# n2 = zlangb(norm,kl,ku,ab,[ldab])
scipy.linalg._flapack.zlangb

# n2 = zlange(norm,a)
scipy.linalg._flapack.zlange

# n2 = zlantr(norm,a,[uplo,diag])
scipy.linalg._flapack.zlantr

# c = zlarf(v,tau,c,work,[side,incv,overwrite_c])
scipy.linalg._flapack.zlarf

# alpha,x,tau = zlarfg(n,alpha,x,[incx,overwrite_x])
scipy.linalg._flapack.zlarfg

# cs,sn,r = zlartg(f,g)
scipy.linalg._flapack.zlartg

# a = zlaswp(a,piv,[k1,k2,off,inc,overwrite_a])
scipy.linalg._flapack.zlaswp

# a,info = zlauum(c,[lower,overwrite_c])
scipy.linalg._flapack.zlauum

# c,x,info = zpbsv(ab,b,[lower,ldab,overwrite_ab,overwrite_b])
scipy.linalg._flapack.zpbsv

# c,info = zpbtrf(ab,[lower,ldab,overwrite_ab])
scipy.linalg._flapack.zpbtrf

# x,info = zpbtrs(ab,b,[lower,ldab,overwrite_b])
scipy.linalg._flapack.zpbtrs

# achol,info = zpftrf(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.zpftrf

# ainv,info = zpftri(n,a,[transr,uplo,overwrite_a])
scipy.linalg._flapack.zpftri

# x,info = zpftrs(n,a,b,[transr,uplo,overwrite_b])
scipy.linalg._flapack.zpftrs

# rcond,info = zpocon(a,anorm,[uplo])
scipy.linalg._flapack.zpocon

# c,x,info = zposv(a,b,[lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.zposv

# a_s,lu,equed,s,b_s,x,rcond,ferr,berr,info = zposvx(a,b,[fact,af,equed,s,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.zposvx

# c,info = zpotrf(a,[lower,clean,overwrite_a])
scipy.linalg._flapack.zpotrf

# inv_a,info = zpotri(c,[lower,overwrite_c])
scipy.linalg._flapack.zpotri

# x,info = zpotrs(c,b,[lower,overwrite_b])
scipy.linalg._flapack.zpotrs

# rcond,info = zppcon(n,ap,anorm,[lower])
scipy.linalg._flapack.zppcon

# x,info = zppsv(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.zppsv

# ul,info = zpptrf(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.zpptrf

# uli,info = zpptri(n,ap,[lower,overwrite_ap])
scipy.linalg._flapack.zpptri

# x,info = zpptrs(n,ap,b,[lower,overwrite_b])
scipy.linalg._flapack.zpptrs

# c,piv,rank_c,info = zpstf2(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.zpstf2

# c,piv,rank_c,info = zpstrf(a,[tol,lower,overwrite_a])
scipy.linalg._flapack.zpstrf

# d,e,z,info = zpteqr(d,e,z,[compute_z,overwrite_d,overwrite_e,overwrite_z])
scipy.linalg._flapack.zpteqr

# d,du,x,info = zptsv(d,e,b,[overwrite_d,overwrite_e,overwrite_b])
scipy.linalg._flapack.zptsv

# df,ef,x,rcond,ferr,berr,info = zptsvx(d,e,b,[fact,df,ef])
scipy.linalg._flapack.zptsvx

# d,e,info = zpttrf(d,e,[overwrite_d,overwrite_e])
scipy.linalg._flapack.zpttrf

# x,info = zpttrs(d,e,b,[lower,overwrite_b])
scipy.linalg._flapack.zpttrs

# x,y = zrot(x,y,c,s,[n,offx,incx,offy,incy,overwrite_x,overwrite_y])
scipy.linalg._flapack.zrot

# rcond,info = zsycon(a,ipiv,anorm,[lower])
scipy.linalg._flapack.zsycon

# a,e,info = zsyconv(a,ipiv,[lower,way,overwrite_a])
scipy.linalg._flapack.zsyconv

# s,scond,amax,info = zsyequb(a,[lower])
scipy.linalg._flapack.zsyequb

# udut,ipiv,x,info = zsysv(a,b,[lwork,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.zsysv

# work,info = zsysv_lwork(n,[lower])
scipy.linalg._flapack.zsysv_lwork

# a_s,udut,ipiv,b_s,x,rcond,ferr,berr,info = zsysvx(a,b,[af,ipiv,lwork,factored,lower,overwrite_a,overwrite_b])
scipy.linalg._flapack.zsysvx

# work,info = zsysvx_lwork(n,[lower])
scipy.linalg._flapack.zsysvx_lwork

# ldu,ipiv,info = zsytf2(a,[lower,overwrite_a])
scipy.linalg._flapack.zsytf2

# ldu,ipiv,info = zsytrf(a,[lower,lwork,overwrite_a])
scipy.linalg._flapack.zsytrf

# work,info = zsytrf_lwork(n,[lower])
scipy.linalg._flapack.zsytrf_lwork

# inv_a,info = zsytri(a,ipiv,[lower,overwrite_a])
scipy.linalg._flapack.zsytri

# x,info = zsytrs(a,ipiv,b,[lower,overwrite_b])
scipy.linalg._flapack.zsytrs

# x,info = ztbtrs(ab,b,[uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.ztbtrs

# x = ztfsm(alpha,a,b,[transr,side,uplo,trans,diag,overwrite_b])
scipy.linalg._flapack.ztfsm

# ap,info = ztfttp(n,arf,[transr,uplo])
scipy.linalg._flapack.ztfttp

# a,info = ztfttr(n,arf,[transr,uplo])
scipy.linalg._flapack.ztfttr

# a,b,q,z,info = ztgexc(a,b,q,z,ifst,ilst,[wantq,wantz,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.ztgexc

# as,bs,alpha,beta,qs,zs,m,pl,pr,dif,info = ztgsen(select,a,b,q,z,[ijob,wantq,wantz,lwork,liwork,overwrite_a,overwrite_b,overwrite_q,overwrite_z])
scipy.linalg._flapack.ztgsen

# work,iwork,info = ztgsen_lwork(select,a,b,[ijob])
scipy.linalg._flapack.ztgsen_lwork

# a,b,info = ztpmqrt(l,v,t,a,b,[side,trans,overwrite_a,overwrite_b])
scipy.linalg._flapack.ztpmqrt

# a,b,t,info = ztpqrt(l,nb,a,b,[overwrite_a,overwrite_b])
scipy.linalg._flapack.ztpqrt

# arf,info = ztpttf(n,ap,[transr,uplo])
scipy.linalg._flapack.ztpttf

# a,info = ztpttr(n,ap,[uplo])
scipy.linalg._flapack.ztpttr

# rcond,info = ztrcon(a,[norm,uplo,diag])
scipy.linalg._flapack.ztrcon

# a,q,info = ztrexc(a,q,ifst,ilst,[wantq,overwrite_a,overwrite_q])
scipy.linalg._flapack.ztrexc

# ts,qs,w,m,s,sep,info = ztrsen(select,t,q,[job,wantq,lwork,overwrite_t,overwrite_q])
scipy.linalg._flapack.ztrsen

# work,info = ztrsen_lwork(select,t,[job])
scipy.linalg._flapack.ztrsen_lwork

# x,scale,info = ztrsyl(a,b,c,[trana,tranb,isgn,overwrite_c])
scipy.linalg._flapack.ztrsyl

# inv_c,info = ztrtri(c,[lower,unitdiag,overwrite_c])
scipy.linalg._flapack.ztrtri

# x,info = ztrtrs(a,b,[lower,trans,unitdiag,lda,overwrite_b])
scipy.linalg._flapack.ztrtrs

# arf,info = ztrttf(a,[transr,uplo])
scipy.linalg._flapack.ztrttf

# ap,info = ztrttp(a,[uplo])
scipy.linalg._flapack.ztrttp

# rz,tau,info = ztzrzf(a,[lwork,overwrite_a])
scipy.linalg._flapack.ztzrzf

# work,info = ztzrzf_lwork(m,n)
scipy.linalg._flapack.ztzrzf_lwork

# cs11,cs12,cs21,cs22,theta,u1,u2,v1t,v2t,info = zuncsd(x11,x12,x21,x22,[compute_u1,compute_u2,compute_v1t,compute_v2t,trans,signs,lwork,lrwork,overwrite_x11,overwrite_x12,overwrite_x21,overwrite_x22])
scipy.linalg._flapack.zuncsd

# work,rwork,info = zuncsd_lwork(m,p,q)
scipy.linalg._flapack.zuncsd_lwork

# ht,info = zunghr(a,tau,[lo,hi,lwork,overwrite_a])
scipy.linalg._flapack.zunghr

# work,info = zunghr_lwork(n,[lo,hi])
scipy.linalg._flapack.zunghr_lwork

# q,work,info = zungqr(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.zungqr

# q,work,info = zungrq(a,tau,[lwork,overwrite_a])
scipy.linalg._flapack.zungrq

# cq,work,info = zunmqr(side,trans,a,tau,c,lwork,[overwrite_c])
scipy.linalg._flapack.zunmqr

# cq,info = zunmrz(a,tau,c,[side,trans,lwork,overwrite_c])
scipy.linalg._flapack.zunmrz

# work,info = zunmrz_lwork(m,n,[side,trans])
scipy.linalg._flapack.zunmrz_lwork

# Compute the hyperbolic matrix cosine.
scipy.linalg._matfuncs.coshm

# Compute the matrix cosine.
scipy.linalg._matfuncs.cosm

# Compute the matrix exponential of an array.
scipy.linalg._matfuncs.expm

# Relative condition number of the matrix exponential in the Frobenius norm.
scipy.linalg._matfuncs.expm_cond

# Frechet derivative of the matrix exponential of A in the direction E.
scipy.linalg._matfuncs.expm_frechet

# Compute the fractional power of a matrix.
scipy.linalg._matfuncs.fractional_matrix_power

# Evaluate a matrix function specified by a callable.
scipy.linalg._matfuncs.funm

# Khatri-rao product
scipy.linalg._matfuncs.khatri_rao

# Compute matrix logarithm.
scipy.linalg._matfuncs.logm

# Matrix sign function.
scipy.linalg._matfuncs.signm

# Compute the hyperbolic matrix sine.
scipy.linalg._matfuncs.sinhm

# Compute the matrix sine.
scipy.linalg._matfuncs.sinm

# Compute, if exists, the matrix square root.
scipy.linalg._matfuncs.sqrtm

# Compute the hyperbolic matrix tangent.
scipy.linalg._matfuncs.tanhm

# Compute the matrix tangent.
scipy.linalg._matfuncs.tanm

scipy.linalg._matfuncs_expm.error

# info = pade_UV_calc(Am, m)
scipy.linalg._matfuncs_expm.pade_UV_calc

# [m, s] = pick_pade_structure(Am)
scipy.linalg._matfuncs_expm.pick_pade_structure

scipy.linalg._matfuncs_inv_ssq.FractionalMatrixPowerError

# Common interface for performing matrix vector products
scipy.linalg._matfuncs_inv_ssq.LinearOperator

scipy.linalg._matfuncs_inv_ssq.LogmError

scipy.linalg._matfuncs_inv_ssq.LogmExactlySingularWarning

scipy.linalg._matfuncs_inv_ssq.LogmNearlySingularWarning

scipy.linalg._matfuncs_inv_ssq.LogmRankWarning

scipy.linalg._matfuncs_inv_ssq.SqrtmError

# Evaluate a matrix function specified by a callable.
scipy.linalg._matfuncs_inv_ssq.funm

# NumPy
scipy.linalg._matfuncs_inv_ssq.np

# Compute a lower bound of the 1-norm of a sparse array.
scipy.linalg._matfuncs_inv_ssq.onenormest

# Convert real Schur form to complex Schur form.
scipy.linalg._matfuncs_inv_ssq.rsf2csf

# Compute Schur decomposition of a matrix.
scipy.linalg._matfuncs_inv_ssq.schur

# SciPy: A scientific computing package for Python
scipy.linalg._matfuncs_inv_ssq.scipy

# Solve the equation ``a @ x = b`` for ``x``, where `a` is a triangular matrix.
scipy.linalg._matfuncs_inv_ssq.solve_triangular

# Compute singular values of a matrix.
scipy.linalg._matfuncs_inv_ssq.svdvals

# Python part of the warnings subsystem.
scipy.linalg._matfuncs_inv_ssq.warnings

scipy.linalg._matfuncs_schur_sqrtm.error

# Compute the matrix square root by recursion.
scipy.linalg._matfuncs_schur_sqrtm.recursive_schur_sqrtm

scipy.linalg._matfuncs_sqrtm_triu.SqrtmError

scipy.linalg._matfuncs_sqrtm_triu.within_block_loop

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg._misc.LinAlgError

# The warning emitted when a linear algebra related operation is close
scipy.linalg._misc.LinAlgWarning

# Matrix or vector norm.
scipy.linalg._misc.norm

# Compute the matrix solution of the orthogonal (or unitary) Procrustes problem.
scipy.linalg._procrustes.orthogonal_procrustes

# Applies a Clarkson-Woodruff Transform/sketch to the input matrix.
scipy.linalg._sketches.clarkson_woodruff_transform

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg._solve_toeplitz.LinAlgError

# asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
scipy.linalg._solve_toeplitz.asarray

# Complex number type composed of two double-precision floating-point
scipy.linalg._solve_toeplitz.complex128

# Double-precision floating-point number type, compatible with Python
scipy.linalg._solve_toeplitz.float64

# Solve a linear Toeplitz system using Levinson recursion.
scipy.linalg._solve_toeplitz.levinson

# zeros(shape, dtype=float, order='C', *, like=None)
scipy.linalg._solve_toeplitz.zeros

# Solves the continuous-time algebraic Riccati equation (CARE).
scipy.linalg._solvers.solve_continuous_are

# Solves the continuous Lyapunov equation :math:`AX + XA^H = Q`.
scipy.linalg._solvers.solve_continuous_lyapunov

# Solves the discrete-time algebraic Riccati equation (DARE).
scipy.linalg._solvers.solve_discrete_are

# Solves the discrete Lyapunov equation :math:`AXA^H - X + Q = 0`.
scipy.linalg._solvers.solve_discrete_lyapunov

# Solves the continuous Lyapunov equation :math:`AX + XA^H = Q`.
scipy.linalg._solvers.solve_lyapunov

# Computes a solution (X) to the Sylvester equation :math:`AX + XB = Q`.
scipy.linalg._solvers.solve_sylvester

# Create a block diagonal array from provided arrays.
scipy.linalg._special_matrices.block_diag

# Construct a circulant matrix.
scipy.linalg._special_matrices.circulant

# Create a companion matrix.
scipy.linalg._special_matrices.companion

# Construct a convolution matrix.
scipy.linalg._special_matrices.convolution_matrix

# Discrete Fourier transform matrix.
scipy.linalg._special_matrices.dft

# Returns a symmetric Fiedler matrix
scipy.linalg._special_matrices.fiedler

# Returns a Fiedler companion matrix
scipy.linalg._special_matrices.fiedler_companion

# Construct an Hadamard matrix.
scipy.linalg._special_matrices.hadamard

# Construct a Hankel matrix.
scipy.linalg._special_matrices.hankel

# Create an Helmert matrix of order `n`.
scipy.linalg._special_matrices.helmert

# Create a Hilbert matrix of order `n`.
scipy.linalg._special_matrices.hilbert

# Compute the inverse of the Hilbert matrix of order `n`.
scipy.linalg._special_matrices.invhilbert

# Returns the inverse of the n x n Pascal matrix.
scipy.linalg._special_matrices.invpascal

# Kronecker product.
scipy.linalg._special_matrices.kron

# Create a Leslie matrix.
scipy.linalg._special_matrices.leslie

# Returns the n x n Pascal matrix.
scipy.linalg._special_matrices.pascal

# Construct a Toeplitz matrix.
scipy.linalg._special_matrices.toeplitz

# Test that a call does not overwrite its input arguments
scipy.linalg._testutils.assert_no_overwrite

# NumPy
scipy.linalg._testutils.np

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg.basic.LinAlgError

# The warning emitted when a linear algebra related operation is close
scipy.linalg.basic.LinAlgWarning

# Compute the determinant of a matrix
scipy.linalg.basic.det

# Return available LAPACK function objects from names.
scipy.linalg.basic.get_lapack_funcs

# Compute the inverse of a matrix.
scipy.linalg.basic.inv

# Compute least-squares solution to the equation ``a @ x = b``.
scipy.linalg.basic.lstsq

# Efficient Toeplitz Matrix-Matrix Multiplication using FFT
scipy.linalg.basic.matmul_toeplitz

# Compute a diagonal similarity transformation for row/column balancing.
scipy.linalg.basic.matrix_balance

# Compute the (Moore-Penrose) pseudo-inverse of a matrix.
scipy.linalg.basic.pinv

# Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.
scipy.linalg.basic.pinvh

# Solve the equation ``a @ x = b`` for  ``x``,
scipy.linalg.basic.solve

# Solve the equation ``a @ x = b`` for ``x``, where ``a`` is the banded matrix
scipy.linalg.basic.solve_banded

# Solve the equation ``C @ x = b`` for ``x``, where ``C`` is a
scipy.linalg.basic.solve_circulant

# Solve the equation ``T @ x = b`` for ``x``, where ``T`` is a Toeplitz
scipy.linalg.basic.solve_toeplitz

# Solve the equation ``a @ x = b`` for ``x``, where `a` is a triangular matrix.
scipy.linalg.basic.solve_triangular

# Solve the equation ``a @ x = b`` for ``x``,  where ``a`` is the 
scipy.linalg.basic.solveh_banded

# Find best-matching BLAS/LAPACK type.
scipy.linalg.blas.find_best_blas_type

# Return available BLAS function objects from names.
scipy.linalg.blas.get_blas_funcs

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg.decomp.LinAlgError

# Converts complex eigenvalues ``w`` and eigenvectors ``v`` to real
scipy.linalg.decomp.cdf2rdf

# Solve an ordinary or generalized eigenvalue problem of a square matrix.
scipy.linalg.decomp.eig

# Solve real symmetric or complex Hermitian band matrix eigenvalue problem.
scipy.linalg.decomp.eig_banded

# Solve a standard or generalized eigenvalue problem for a complex
scipy.linalg.decomp.eigh

# Solve eigenvalue problem for a real symmetric tridiagonal matrix.
scipy.linalg.decomp.eigh_tridiagonal

# Compute eigenvalues from an ordinary or generalized eigenvalue problem.
scipy.linalg.decomp.eigvals

# Solve real symmetric or complex Hermitian band matrix eigenvalue problem.
scipy.linalg.decomp.eigvals_banded

# Solves a standard or generalized eigenvalue problem for a complex
scipy.linalg.decomp.eigvalsh

# Solve eigenvalue problem for a real symmetric tridiagonal matrix.
scipy.linalg.decomp.eigvalsh_tridiagonal

# Return available LAPACK function objects from names.
scipy.linalg.decomp.get_lapack_funcs

# Compute Hessenberg form of a matrix.
scipy.linalg.decomp.hessenberg

# Matrix or vector norm.
scipy.linalg.decomp.norm

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg.decomp_cholesky.LinAlgError

# Compute the Cholesky decomposition of a matrix, to use in cho_solve
scipy.linalg.decomp_cholesky.cho_factor

# Solve the linear equations A x = b, given the Cholesky factorization of A.
scipy.linalg.decomp_cholesky.cho_solve

# Solve the linear equations ``A x = b``, given the Cholesky factorization of
scipy.linalg.decomp_cholesky.cho_solve_banded

# Compute the Cholesky decomposition of a matrix.
scipy.linalg.decomp_cholesky.cholesky

# Cholesky decompose a banded Hermitian positive-definite matrix
scipy.linalg.decomp_cholesky.cholesky_banded

# Return available LAPACK function objects from names.
scipy.linalg.decomp_cholesky.get_lapack_funcs

# The warning emitted when a linear algebra related operation is close
scipy.linalg.decomp_lu.LinAlgWarning

# Return available LAPACK function objects from names.
scipy.linalg.decomp_lu.get_lapack_funcs

# Compute LU decomposition of a matrix with partial pivoting.
scipy.linalg.decomp_lu.lu

# Compute pivoted LU decomposition of a matrix.
scipy.linalg.decomp_lu.lu_factor

# Solve an equation system, a x = b, given the LU factorization of a
scipy.linalg.decomp_lu.lu_solve

# Return available LAPACK function objects from names.
scipy.linalg.decomp_qr.get_lapack_funcs

# Compute QR decomposition of a matrix.
scipy.linalg.decomp_qr.qr

# Calculate the QR decomposition and multiply Q with a matrix.
scipy.linalg.decomp_qr.qr_multiply

# Compute RQ decomposition of a matrix.
scipy.linalg.decomp_qr.rq

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg.decomp_schur.LinAlgError

# Compute eigenvalues from an ordinary or generalized eigenvalue problem.
scipy.linalg.decomp_schur.eigvals

# Return available LAPACK function objects from names.
scipy.linalg.decomp_schur.get_lapack_funcs

# Matrix or vector norm.
scipy.linalg.decomp_schur.norm

# Convert real Schur form to complex Schur form.
scipy.linalg.decomp_schur.rsf2csf

# Compute Schur decomposition of a matrix.
scipy.linalg.decomp_schur.schur

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg.decomp_svd.LinAlgError

# Construct the sigma matrix in SVD from singular values and size M, N.
scipy.linalg.decomp_svd.diagsvd

# Return available LAPACK function objects from names.
scipy.linalg.decomp_svd.get_lapack_funcs

# Construct an orthonormal basis for the null space of A using SVD
scipy.linalg.decomp_svd.null_space

# Construct an orthonormal basis for the range of A using SVD
scipy.linalg.decomp_svd.orth

# Compute the subspace angles between two matrices.
scipy.linalg.decomp_svd.subspace_angles

# Singular Value Decomposition.
scipy.linalg.decomp_svd.svd

# Compute singular values of a matrix.
scipy.linalg.decomp_svd.svdvals

# Estimate matrix rank to a specified relative precision using randomized
scipy.linalg.interpolative.estimate_rank

# Estimate spectral norm of a matrix by the randomized power method.
scipy.linalg.interpolative.estimate_spectral_norm

# Estimate spectral norm of the difference of two matrices by the randomized
scipy.linalg.interpolative.estimate_spectral_norm_diff

# Convert ID to SVD.
scipy.linalg.interpolative.id_to_svd

# Compute ID of a matrix.
scipy.linalg.interpolative.interp_decomp

# This function, historically, used to generate uniformly distributed random number
scipy.linalg.interpolative.rand

# Reconstruct interpolation matrix from ID.
scipy.linalg.interpolative.reconstruct_interp_matrix

# Reconstruct matrix from its ID.
scipy.linalg.interpolative.reconstruct_matrix_from_id

# Reconstruct skeleton matrix from ID.
scipy.linalg.interpolative.reconstruct_skel_matrix

# This function, historically, used to set the seed of the randomization algorithms
scipy.linalg.interpolative.seed

# Compute SVD of a matrix via an ID.
scipy.linalg.interpolative.svd

# Return available LAPACK function objects from names.
scipy.linalg.lapack.get_lapack_funcs

# Compute the hyperbolic matrix cosine.
scipy.linalg.matfuncs.coshm

# Compute the matrix cosine.
scipy.linalg.matfuncs.cosm

# Compute the matrix exponential of an array.
scipy.linalg.matfuncs.expm

# Relative condition number of the matrix exponential in the Frobenius norm.
scipy.linalg.matfuncs.expm_cond

# Frechet derivative of the matrix exponential of A in the direction E.
scipy.linalg.matfuncs.expm_frechet

# Compute the fractional power of a matrix.
scipy.linalg.matfuncs.fractional_matrix_power

# Evaluate a matrix function specified by a callable.
scipy.linalg.matfuncs.funm

# Compute the inverse of a matrix.
scipy.linalg.matfuncs.inv

# Khatri-rao product
scipy.linalg.matfuncs.khatri_rao

# Compute matrix logarithm.
scipy.linalg.matfuncs.logm

# Matrix or vector norm.
scipy.linalg.matfuncs.norm

# Convert real Schur form to complex Schur form.
scipy.linalg.matfuncs.rsf2csf

# Compute Schur decomposition of a matrix.
scipy.linalg.matfuncs.schur

# Matrix sign function.
scipy.linalg.matfuncs.signm

# Compute the hyperbolic matrix sine.
scipy.linalg.matfuncs.sinhm

# Compute the matrix sine.
scipy.linalg.matfuncs.sinm

# Solve the equation ``a @ x = b`` for  ``x``,
scipy.linalg.matfuncs.solve

# Compute, if exists, the matrix square root.
scipy.linalg.matfuncs.sqrtm

# Singular Value Decomposition.
scipy.linalg.matfuncs.svd

# Compute the hyperbolic matrix tangent.
scipy.linalg.matfuncs.tanhm

# Compute the matrix tangent.
scipy.linalg.matfuncs.tanm

# Generic Python-exception-derived object raised by linalg functions.
scipy.linalg.misc.LinAlgError

# The warning emitted when a linear algebra related operation is close
scipy.linalg.misc.LinAlgWarning

# Return available BLAS function objects from names.
scipy.linalg.misc.get_blas_funcs

# Return available LAPACK function objects from names.
scipy.linalg.misc.get_lapack_funcs

# Matrix or vector norm.
scipy.linalg.misc.norm

# Create a block diagonal array from provided arrays.
scipy.linalg.special_matrices.block_diag

# Construct a circulant matrix.
scipy.linalg.special_matrices.circulant

# Create a companion matrix.
scipy.linalg.special_matrices.companion

# Construct a convolution matrix.
scipy.linalg.special_matrices.convolution_matrix

# Discrete Fourier transform matrix.
scipy.linalg.special_matrices.dft

# Returns a symmetric Fiedler matrix
scipy.linalg.special_matrices.fiedler

# Returns a Fiedler companion matrix
scipy.linalg.special_matrices.fiedler_companion

# Construct an Hadamard matrix.
scipy.linalg.special_matrices.hadamard

# Construct a Hankel matrix.
scipy.linalg.special_matrices.hankel

# Create an Helmert matrix of order `n`.
scipy.linalg.special_matrices.helmert

# Create a Hilbert matrix of order `n`.
scipy.linalg.special_matrices.hilbert

# Compute the inverse of the Hilbert matrix of order `n`.
scipy.linalg.special_matrices.invhilbert

# Returns the inverse of the n x n Pascal matrix.
scipy.linalg.special_matrices.invpascal

# Kronecker product.
scipy.linalg.special_matrices.kron

# Create a Leslie matrix.
scipy.linalg.special_matrices.leslie

# Returns the n x n Pascal matrix.
scipy.linalg.special_matrices.pascal

# Construct a Toeplitz matrix.
scipy.linalg.special_matrices.toeplitz

# Python part of the warnings subsystem.
scipy.misc.common.warnings

# Python part of the warnings subsystem.
scipy.misc.doccer.warnings

scipy.ndimage._ctest.filter1d

scipy.ndimage._ctest.filter2d

scipy.ndimage._ctest.transform

scipy.ndimage._cytest.filter1d

scipy.ndimage._cytest.filter1d_capsule

scipy.ndimage._cytest.filter2d

scipy.ndimage._cytest.filter2d_capsule

scipy.ndimage._cytest.transform

scipy.ndimage._cytest.transform_capsule

scipy.ndimage._delegators.affine_transform_signature

# Get the array API compatible namespace for the arrays xs.
scipy.ndimage._delegators.array_namespace

scipy.ndimage._delegators.binary_closing_signature

scipy.ndimage._delegators.binary_dilation_signature

scipy.ndimage._delegators.binary_erosion_signature

scipy.ndimage._delegators.binary_fill_holes_signature

scipy.ndimage._delegators.binary_hit_or_miss_signature

scipy.ndimage._delegators.binary_opening_signature

scipy.ndimage._delegators.binary_propagation_signature

scipy.ndimage._delegators.black_tophat_signature

scipy.ndimage._delegators.center_of_mass_signature

scipy.ndimage._delegators.convolve1d_signature

scipy.ndimage._delegators.convolve_signature

scipy.ndimage._delegators.correlate1d_signature

scipy.ndimage._delegators.correlate_signature

scipy.ndimage._delegators.distance_transform_bf_signature

scipy.ndimage._delegators.distance_transform_cdt_signature

scipy.ndimage._delegators.distance_transform_edt_signature

scipy.ndimage._delegators.extrema_signature

scipy.ndimage._delegators.find_objects_signature

scipy.ndimage._delegators.fourier_ellipsoid_signature

scipy.ndimage._delegators.fourier_gaussian_signature

scipy.ndimage._delegators.fourier_shift_signature

scipy.ndimage._delegators.fourier_uniform_signature

scipy.ndimage._delegators.gaussian_filter1d_signature

scipy.ndimage._delegators.gaussian_filter_signature

scipy.ndimage._delegators.gaussian_gradient_magnitude_signature

scipy.ndimage._delegators.gaussian_laplace_signature

scipy.ndimage._delegators.generate_binary_structure_signature

scipy.ndimage._delegators.generic_filter1d_signature

scipy.ndimage._delegators.generic_filter_signature

scipy.ndimage._delegators.generic_gradient_magnitude_signature

scipy.ndimage._delegators.generic_laplace_signature

scipy.ndimage._delegators.geometric_transform_signature

scipy.ndimage._delegators.grey_closing_signature

scipy.ndimage._delegators.grey_dilation_signature

scipy.ndimage._delegators.grey_erosion_signature

scipy.ndimage._delegators.grey_opening_signature

scipy.ndimage._delegators.histogram_signature

scipy.ndimage._delegators.iterate_structure_signature

scipy.ndimage._delegators.label_signature

scipy.ndimage._delegators.labeled_comprehension_signature

scipy.ndimage._delegators.laplace_signature

scipy.ndimage._delegators.map_coordinates_signature

scipy.ndimage._delegators.maximum_filter1d_signature

scipy.ndimage._delegators.maximum_filter_signature

scipy.ndimage._delegators.maximum_position_signature

scipy.ndimage._delegators.maximum_signature

scipy.ndimage._delegators.mean_signature

scipy.ndimage._delegators.median_filter_signature

scipy.ndimage._delegators.median_signature

scipy.ndimage._delegators.minimum_filter1d_signature

scipy.ndimage._delegators.minimum_filter_signature

scipy.ndimage._delegators.minimum_position_signature

scipy.ndimage._delegators.minimum_signature

scipy.ndimage._delegators.morphological_gradient_signature

scipy.ndimage._delegators.morphological_laplace_signature

# NumPy
scipy.ndimage._delegators.np

scipy.ndimage._delegators.percentile_filter_signature

scipy.ndimage._delegators.prewitt_signature

scipy.ndimage._delegators.rank_filter_signature

scipy.ndimage._delegators.rotate_signature

scipy.ndimage._delegators.shift_signature

scipy.ndimage._delegators.sobel_signature

scipy.ndimage._delegators.spline_filter1d_signature

scipy.ndimage._delegators.spline_filter_signature

scipy.ndimage._delegators.standard_deviation_signature

scipy.ndimage._delegators.sum_labels_signature

scipy.ndimage._delegators.sum_signature

scipy.ndimage._delegators.uniform_filter1d_signature

scipy.ndimage._delegators.uniform_filter_signature

scipy.ndimage._delegators.value_indices_signature

scipy.ndimage._delegators.variance_signature

scipy.ndimage._delegators.vectorized_filter_signature

scipy.ndimage._delegators.watershed_ift_signature

scipy.ndimage._delegators.white_tophat_signature

scipy.ndimage._delegators.zoom_signature

# Multidimensional convolution.
scipy.ndimage._filters.convolve

# Calculate a 1-D convolution along the given axis.
scipy.ndimage._filters.convolve1d

# Multidimensional correlation.
scipy.ndimage._filters.correlate

# Calculate a 1-D correlation along the given axis.
scipy.ndimage._filters.correlate1d

# Multidimensional Gaussian filter.
scipy.ndimage._filters.gaussian_filter

# 1-D Gaussian filter.
scipy.ndimage._filters.gaussian_filter1d

# Multidimensional gradient magnitude using Gaussian derivatives.
scipy.ndimage._filters.gaussian_gradient_magnitude

# Multidimensional Laplace filter using Gaussian second derivatives.
scipy.ndimage._filters.gaussian_laplace

# Calculate a multidimensional filter using the given function.
scipy.ndimage._filters.generic_filter

# Calculate a 1-D filter along the given axis.
scipy.ndimage._filters.generic_filter1d

# Gradient magnitude using a provided gradient function.
scipy.ndimage._filters.generic_gradient_magnitude

# N-D Laplace filter using a provided second derivative function.
scipy.ndimage._filters.generic_laplace

# N-D Laplace filter based on approximate second derivatives.
scipy.ndimage._filters.laplace

# Calculate a multidimensional maximum filter.
scipy.ndimage._filters.maximum_filter

# Calculate a 1-D maximum filter along the given axis.
scipy.ndimage._filters.maximum_filter1d

# Calculate a multidimensional median filter.
scipy.ndimage._filters.median_filter

# Calculate a multidimensional minimum filter.
scipy.ndimage._filters.minimum_filter

# Calculate a 1-D minimum filter along the given axis.
scipy.ndimage._filters.minimum_filter1d

# Calculate a multidimensional percentile filter.
scipy.ndimage._filters.percentile_filter

# Calculate a Prewitt filter.
scipy.ndimage._filters.prewitt

# Calculate a multidimensional rank filter.
scipy.ndimage._filters.rank_filter

# Calculate a Sobel filter.
scipy.ndimage._filters.sobel

# Multidimensional uniform filter.
scipy.ndimage._filters.uniform_filter

# Calculate a 1-D uniform filter along the given axis.
scipy.ndimage._filters.uniform_filter1d

# Filter an array with a vectorized Python callable as the kernel
scipy.ndimage._filters.vectorized_filter

# Multidimensional ellipsoid Fourier filter.
scipy.ndimage._fourier.fourier_ellipsoid

# Multidimensional Gaussian fourier filter.
scipy.ndimage._fourier.fourier_gaussian

# Multidimensional Fourier shift filter.
scipy.ndimage._fourier.fourier_shift

# Multidimensional uniform fourier filter.
scipy.ndimage._fourier.fourier_uniform

# Apply an affine transformation.
scipy.ndimage._interpolation.affine_transform

# Apply an arbitrary geometric transform.
scipy.ndimage._interpolation.geometric_transform

# Map the input array to new coordinates by interpolation.
scipy.ndimage._interpolation.map_coordinates

# Rotate an array.
scipy.ndimage._interpolation.rotate

# Shift an array.
scipy.ndimage._interpolation.shift

# Multidimensional spline filter.
scipy.ndimage._interpolation.spline_filter

# Calculate a 1-D spline filter along the given axis.
scipy.ndimage._interpolation.spline_filter1d

# Zoom an array.
scipy.ndimage._interpolation.zoom

# Calculate the center of mass of the values of an array at labels.
scipy.ndimage._measurements.center_of_mass

# Calculate the minimums and maximums of the values of an array
scipy.ndimage._measurements.extrema

# Find objects in a labeled array.
scipy.ndimage._measurements.find_objects

# Calculate the histogram of the values of an array, optionally at labels.
scipy.ndimage._measurements.histogram

# Label features in an array.
scipy.ndimage._measurements.label

# Roughly equivalent to [func(input[labels == i]) for i in index].
scipy.ndimage._measurements.labeled_comprehension

# Calculate the maximum of the values of an array over labeled regions.
scipy.ndimage._measurements.maximum

# Find the positions of the maximums of the values of an array at labels.
scipy.ndimage._measurements.maximum_position

# Calculate the mean of the values of an array at labels.
scipy.ndimage._measurements.mean

# Calculate the median of the values of an array over labeled regions.
scipy.ndimage._measurements.median

# Calculate the minimum of the values of an array over labeled regions.
scipy.ndimage._measurements.minimum

# Find the positions of the minimums of the values of an array at labels.
scipy.ndimage._measurements.minimum_position

# Calculate the standard deviation of the values of an N-D image array,
scipy.ndimage._measurements.standard_deviation

# Calculate the sum of the values of the array.
scipy.ndimage._measurements.sum

# Calculate the sum of the values of the array.
scipy.ndimage._measurements.sum_labels

# Find indices of each distinct value in given array.
scipy.ndimage._measurements.value_indices

# Calculate the variance of the values of an N-D image array, optionally at
scipy.ndimage._measurements.variance

# Apply watershed from markers using image foresting transform algorithm.
scipy.ndimage._measurements.watershed_ift

# Multidimensional binary closing with the given structuring element.
scipy.ndimage._morphology.binary_closing

# Multidimensional binary dilation with the given structuring element.
scipy.ndimage._morphology.binary_dilation

# Multidimensional binary erosion with a given structuring element.
scipy.ndimage._morphology.binary_erosion

# Fill the holes in binary objects.
scipy.ndimage._morphology.binary_fill_holes

# Multidimensional binary hit-or-miss transform.
scipy.ndimage._morphology.binary_hit_or_miss

# Multidimensional binary opening with the given structuring element.
scipy.ndimage._morphology.binary_opening

# Multidimensional binary propagation with the given structuring element.
scipy.ndimage._morphology.binary_propagation

# Multidimensional black tophat filter.
scipy.ndimage._morphology.black_tophat

# Distance transform function by a brute force algorithm.
scipy.ndimage._morphology.distance_transform_bf

# Distance transform for chamfer type of transforms.
scipy.ndimage._morphology.distance_transform_cdt

# Exact Euclidean distance transform.
scipy.ndimage._morphology.distance_transform_edt

# Generate a binary structure for binary morphological operations.
scipy.ndimage._morphology.generate_binary_structure

# Multidimensional grayscale closing.
scipy.ndimage._morphology.grey_closing

# Calculate a greyscale dilation, using either a structuring element,
scipy.ndimage._morphology.grey_dilation

# Calculate a greyscale erosion, using either a structuring element,
scipy.ndimage._morphology.grey_erosion

# Multidimensional grayscale opening.
scipy.ndimage._morphology.grey_opening

# Iterate a structure by dilating it with itself.
scipy.ndimage._morphology.iterate_structure

# Multidimensional morphological gradient.
scipy.ndimage._morphology.morphological_gradient

# Multidimensional morphological laplace.
scipy.ndimage._morphology.morphological_laplace

# Multidimensional white tophat filter.
scipy.ndimage._morphology.white_tophat

scipy.ndimage._nd_image.binary_erosion

scipy.ndimage._nd_image.binary_erosion2

scipy.ndimage._nd_image.correlate

scipy.ndimage._nd_image.correlate1d

scipy.ndimage._nd_image.distance_transform_bf

scipy.ndimage._nd_image.distance_transform_op

scipy.ndimage._nd_image.euclidean_feature_transform

scipy.ndimage._nd_image.find_objects

scipy.ndimage._nd_image.fourier_filter

scipy.ndimage._nd_image.fourier_shift

scipy.ndimage._nd_image.generic_filter

scipy.ndimage._nd_image.generic_filter1d

scipy.ndimage._nd_image.geometric_transform

scipy.ndimage._nd_image.min_or_max_filter

scipy.ndimage._nd_image.min_or_max_filter1d

scipy.ndimage._nd_image.rank_filter

scipy.ndimage._nd_image.spline_filter1d

scipy.ndimage._nd_image.uniform_filter1d

scipy.ndimage._nd_image.value_indices

scipy.ndimage._nd_image.watershed_ift

scipy.ndimage._nd_image.zoom_shift

# Apply an affine transformation.
scipy.ndimage._ndimage_api.affine_transform

# Multidimensional binary closing with the given structuring element.
scipy.ndimage._ndimage_api.binary_closing

# Multidimensional binary dilation with the given structuring element.
scipy.ndimage._ndimage_api.binary_dilation

# Multidimensional binary erosion with a given structuring element.
scipy.ndimage._ndimage_api.binary_erosion

# Fill the holes in binary objects.
scipy.ndimage._ndimage_api.binary_fill_holes

# Multidimensional binary hit-or-miss transform.
scipy.ndimage._ndimage_api.binary_hit_or_miss

# Multidimensional binary opening with the given structuring element.
scipy.ndimage._ndimage_api.binary_opening

# Multidimensional binary propagation with the given structuring element.
scipy.ndimage._ndimage_api.binary_propagation

# Multidimensional black tophat filter.
scipy.ndimage._ndimage_api.black_tophat

# Calculate the center of mass of the values of an array at labels.
scipy.ndimage._ndimage_api.center_of_mass

# Multidimensional convolution.
scipy.ndimage._ndimage_api.convolve

# Calculate a 1-D convolution along the given axis.
scipy.ndimage._ndimage_api.convolve1d

# Multidimensional correlation.
scipy.ndimage._ndimage_api.correlate

# Calculate a 1-D correlation along the given axis.
scipy.ndimage._ndimage_api.correlate1d

# Distance transform function by a brute force algorithm.
scipy.ndimage._ndimage_api.distance_transform_bf

# Distance transform for chamfer type of transforms.
scipy.ndimage._ndimage_api.distance_transform_cdt

# Exact Euclidean distance transform.
scipy.ndimage._ndimage_api.distance_transform_edt

# Calculate the minimums and maximums of the values of an array
scipy.ndimage._ndimage_api.extrema

# Find objects in a labeled array.
scipy.ndimage._ndimage_api.find_objects

# Multidimensional ellipsoid Fourier filter.
scipy.ndimage._ndimage_api.fourier_ellipsoid

# Multidimensional Gaussian fourier filter.
scipy.ndimage._ndimage_api.fourier_gaussian

# Multidimensional Fourier shift filter.
scipy.ndimage._ndimage_api.fourier_shift

# Multidimensional uniform fourier filter.
scipy.ndimage._ndimage_api.fourier_uniform

# Multidimensional Gaussian filter.
scipy.ndimage._ndimage_api.gaussian_filter

# 1-D Gaussian filter.
scipy.ndimage._ndimage_api.gaussian_filter1d

# Multidimensional gradient magnitude using Gaussian derivatives.
scipy.ndimage._ndimage_api.gaussian_gradient_magnitude

# Multidimensional Laplace filter using Gaussian second derivatives.
scipy.ndimage._ndimage_api.gaussian_laplace

# Generate a binary structure for binary morphological operations.
scipy.ndimage._ndimage_api.generate_binary_structure

# Calculate a multidimensional filter using the given function.
scipy.ndimage._ndimage_api.generic_filter

# Calculate a 1-D filter along the given axis.
scipy.ndimage._ndimage_api.generic_filter1d

# Gradient magnitude using a provided gradient function.
scipy.ndimage._ndimage_api.generic_gradient_magnitude

# N-D Laplace filter using a provided second derivative function.
scipy.ndimage._ndimage_api.generic_laplace

# Apply an arbitrary geometric transform.
scipy.ndimage._ndimage_api.geometric_transform

# Multidimensional grayscale closing.
scipy.ndimage._ndimage_api.grey_closing

# Calculate a greyscale dilation, using either a structuring element,
scipy.ndimage._ndimage_api.grey_dilation

# Calculate a greyscale erosion, using either a structuring element,
scipy.ndimage._ndimage_api.grey_erosion

# Multidimensional grayscale opening.
scipy.ndimage._ndimage_api.grey_opening

# Calculate the histogram of the values of an array, optionally at labels.
scipy.ndimage._ndimage_api.histogram

# Iterate a structure by dilating it with itself.
scipy.ndimage._ndimage_api.iterate_structure

# Label features in an array.
scipy.ndimage._ndimage_api.label

# Roughly equivalent to [func(input[labels == i]) for i in index].
scipy.ndimage._ndimage_api.labeled_comprehension

# N-D Laplace filter based on approximate second derivatives.
scipy.ndimage._ndimage_api.laplace

# Map the input array to new coordinates by interpolation.
scipy.ndimage._ndimage_api.map_coordinates

# Calculate the maximum of the values of an array over labeled regions.
scipy.ndimage._ndimage_api.maximum

# Calculate a multidimensional maximum filter.
scipy.ndimage._ndimage_api.maximum_filter

# Calculate a 1-D maximum filter along the given axis.
scipy.ndimage._ndimage_api.maximum_filter1d

# Find the positions of the maximums of the values of an array at labels.
scipy.ndimage._ndimage_api.maximum_position

# Calculate the mean of the values of an array at labels.
scipy.ndimage._ndimage_api.mean

# Calculate the median of the values of an array over labeled regions.
scipy.ndimage._ndimage_api.median

# Calculate a multidimensional median filter.
scipy.ndimage._ndimage_api.median_filter

# Calculate the minimum of the values of an array over labeled regions.
scipy.ndimage._ndimage_api.minimum

# Calculate a multidimensional minimum filter.
scipy.ndimage._ndimage_api.minimum_filter

# Calculate a 1-D minimum filter along the given axis.
scipy.ndimage._ndimage_api.minimum_filter1d

# Find the positions of the minimums of the values of an array at labels.
scipy.ndimage._ndimage_api.minimum_position

# Multidimensional morphological gradient.
scipy.ndimage._ndimage_api.morphological_gradient

# Multidimensional morphological laplace.
scipy.ndimage._ndimage_api.morphological_laplace

# Calculate a multidimensional percentile filter.
scipy.ndimage._ndimage_api.percentile_filter

# Calculate a Prewitt filter.
scipy.ndimage._ndimage_api.prewitt

# Calculate a multidimensional rank filter.
scipy.ndimage._ndimage_api.rank_filter

# Rotate an array.
scipy.ndimage._ndimage_api.rotate

# Shift an array.
scipy.ndimage._ndimage_api.shift

# Calculate a Sobel filter.
scipy.ndimage._ndimage_api.sobel

# Multidimensional spline filter.
scipy.ndimage._ndimage_api.spline_filter

# Calculate a 1-D spline filter along the given axis.
scipy.ndimage._ndimage_api.spline_filter1d

# Calculate the standard deviation of the values of an N-D image array,
scipy.ndimage._ndimage_api.standard_deviation

# Calculate the sum of the values of the array.
scipy.ndimage._ndimage_api.sum

# Calculate the sum of the values of the array.
scipy.ndimage._ndimage_api.sum_labels

# Multidimensional uniform filter.
scipy.ndimage._ndimage_api.uniform_filter

# Calculate a 1-D uniform filter along the given axis.
scipy.ndimage._ndimage_api.uniform_filter1d

# Find indices of each distinct value in given array.
scipy.ndimage._ndimage_api.value_indices

# Calculate the variance of the values of an N-D image array, optionally at
scipy.ndimage._ndimage_api.variance

# Filter an array with a vectorized Python callable as the kernel
scipy.ndimage._ndimage_api.vectorized_filter

# Apply watershed from markers using image foresting transform algorithm.
scipy.ndimage._ndimage_api.watershed_ift

# Multidimensional white tophat filter.
scipy.ndimage._ndimage_api.white_tophat

# Zoom an array.
scipy.ndimage._ndimage_api.zoom

scipy.ndimage._ni_docstrings.docfiller

scipy.ndimage._ni_label.NeedMoreBits

scipy.ndimage._ni_label.get_nonzero_line

scipy.ndimage._ni_label.get_read_line

scipy.ndimage._ni_label.get_write_line

# NumPy
scipy.ndimage._ni_label.np

scipy.ndimage._ni_support.Iterable

# NumPy
scipy.ndimage._ni_support.np

# Operator interface.
scipy.ndimage._ni_support.operator

# Python part of the warnings subsystem.
scipy.ndimage._ni_support.warnings

# 1D rank filter
scipy.ndimage._rank_filter_1d.rank_filter

# Apply an affine transformation.
scipy.ndimage._support_alternative_backends.affine_transform

# Multidimensional binary closing with the given structuring element.
scipy.ndimage._support_alternative_backends.binary_closing

# Multidimensional binary dilation with the given structuring element.
scipy.ndimage._support_alternative_backends.binary_dilation

# Multidimensional binary erosion with a given structuring element.
scipy.ndimage._support_alternative_backends.binary_erosion

# Fill the holes in binary objects.
scipy.ndimage._support_alternative_backends.binary_fill_holes

# Multidimensional binary hit-or-miss transform.
scipy.ndimage._support_alternative_backends.binary_hit_or_miss

# Multidimensional binary opening with the given structuring element.
scipy.ndimage._support_alternative_backends.binary_opening

# Multidimensional binary propagation with the given structuring element.
scipy.ndimage._support_alternative_backends.binary_propagation

# Multidimensional black tophat filter.
scipy.ndimage._support_alternative_backends.black_tophat

# Calculate the center of mass of the values of an array at labels.
scipy.ndimage._support_alternative_backends.center_of_mass

# Multidimensional convolution.
scipy.ndimage._support_alternative_backends.convolve

# Calculate a 1-D convolution along the given axis.
scipy.ndimage._support_alternative_backends.convolve1d

# Multidimensional correlation.
scipy.ndimage._support_alternative_backends.correlate

# Calculate a 1-D correlation along the given axis.
scipy.ndimage._support_alternative_backends.correlate1d

# Distance transform function by a brute force algorithm.
scipy.ndimage._support_alternative_backends.distance_transform_bf

# Distance transform for chamfer type of transforms.
scipy.ndimage._support_alternative_backends.distance_transform_cdt

# Exact Euclidean distance transform.
scipy.ndimage._support_alternative_backends.distance_transform_edt

# Calculate the minimums and maximums of the values of an array
scipy.ndimage._support_alternative_backends.extrema

# Find objects in a labeled array.
scipy.ndimage._support_alternative_backends.find_objects

# Multidimensional ellipsoid Fourier filter.
scipy.ndimage._support_alternative_backends.fourier_ellipsoid

# Multidimensional Gaussian fourier filter.
scipy.ndimage._support_alternative_backends.fourier_gaussian

# Multidimensional Fourier shift filter.
scipy.ndimage._support_alternative_backends.fourier_shift

# Multidimensional uniform fourier filter.
scipy.ndimage._support_alternative_backends.fourier_uniform

# Multidimensional Gaussian filter.
scipy.ndimage._support_alternative_backends.gaussian_filter

# 1-D Gaussian filter.
scipy.ndimage._support_alternative_backends.gaussian_filter1d

# Multidimensional gradient magnitude using Gaussian derivatives.
scipy.ndimage._support_alternative_backends.gaussian_gradient_magnitude

# Multidimensional Laplace filter using Gaussian second derivatives.
scipy.ndimage._support_alternative_backends.gaussian_laplace

# Generate a binary structure for binary morphological operations.
scipy.ndimage._support_alternative_backends.generate_binary_structure

# Calculate a multidimensional filter using the given function.
scipy.ndimage._support_alternative_backends.generic_filter

# Calculate a 1-D filter along the given axis.
scipy.ndimage._support_alternative_backends.generic_filter1d

# Gradient magnitude using a provided gradient function.
scipy.ndimage._support_alternative_backends.generic_gradient_magnitude

# N-D Laplace filter using a provided second derivative function.
scipy.ndimage._support_alternative_backends.generic_laplace

# Apply an arbitrary geometric transform.
scipy.ndimage._support_alternative_backends.geometric_transform

# Multidimensional grayscale closing.
scipy.ndimage._support_alternative_backends.grey_closing

# Calculate a greyscale dilation, using either a structuring element,
scipy.ndimage._support_alternative_backends.grey_dilation

# Calculate a greyscale erosion, using either a structuring element,
scipy.ndimage._support_alternative_backends.grey_erosion

# Multidimensional grayscale opening.
scipy.ndimage._support_alternative_backends.grey_opening

# Calculate the histogram of the values of an array, optionally at labels.
scipy.ndimage._support_alternative_backends.histogram

# Iterate a structure by dilating it with itself.
scipy.ndimage._support_alternative_backends.iterate_structure

# Label features in an array.
scipy.ndimage._support_alternative_backends.label

# Roughly equivalent to [func(input[labels == i]) for i in index].
scipy.ndimage._support_alternative_backends.labeled_comprehension

# N-D Laplace filter based on approximate second derivatives.
scipy.ndimage._support_alternative_backends.laplace

# Map the input array to new coordinates by interpolation.
scipy.ndimage._support_alternative_backends.map_coordinates

# Calculate the maximum of the values of an array over labeled regions.
scipy.ndimage._support_alternative_backends.maximum

# Calculate a multidimensional maximum filter.
scipy.ndimage._support_alternative_backends.maximum_filter

# Calculate a 1-D maximum filter along the given axis.
scipy.ndimage._support_alternative_backends.maximum_filter1d

# Find the positions of the maximums of the values of an array at labels.
scipy.ndimage._support_alternative_backends.maximum_position

# Calculate the mean of the values of an array at labels.
scipy.ndimage._support_alternative_backends.mean

# Calculate the median of the values of an array over labeled regions.
scipy.ndimage._support_alternative_backends.median

# Calculate a multidimensional median filter.
scipy.ndimage._support_alternative_backends.median_filter

# Calculate the minimum of the values of an array over labeled regions.
scipy.ndimage._support_alternative_backends.minimum

# Calculate a multidimensional minimum filter.
scipy.ndimage._support_alternative_backends.minimum_filter

# Calculate a 1-D minimum filter along the given axis.
scipy.ndimage._support_alternative_backends.minimum_filter1d

# Find the positions of the minimums of the values of an array at labels.
scipy.ndimage._support_alternative_backends.minimum_position

# Multidimensional morphological gradient.
scipy.ndimage._support_alternative_backends.morphological_gradient

# Multidimensional morphological laplace.
scipy.ndimage._support_alternative_backends.morphological_laplace

# Calculate a multidimensional percentile filter.
scipy.ndimage._support_alternative_backends.percentile_filter

# Calculate a Prewitt filter.
scipy.ndimage._support_alternative_backends.prewitt

# Calculate a multidimensional rank filter.
scipy.ndimage._support_alternative_backends.rank_filter

# Rotate an array.
scipy.ndimage._support_alternative_backends.rotate

# Shift an array.
scipy.ndimage._support_alternative_backends.shift

# Calculate a Sobel filter.
scipy.ndimage._support_alternative_backends.sobel

# Multidimensional spline filter.
scipy.ndimage._support_alternative_backends.spline_filter

# Calculate a 1-D spline filter along the given axis.
scipy.ndimage._support_alternative_backends.spline_filter1d

# Calculate the standard deviation of the values of an N-D image array,
scipy.ndimage._support_alternative_backends.standard_deviation

# Calculate the sum of the values of the array.
scipy.ndimage._support_alternative_backends.sum

# Calculate the sum of the values of the array.
scipy.ndimage._support_alternative_backends.sum_labels

# Multidimensional uniform filter.
scipy.ndimage._support_alternative_backends.uniform_filter

# Calculate a 1-D uniform filter along the given axis.
scipy.ndimage._support_alternative_backends.uniform_filter1d

# Find indices of each distinct value in given array.
scipy.ndimage._support_alternative_backends.value_indices

# Calculate the variance of the values of an N-D image array, optionally at
scipy.ndimage._support_alternative_backends.variance

# Filter an array with a vectorized Python callable as the kernel
scipy.ndimage._support_alternative_backends.vectorized_filter

# Apply watershed from markers using image foresting transform algorithm.
scipy.ndimage._support_alternative_backends.watershed_ift

# Multidimensional white tophat filter.
scipy.ndimage._support_alternative_backends.white_tophat

# Zoom an array.
scipy.ndimage._support_alternative_backends.zoom

# Multidimensional convolution.
scipy.ndimage.filters.convolve

# Calculate a 1-D convolution along the given axis.
scipy.ndimage.filters.convolve1d

# Multidimensional correlation.
scipy.ndimage.filters.correlate

# Calculate a 1-D correlation along the given axis.
scipy.ndimage.filters.correlate1d

# Multidimensional Gaussian filter.
scipy.ndimage.filters.gaussian_filter

# 1-D Gaussian filter.
scipy.ndimage.filters.gaussian_filter1d

# Multidimensional gradient magnitude using Gaussian derivatives.
scipy.ndimage.filters.gaussian_gradient_magnitude

# Multidimensional Laplace filter using Gaussian second derivatives.
scipy.ndimage.filters.gaussian_laplace

# Calculate a multidimensional filter using the given function.
scipy.ndimage.filters.generic_filter

# Calculate a 1-D filter along the given axis.
scipy.ndimage.filters.generic_filter1d

# Gradient magnitude using a provided gradient function.
scipy.ndimage.filters.generic_gradient_magnitude

# N-D Laplace filter using a provided second derivative function.
scipy.ndimage.filters.generic_laplace

# N-D Laplace filter based on approximate second derivatives.
scipy.ndimage.filters.laplace

# Calculate a multidimensional maximum filter.
scipy.ndimage.filters.maximum_filter

# Calculate a 1-D maximum filter along the given axis.
scipy.ndimage.filters.maximum_filter1d

# Calculate a multidimensional median filter.
scipy.ndimage.filters.median_filter

# Calculate a multidimensional minimum filter.
scipy.ndimage.filters.minimum_filter

# Calculate a 1-D minimum filter along the given axis.
scipy.ndimage.filters.minimum_filter1d

# Calculate a multidimensional percentile filter.
scipy.ndimage.filters.percentile_filter

# Calculate a Prewitt filter.
scipy.ndimage.filters.prewitt

# Calculate a multidimensional rank filter.
scipy.ndimage.filters.rank_filter

# Calculate a Sobel filter.
scipy.ndimage.filters.sobel

# Multidimensional uniform filter.
scipy.ndimage.filters.uniform_filter

# Calculate a 1-D uniform filter along the given axis.
scipy.ndimage.filters.uniform_filter1d

# Multidimensional ellipsoid Fourier filter.
scipy.ndimage.fourier.fourier_ellipsoid

# Multidimensional Gaussian fourier filter.
scipy.ndimage.fourier.fourier_gaussian

# Multidimensional Fourier shift filter.
scipy.ndimage.fourier.fourier_shift

# Multidimensional uniform fourier filter.
scipy.ndimage.fourier.fourier_uniform

# Apply an affine transformation.
scipy.ndimage.interpolation.affine_transform

# Apply an arbitrary geometric transform.
scipy.ndimage.interpolation.geometric_transform

# Map the input array to new coordinates by interpolation.
scipy.ndimage.interpolation.map_coordinates

# Rotate an array.
scipy.ndimage.interpolation.rotate

# Shift an array.
scipy.ndimage.interpolation.shift

# Multidimensional spline filter.
scipy.ndimage.interpolation.spline_filter

# Calculate a 1-D spline filter along the given axis.
scipy.ndimage.interpolation.spline_filter1d

# Zoom an array.
scipy.ndimage.interpolation.zoom

# Calculate the center of mass of the values of an array at labels.
scipy.ndimage.measurements.center_of_mass

# Calculate the minimums and maximums of the values of an array
scipy.ndimage.measurements.extrema

# Find objects in a labeled array.
scipy.ndimage.measurements.find_objects

# Calculate the histogram of the values of an array, optionally at labels.
scipy.ndimage.measurements.histogram

# Label features in an array.
scipy.ndimage.measurements.label

# Roughly equivalent to [func(input[labels == i]) for i in index].
scipy.ndimage.measurements.labeled_comprehension

# Calculate the maximum of the values of an array over labeled regions.
scipy.ndimage.measurements.maximum

# Find the positions of the maximums of the values of an array at labels.
scipy.ndimage.measurements.maximum_position

# Calculate the mean of the values of an array at labels.
scipy.ndimage.measurements.mean

# Calculate the median of the values of an array over labeled regions.
scipy.ndimage.measurements.median

# Calculate the minimum of the values of an array over labeled regions.
scipy.ndimage.measurements.minimum

# Find the positions of the minimums of the values of an array at labels.
scipy.ndimage.measurements.minimum_position

# Calculate the standard deviation of the values of an N-D image array,
scipy.ndimage.measurements.standard_deviation

# Calculate the sum of the values of the array.
scipy.ndimage.measurements.sum

# Calculate the sum of the values of the array.
scipy.ndimage.measurements.sum_labels

# Calculate the variance of the values of an N-D image array, optionally at
scipy.ndimage.measurements.variance

# Apply watershed from markers using image foresting transform algorithm.
scipy.ndimage.measurements.watershed_ift

# Multidimensional binary closing with the given structuring element.
scipy.ndimage.morphology.binary_closing

# Multidimensional binary dilation with the given structuring element.
scipy.ndimage.morphology.binary_dilation

# Multidimensional binary erosion with a given structuring element.
scipy.ndimage.morphology.binary_erosion

# Fill the holes in binary objects.
scipy.ndimage.morphology.binary_fill_holes

# Multidimensional binary hit-or-miss transform.
scipy.ndimage.morphology.binary_hit_or_miss

# Multidimensional binary opening with the given structuring element.
scipy.ndimage.morphology.binary_opening

# Multidimensional binary propagation with the given structuring element.
scipy.ndimage.morphology.binary_propagation

# Multidimensional black tophat filter.
scipy.ndimage.morphology.black_tophat

# Distance transform function by a brute force algorithm.
scipy.ndimage.morphology.distance_transform_bf

# Distance transform for chamfer type of transforms.
scipy.ndimage.morphology.distance_transform_cdt

# Exact Euclidean distance transform.
scipy.ndimage.morphology.distance_transform_edt

# Generate a binary structure for binary morphological operations.
scipy.ndimage.morphology.generate_binary_structure

# Multidimensional grayscale closing.
scipy.ndimage.morphology.grey_closing

# Calculate a greyscale dilation, using either a structuring element,
scipy.ndimage.morphology.grey_dilation

# Calculate a greyscale erosion, using either a structuring element,
scipy.ndimage.morphology.grey_erosion

# Multidimensional grayscale opening.
scipy.ndimage.morphology.grey_opening

# Iterate a structure by dilating it with itself.
scipy.ndimage.morphology.iterate_structure

# Multidimensional morphological gradient.
scipy.ndimage.morphology.morphological_gradient

# Multidimensional morphological laplace.
scipy.ndimage.morphology.morphological_laplace

# Multidimensional white tophat filter.
scipy.ndimage.morphology.white_tophat

# odr(fcn, beta0, y, x, we=None, wd=None, fjacb=None, fjacd=None, extra_args=None,
scipy.odr.__odrpack.odr

# Add documentation to an existing object, typically one defined in C
scipy.odr._add_newdocs.add_newdoc

# The Model class stores information about the function you wish to fit.
scipy.odr._models.Model

# Exponential model
scipy.odr._models.exponential

# Arbitrary-dimensional linear model
scipy.odr._models.multilinear

# Factory function for a general polynomial model.
scipy.odr._models.polynomial

# Quadratic model
scipy.odr._models.quadratic

# Univariate linear model
scipy.odr._models.unilinear

# The data to fit.
scipy.odr._odrpack.Data

# The Model class stores information about the function you wish to fit.
scipy.odr._odrpack.Model

# The ODR class gathers all information and coordinates the running of the
scipy.odr._odrpack.ODR

# Exception indicating an error in fitting.
scipy.odr._odrpack.OdrError

# Exception stopping fitting.
scipy.odr._odrpack.OdrStop

# Warning indicating that the data passed into
scipy.odr._odrpack.OdrWarning

# The Output class stores the output of an ODR run.
scipy.odr._odrpack.Output

# The data, with weightings as actual standard deviations and/or
scipy.odr._odrpack.RealData

# odr(fcn, beta0, y, x, we=None, wd=None, fjacb=None, fjacd=None, extra_args=None,
scipy.odr._odrpack.odr

# Exception indicating an error in fitting.
scipy.odr._odrpack.odr_error

# Exception stopping fitting.
scipy.odr._odrpack.odr_stop

# The Model class stores information about the function you wish to fit.
scipy.odr.models.Model

# Exponential model
scipy.odr.models.exponential

# Arbitrary-dimensional linear model
scipy.odr.models.multilinear

# Factory function for a general polynomial model.
scipy.odr.models.polynomial

# Quadratic model
scipy.odr.models.quadratic

# Univariate linear model
scipy.odr.models.unilinear

# The data to fit.
scipy.odr.odrpack.Data

# The Model class stores information about the function you wish to fit.
scipy.odr.odrpack.Model

# The ODR class gathers all information and coordinates the running of the
scipy.odr.odrpack.ODR

# Exception indicating an error in fitting.
scipy.odr.odrpack.OdrError

# Exception stopping fitting.
scipy.odr.odrpack.OdrStop

# Warning indicating that the data passed into
scipy.odr.odrpack.OdrWarning

# The Output class stores the output of an ODR run.
scipy.odr.odrpack.Output

# The data, with weightings as actual standard deviations and/or
scipy.odr.odrpack.RealData

# odr(fcn, beta0, y, x, we=None, wd=None, fjacb=None, fjacd=None, extra_args=None,
scipy.odr.odrpack.odr

# Exception indicating an error in fitting.
scipy.odr.odrpack.odr_error

# Exception stopping fitting.
scipy.odr.odrpack.odr_stop

# Find the global minimum of a function using the basin-hopping algorithm.
scipy.optimize._basinhopping.basinhopping

# Represents PLU factorization with Golub rank-one updates from
scipy.optimize._bglu_dense.BGLU

# Represents PLU factorization of a basis matrix with naive rank-one updates
scipy.optimize._bglu_dense.LU

# Get the array API compatible namespace for the arrays xs.
scipy.optimize._bracket.array_namespace

scipy.optimize._bracket.eim

# NumPy
scipy.optimize._bracket.np

# Promotes elements of *args to result dtype, ignoring `None`s.
scipy.optimize._bracket.xp_promote

scipy.optimize._bracket.xp_ravel

scipy.optimize._chandrupatla.eim

# This module provides access to the mathematical functions
scipy.optimize._chandrupatla.math

# NumPy
scipy.optimize._chandrupatla.np

# Copies an array.
scipy.optimize._chandrupatla.xp_copy

# Minimize a function using the Constrained Optimization By Linear
scipy.optimize._cobyla_py.fmin_cobyla

# A lock object is a synchronization primitive.  To create a lock,
scipy.optimize._cobyqa_py.COBYQA_LOCK

# A lock object is a synchronization primitive.  To create a lock,
scipy.optimize._cobyqa_py.Lock

# NumPy
scipy.optimize._cobyqa_py.np

# Broyden-Fletcher-Goldfarb-Shanno (BFGS) Hessian update strategy.
scipy.optimize._constraints.BFGS

# Bounds constraint on the variables.
scipy.optimize._constraints.Bounds

# Identity vector function and its derivatives.
scipy.optimize._constraints.IdentityVectorFunction

# Linear constraint on the variables.
scipy.optimize._constraints.LinearConstraint

# Linear vector function and its derivatives.
scipy.optimize._constraints.LinearVectorFunction

# Nonlinear constraint on the variables.
scipy.optimize._constraints.NonlinearConstraint

# General warning for :mod:`scipy.optimize`.
scipy.optimize._constraints.OptimizeWarning

# Constraint prepared from a user defined constraint.
scipy.optimize._constraints.PreparedConstraint

# Vector function and its derivatives.
scipy.optimize._constraints.VectorFunction

# A context manager that copies and restores the warnings filter upon
scipy.optimize._constraints.catch_warnings

# Insert an entry into the list of warnings filters (at the front).
scipy.optimize._constraints.filterwarnings

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._constraints.issparse

# Convert the new bounds representation to the old one.
scipy.optimize._constraints.new_bounds_to_old

# Converts new-style constraint objects to old-style constraint dictionaries.
scipy.optimize._constraints.new_constraint_to_old

# NumPy
scipy.optimize._constraints.np

# Convert the old bounds representation to the new one.
scipy.optimize._constraints.old_bound_to_new

# Converts old-style constraint dictionaries to new-style constraint objects.
scipy.optimize._constraints.old_constraint_to_new

# Insert a simple entry into the list of warnings filters (at the front).
scipy.optimize._constraints.simplefilter

# Remove bounds which are not asked to be kept feasible.
scipy.optimize._constraints.strict_bounds

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._constraints.warn

# Parameters
scipy.optimize._dcsrch.DCSRCH

# Subroutine dcstep
scipy.optimize._dcsrch.dcstep

# NumPy
scipy.optimize._dcsrch.np

# Built-in immutable sequence.
scipy.optimize._differentiable_functions.FD_METHODS

# Interface for implementing Hessian update strategies.
scipy.optimize._differentiable_functions.HessianUpdateStrategy

# Identity vector function and its derivatives.
scipy.optimize._differentiable_functions.IdentityVectorFunction

# Common interface for performing matrix vector products
scipy.optimize._differentiable_functions.LinearOperator

# Linear vector function and its derivatives.
scipy.optimize._differentiable_functions.LinearVectorFunction

# Scalar function and its derivatives.
scipy.optimize._differentiable_functions.ScalarFunction

# Vector function and its derivatives.
scipy.optimize._differentiable_functions.VectorFunction

# Compute finite difference approximation of the derivatives of a
scipy.optimize._differentiable_functions.approx_derivative

# Get the array API compatible namespace for the arrays xs.
scipy.optimize._differentiable_functions.array_namespace

# Group columns of a 2-D matrix for sparse finite differencing [1]_.
scipy.optimize._differentiable_functions.group_columns

# Returns a new subclass of tuple with named fields.
scipy.optimize._differentiable_functions.namedtuple

# NumPy
scipy.optimize._differentiable_functions.np

# ===================================
scipy.optimize._differentiable_functions.sps

# Copies an array.
scipy.optimize._differentiable_functions.xp_copy

# Extra array functions built on top of the array API standard.
scipy.optimize._differentiable_functions.xpx

# Finds the global minimum of a multivariate function.
scipy.optimize._differentialevolution.differential_evolution

# DIRECT Optimization Algorithm
scipy.optimize._direct.direct

# Finds the global minimum of a function using the
scipy.optimize._direct_py.direct

# Find the global minimum of a function using Dual Annealing.
scipy.optimize._dual_annealing.dual_annealing

# Bracket the minimum of a unimodal, real-valued function of a real variable.
scipy.optimize._elementwise.bracket_minimum

# Bracket the root of a monotonic, real-valued function of a real variable.
scipy.optimize._elementwise.bracket_root

# Find the minimum of an unimodal, real-valued function of a real variable.
scipy.optimize._elementwise.find_minimum

# Find the root of a monotonic, real-valued function of a real variable.
scipy.optimize._elementwise.find_root

# Supported prototypes:
scipy.optimize._group_columns.group_dense

# Supported prototypes:
scipy.optimize._group_columns.group_sparse

# Broyden-Fletcher-Goldfarb-Shanno (BFGS) Hessian update strategy.
scipy.optimize._hessian_update_strategy.BFGS

# Interface for implementing Hessian update strategies.
scipy.optimize._hessian_update_strategy.HessianUpdateStrategy

# Symmetric-rank-1 Hessian update strategy.
scipy.optimize._hessian_update_strategy.SR1

# Members:
scipy.optimize._highspy._core.BasisValidity

# int([x]) -> integer
scipy.optimize._highspy._core.HIGHS_VERSION_MAJOR

# int([x]) -> integer
scipy.optimize._highspy._core.HIGHS_VERSION_MINOR

# int([x]) -> integer
scipy.optimize._highspy._core.HIGHS_VERSION_PATCH

# Members:
scipy.optimize._highspy._core.HessianFormat

scipy.optimize._highspy._core.HighsBasis

# Members:
scipy.optimize._highspy._core.HighsBasisStatus

# Members:
scipy.optimize._highspy._core.HighsDebugLevel

scipy.optimize._highspy._core.HighsHessian

scipy.optimize._highspy._core.HighsIis

scipy.optimize._highspy._core.HighsIisInfo

scipy.optimize._highspy._core.HighsInfo

# Members:
scipy.optimize._highspy._core.HighsInfoType

# Members:
scipy.optimize._highspy._core.HighsLogType

scipy.optimize._highspy._core.HighsLp

scipy.optimize._highspy._core.HighsLpMods

scipy.optimize._highspy._core.HighsModel

# Members:
scipy.optimize._highspy._core.HighsModelStatus

scipy.optimize._highspy._core.HighsObjectiveSolution

# Members:
scipy.optimize._highspy._core.HighsOptionType

scipy.optimize._highspy._core.HighsOptions

# Members:
scipy.optimize._highspy._core.HighsPresolveStatus

scipy.optimize._highspy._core.HighsRanging

scipy.optimize._highspy._core.HighsRangingRecord

scipy.optimize._highspy._core.HighsScale

scipy.optimize._highspy._core.HighsSolution

scipy.optimize._highspy._core.HighsSparseMatrix

# Members:
scipy.optimize._highspy._core.HighsStatus

# Members:
scipy.optimize._highspy._core.HighsVarType

# Members:
scipy.optimize._highspy._core.IisBoundStatus

# Members:
scipy.optimize._highspy._core.IisStrategy

# Members:
scipy.optimize._highspy._core.MatrixFormat

# Members:
scipy.optimize._highspy._core.ObjSense

# Members:
scipy.optimize._highspy._core.SolutionStatus

# Callback interface submodule
scipy.optimize._highspy._core.cb

# Members:
scipy.optimize._highspy._core.kBasisValidityInvalid

# Members:
scipy.optimize._highspy._core.kBasisValidityValid

# Members:
scipy.optimize._highspy._core.kHighsDebugLevelCheap

# Members:
scipy.optimize._highspy._core.kHighsDebugLevelCostly

# Members:
scipy.optimize._highspy._core.kHighsDebugLevelExpensive

# Members:
scipy.optimize._highspy._core.kHighsDebugLevelMax

# Members:
scipy.optimize._highspy._core.kHighsDebugLevelMin

# Members:
scipy.optimize._highspy._core.kHighsDebugLevelNone

# int([x]) -> integer
scipy.optimize._highspy._core.kHighsIInf

# Convert a string or number to a floating-point number, if possible.
scipy.optimize._highspy._core.kHighsInf

# Members:
scipy.optimize._highspy._core.kIisBoundStatusBoxed

# Members:
scipy.optimize._highspy._core.kIisBoundStatusDropped

# Members:
scipy.optimize._highspy._core.kIisBoundStatusFree

# Members:
scipy.optimize._highspy._core.kIisBoundStatusLower

# Members:
scipy.optimize._highspy._core.kIisBoundStatusNull

# Members:
scipy.optimize._highspy._core.kIisBoundStatusUpper

# Members:
scipy.optimize._highspy._core.kIisStrategyFromLpColPriority

# Members:
scipy.optimize._highspy._core.kIisStrategyFromLpRowPriority

# Members:
scipy.optimize._highspy._core.kIisStrategyMax

# Members:
scipy.optimize._highspy._core.kIisStrategyMin

# Members:
scipy.optimize._highspy._core.kSolutionStatusFeasible

# Members:
scipy.optimize._highspy._core.kSolutionStatusInfeasible

# Members:
scipy.optimize._highspy._core.kSolutionStatusNone

scipy.optimize._highspy._core.readonly_ptr_wrapper_double

# Submodule for simplex constants
scipy.optimize._highspy._core.simplex_constants

scipy.optimize._highspy._highs_options.HighsOptionsManager

# General warning for :mod:`scipy.optimize`.
scipy.optimize._highspy._highs_wrapper.OptimizeWarning

scipy.optimize._highspy._highs_wrapper.check_option

scipy.optimize._highspy._highs_wrapper.hopt

# NumPy
scipy.optimize._highspy._highs_wrapper.np

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._highspy._highs_wrapper.warn

# Nonparametric isotonic regression.
scipy.optimize._isotonic.isotonic_regression

scipy.optimize._lbfgsb.error

# setulb(m,x,l,u,nbd,f,g,factr,pgtol,wa,iwa,task,lsave,isave,dsave,maxls,ln_task)
scipy.optimize._lbfgsb.setulb

# Linear operator for the L-BFGS approximate inverse Hessian.
scipy.optimize._lbfgsb_py.LbfgsInvHessProduct

# Minimize a function func using the L-BFGS-B algorithm.
scipy.optimize._lbfgsb_py.fmin_l_bfgs_b

scipy.optimize._linesearch.LineSearchWarning

# Minimize over alpha, the function ``f(xk+alpha pk)``.
scipy.optimize._linesearch.line_search_armijo

# As `scalar_search_wolfe1` but do a line search to direction `pk`
scipy.optimize._linesearch.line_search_wolfe1

# Find alpha that satisfies strong Wolfe conditions.
scipy.optimize._linesearch.line_search_wolfe2

# Scalar function search for alpha that satisfies strong Wolfe conditions
scipy.optimize._linesearch.scalar_search_wolfe1

# Find alpha that satisfies strong Wolfe conditions.
scipy.optimize._linesearch.scalar_search_wolfe2

# Linear programming: minimize a linear objective function subject to linear
scipy.optimize._linprog.linprog

# A sample callback function demonstrating the linprog callback interface.
scipy.optimize._linprog.linprog_terse_callback

# A sample callback function demonstrating the linprog callback interface.
scipy.optimize._linprog.linprog_verbose_callback

# Members:
scipy.optimize._linprog_highs.HighsDebugLevel

# Members:
scipy.optimize._linprog_highs.HighsModelStatus

# Members:
scipy.optimize._linprog_highs.ObjSense

# Represents the optimization result.
scipy.optimize._linprog_highs.OptimizeResult

# General warning for :mod:`scipy.optimize`.
scipy.optimize._linprog_highs.OptimizeWarning

# Compressed Sparse Column array.
scipy.optimize._linprog_highs.csc_array

# Get useful information from live Python objects.
scipy.optimize._linprog_highs.inspect

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._linprog_highs.issparse

# Convert a string or number to a floating-point number, if possible.
scipy.optimize._linprog_highs.kHighsInf

# NumPy
scipy.optimize._linprog_highs.np

# Submodule for simplex constants
scipy.optimize._linprog_highs.s_c

# Stack sparse arrays vertically (row wise)
scipy.optimize._linprog_highs.vstack

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._linprog_highs.warn

# Generic Python-exception-derived object raised by linalg functions.
scipy.optimize._linprog_ip.LinAlgError

# Represents the optimization result.
scipy.optimize._linprog_ip.OptimizeResult

# General warning for :mod:`scipy.optimize`.
scipy.optimize._linprog_ip.OptimizeWarning

# Returns True when the argument is true, False otherwise.
scipy.optimize._linprog_ip.has_cholmod

# Returns True when the argument is true, False otherwise.
scipy.optimize._linprog_ip.has_umfpack

# NumPy
scipy.optimize._linprog_ip.np

# SciPy: A scientific computing package for Python
scipy.optimize._linprog_ip.sp

# ===================================
scipy.optimize._linprog_ip.sps

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._linprog_ip.warn

# Represents PLU factorization with Golub rank-one updates from
scipy.optimize._linprog_rs.BGLU

# Represents PLU factorization of a basis matrix with naive rank-one updates
scipy.optimize._linprog_rs.LU

# Generic Python-exception-derived object raised by linalg functions.
scipy.optimize._linprog_rs.LinAlgError

# Represents the optimization result.
scipy.optimize._linprog_rs.OptimizeResult

# NumPy
scipy.optimize._linprog_rs.np

# Solve the equation ``a @ x = b`` for  ``x``,
scipy.optimize._linprog_rs.solve

# Represents the optimization result.
scipy.optimize._linprog_simplex.OptimizeResult

# General warning for :mod:`scipy.optimize`.
scipy.optimize._linprog_simplex.OptimizeWarning

# NumPy
scipy.optimize._linprog_simplex.np

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._linprog_simplex.warn

# General warning for :mod:`scipy.optimize`.
scipy.optimize._linprog_util.OptimizeWarning

# Returns a new subclass of tuple with named fields.
scipy.optimize._linprog_util.namedtuple

# NumPy
scipy.optimize._linprog_util.np

# ===================================
scipy.optimize._linprog_util.sps

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._linprog_util.warn

# Solve the linear sum assignment problem.
scipy.optimize._lsap.linear_sum_assignment

# Represents the optimization result.
scipy.optimize._lsq.bvls.OptimizeResult

scipy.optimize._lsq.bvls.bvls

# Compute the maximum violation of KKT conditions.
scipy.optimize._lsq.bvls.compute_kkt_optimality

# Return the least-squares solution to a linear matrix equation.
scipy.optimize._lsq.bvls.lstsq

# Matrix or vector norm.
scipy.optimize._lsq.bvls.norm

# NumPy
scipy.optimize._lsq.bvls.np

scipy.optimize._lsq.bvls.print_header_linear

scipy.optimize._lsq.bvls.print_iteration_linear

# Compute Coleman-Li scaling vector and its derivatives.
scipy.optimize._lsq.common.CL_scaling_vector

# Double-precision floating-point number type, compatible with Python
scipy.optimize._lsq.common.EPS

# Generic Python-exception-derived object raised by linalg functions.
scipy.optimize._lsq.common.LinAlgError

# Common interface for performing matrix vector products
scipy.optimize._lsq.common.LinearOperator

# Return A as a LinearOperator.
scipy.optimize._lsq.common.aslinearoperator

# Parameterize a multivariate quadratic function along a line.
scipy.optimize._lsq.common.build_quadratic_1d

# Check termination condition for nonlinear least squares.
scipy.optimize._lsq.common.check_termination

# Compute the Cholesky decomposition of a matrix, to use in cho_solve
scipy.optimize._lsq.common.cho_factor

# Solve the linear equations A x = b, given the Cholesky factorization of A.
scipy.optimize._lsq.common.cho_solve

# Compute gradient of the least-squares cost function.
scipy.optimize._lsq.common.compute_grad

# Compute variables scale based on the Jacobian matrix.
scipy.optimize._lsq.common.compute_jac_scale

# Return a float with the magnitude (absolute value) of x but the sign of y.
scipy.optimize._lsq.common.copysign

# Compute values of a quadratic function arising in least squares.
scipy.optimize._lsq.common.evaluate_quadratic

# Determine which constraints are active in a given point.
scipy.optimize._lsq.common.find_active_constraints

# Check if a point lies within bounds.
scipy.optimize._lsq.common.in_bounds

# Find the intersection of a line with the boundary of a trust region.
scipy.optimize._lsq.common.intersect_trust_region

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._lsq.common.issparse

# Return diag(d) J as LinearOperator.
scipy.optimize._lsq.common.left_multiplied_operator

# Compute diag(d) J.
scipy.optimize._lsq.common.left_multiply

# Shift a point to the interior of a feasible region.
scipy.optimize._lsq.common.make_strictly_feasible

# Minimize a 1-D quadratic function subject to bounds.
scipy.optimize._lsq.common.minimize_quadratic_1d

# Matrix or vector norm.
scipy.optimize._lsq.common.norm

# NumPy
scipy.optimize._lsq.common.np

scipy.optimize._lsq.common.print_header_linear

scipy.optimize._lsq.common.print_header_nonlinear

scipy.optimize._lsq.common.print_iteration_linear

scipy.optimize._lsq.common.print_iteration_nonlinear

# Compute reflective transformation and its gradient.
scipy.optimize._lsq.common.reflective_transformation

# Return a matrix arising in regularized least squares as LinearOperator.
scipy.optimize._lsq.common.regularized_lsq_operator

# Return J diag(d) as LinearOperator.
scipy.optimize._lsq.common.right_multiplied_operator

# Compute J diag(d).
scipy.optimize._lsq.common.right_multiply

# Scale Jacobian and residuals for a robust loss function.
scipy.optimize._lsq.common.scale_for_robust_loss_function

# Solve a trust-region problem arising in least-squares minimization.
scipy.optimize._lsq.common.solve_lsq_trust_region

# Solve a general trust-region problem in 2 dimensions.
scipy.optimize._lsq.common.solve_trust_region_2d

# Compute a min_step size required to reach a bound.
scipy.optimize._lsq.common.step_size_to_bound

# Update the radius of a trust region based on the cost reduction.
scipy.optimize._lsq.common.update_tr_radius

# Common interface for performing matrix vector products
scipy.optimize._lsq.dogbox.LinearOperator

# Represents the optimization result.
scipy.optimize._lsq.dogbox.OptimizeResult

# Return A as a LinearOperator.
scipy.optimize._lsq.dogbox.aslinearoperator

# Parameterize a multivariate quadratic function along a line.
scipy.optimize._lsq.dogbox.build_quadratic_1d

# Check termination condition for nonlinear least squares.
scipy.optimize._lsq.dogbox.check_termination

# Compute gradient of the least-squares cost function.
scipy.optimize._lsq.dogbox.compute_grad

# Compute variables scale based on the Jacobian matrix.
scipy.optimize._lsq.dogbox.compute_jac_scale

scipy.optimize._lsq.dogbox.dogbox

# Find dogleg step in a rectangular region.
scipy.optimize._lsq.dogbox.dogleg_step

# Compute values of a quadratic function arising in least squares.
scipy.optimize._lsq.dogbox.evaluate_quadratic

# Find intersection of trust-region bounds and initial bounds.
scipy.optimize._lsq.dogbox.find_intersection

# Check if a point lies within bounds.
scipy.optimize._lsq.dogbox.in_bounds

# Iterative solver for least-squares problems.
scipy.optimize._lsq.dogbox.lsmr

# Compute LinearOperator to use in LSMR by dogbox algorithm.
scipy.optimize._lsq.dogbox.lsmr_operator

# Return the least-squares solution to a linear matrix equation.
scipy.optimize._lsq.dogbox.lstsq

# Minimize a 1-D quadratic function subject to bounds.
scipy.optimize._lsq.dogbox.minimize_quadratic_1d

# Matrix or vector norm.
scipy.optimize._lsq.dogbox.norm

# NumPy
scipy.optimize._lsq.dogbox.np

scipy.optimize._lsq.dogbox.print_header_nonlinear

scipy.optimize._lsq.dogbox.print_iteration_nonlinear

# Scale Jacobian and residuals for a robust loss function.
scipy.optimize._lsq.dogbox.scale_for_robust_loss_function

# Compute a min_step size required to reach a bound.
scipy.optimize._lsq.dogbox.step_size_to_bound

# Update the radius of a trust region based on the cost reduction.
scipy.optimize._lsq.dogbox.update_tr_radius

# Zero out a diagonal block of a matrix by series of Givens rotations.
scipy.optimize._lsq.givens_elimination.givens_elimination

# NumPy
scipy.optimize._lsq.givens_elimination.np

# Bounds constraint on the variables.
scipy.optimize._lsq.least_squares.Bounds

# Double-precision floating-point number type, compatible with Python
scipy.optimize._lsq.least_squares.EPS

# dict() -> new empty dictionary
scipy.optimize._lsq.least_squares.FROM_MINPACK_TO_COMMON

# dict() -> new empty dictionary
scipy.optimize._lsq.least_squares.IMPLEMENTED_LOSSES

# Common interface for performing matrix vector products
scipy.optimize._lsq.least_squares.LinearOperator

# Represents the optimization result.
scipy.optimize._lsq.least_squares.OptimizeResult

# dict() -> new empty dictionary
scipy.optimize._lsq.least_squares.TERMINATION_MESSAGES

# Vector function and its derivatives.
scipy.optimize._lsq.least_squares.VectorFunction

scipy.optimize._lsq.least_squares.arctan

# Get the array API compatible namespace for the arrays xs.
scipy.optimize._lsq.least_squares.array_namespace

scipy.optimize._lsq.least_squares.call_minpack

scipy.optimize._lsq.least_squares.cauchy

scipy.optimize._lsq.least_squares.check_jac_sparsity

scipy.optimize._lsq.least_squares.check_tolerance

scipy.optimize._lsq.least_squares.check_x_scale

scipy.optimize._lsq.least_squares.construct_loss_function

scipy.optimize._lsq.least_squares.dogbox

# Group columns of a 2-D matrix for sparse finite differencing [1]_.
scipy.optimize._lsq.least_squares.group_columns

scipy.optimize._lsq.least_squares.huber

# Check if a point lies within bounds.
scipy.optimize._lsq.least_squares.in_bounds

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._lsq.least_squares.issparse

# Solve a nonlinear least-squares problem with bounds on the variables.
scipy.optimize._lsq.least_squares.least_squares

# Shift a point to the interior of a feasible region.
scipy.optimize._lsq.least_squares.make_strictly_feasible

# Matrix or vector norm.
scipy.optimize._lsq.least_squares.norm

# NumPy
scipy.optimize._lsq.least_squares.np

scipy.optimize._lsq.least_squares.prepare_bounds

scipy.optimize._lsq.least_squares.soft_l1

scipy.optimize._lsq.least_squares.trf

# Issue a warning, or maybe ignore it or raise an exception.
scipy.optimize._lsq.least_squares.warn

# Bounds constraint on the variables.
scipy.optimize._lsq.lsq_linear.Bounds

# Common interface for performing matrix vector products
scipy.optimize._lsq.lsq_linear.LinearOperator

# Represents the optimization result.
scipy.optimize._lsq.lsq_linear.OptimizeResult

# dict() -> new empty dictionary
scipy.optimize._lsq.lsq_linear.TERMINATION_MESSAGES

scipy.optimize._lsq.lsq_linear.bvls

# Compute gradient of the least-squares cost function.
scipy.optimize._lsq.lsq_linear.compute_grad

# Compressed Sparse Row array.
scipy.optimize._lsq.lsq_linear.csr_array

# Check if a point lies within bounds.
scipy.optimize._lsq.lsq_linear.in_bounds

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._lsq.lsq_linear.issparse

# Iterative solver for least-squares problems.
scipy.optimize._lsq.lsq_linear.lsmr

# Solve a linear least-squares problem with bounds on the variables.
scipy.optimize._lsq.lsq_linear.lsq_linear

# Matrix or vector norm.
scipy.optimize._lsq.lsq_linear.norm

# NumPy
scipy.optimize._lsq.lsq_linear.np

scipy.optimize._lsq.lsq_linear.prepare_bounds

scipy.optimize._lsq.lsq_linear.trf_linear

# Compute Coleman-Li scaling vector and its derivatives.
scipy.optimize._lsq.trf.CL_scaling_vector

# Represents the optimization result.
scipy.optimize._lsq.trf.OptimizeResult

# Parameterize a multivariate quadratic function along a line.
scipy.optimize._lsq.trf.build_quadratic_1d

# Check termination condition for nonlinear least squares.
scipy.optimize._lsq.trf.check_termination

# Compute gradient of the least-squares cost function.
scipy.optimize._lsq.trf.compute_grad

# Compute variables scale based on the Jacobian matrix.
scipy.optimize._lsq.trf.compute_jac_scale

# Compute values of a quadratic function arising in least squares.
scipy.optimize._lsq.trf.evaluate_quadratic

# Determine which constraints are active in a given point.
scipy.optimize._lsq.trf.find_active_constraints

# Check if a point lies within bounds.
scipy.optimize._lsq.trf.in_bounds

# Find the intersection of a line with the boundary of a trust region.
scipy.optimize._lsq.trf.intersect_trust_region

# Iterative solver for least-squares problems.
scipy.optimize._lsq.trf.lsmr

# Shift a point to the interior of a feasible region.
scipy.optimize._lsq.trf.make_strictly_feasible

# Minimize a 1-D quadratic function subject to bounds.
scipy.optimize._lsq.trf.minimize_quadratic_1d

# Matrix or vector norm.
scipy.optimize._lsq.trf.norm

# NumPy
scipy.optimize._lsq.trf.np

scipy.optimize._lsq.trf.print_header_nonlinear

scipy.optimize._lsq.trf.print_iteration_nonlinear

# Compute QR decomposition of a matrix.
scipy.optimize._lsq.trf.qr

# Return a matrix arising in regularized least squares as LinearOperator.
scipy.optimize._lsq.trf.regularized_lsq_operator

# Return J diag(d) as LinearOperator.
scipy.optimize._lsq.trf.right_multiplied_operator

# Scale Jacobian and residuals for a robust loss function.
scipy.optimize._lsq.trf.scale_for_robust_loss_function

# Select the best step according to Trust Region Reflective algorithm.
scipy.optimize._lsq.trf.select_step

# Solve a trust-region problem arising in least-squares minimization.
scipy.optimize._lsq.trf.solve_lsq_trust_region

# Solve a general trust-region problem in 2 dimensions.
scipy.optimize._lsq.trf.solve_trust_region_2d

# Compute a min_step size required to reach a bound.
scipy.optimize._lsq.trf.step_size_to_bound

# Singular Value Decomposition.
scipy.optimize._lsq.trf.svd

scipy.optimize._lsq.trf.trf

scipy.optimize._lsq.trf.trf_bounds

scipy.optimize._lsq.trf.trf_no_bounds

# Update the radius of a trust region based on the cost reduction.
scipy.optimize._lsq.trf.update_tr_radius

# Compute Coleman-Li scaling vector and its derivatives.
scipy.optimize._lsq.trf_linear.CL_scaling_vector

# Double-precision floating-point number type, compatible with Python
scipy.optimize._lsq.trf_linear.EPS

# Represents the optimization result.
scipy.optimize._lsq.trf_linear.OptimizeResult

# Find an appropriate step size using backtracking line search.
scipy.optimize._lsq.trf_linear.backtracking

# Parameterize a multivariate quadratic function along a line.
scipy.optimize._lsq.trf_linear.build_quadratic_1d

# Compute gradient of the least-squares cost function.
scipy.optimize._lsq.trf_linear.compute_grad

# Compute values of a quadratic function arising in least squares.
scipy.optimize._lsq.trf_linear.evaluate_quadratic

# Determine which constraints are active in a given point.
scipy.optimize._lsq.trf_linear.find_active_constraints

# Zero out a diagonal block of a matrix by series of Givens rotations.
scipy.optimize._lsq.trf_linear.givens_elimination

# Check if a point lies within bounds.
scipy.optimize._lsq.trf_linear.in_bounds

# Iterative solver for least-squares problems.
scipy.optimize._lsq.trf_linear.lsmr

# Shift a point to the interior of a feasible region.
scipy.optimize._lsq.trf_linear.make_strictly_feasible

# Minimize a 1-D quadratic function subject to bounds.
scipy.optimize._lsq.trf_linear.minimize_quadratic_1d

# Matrix or vector norm.
scipy.optimize._lsq.trf_linear.norm

# NumPy
scipy.optimize._lsq.trf_linear.np

scipy.optimize._lsq.trf_linear.print_header_linear

scipy.optimize._lsq.trf_linear.print_iteration_linear

# Compute QR decomposition of a matrix.
scipy.optimize._lsq.trf_linear.qr

# Compute reflective transformation and its gradient.
scipy.optimize._lsq.trf_linear.reflective_transformation

# Return a matrix arising in regularized least squares as LinearOperator.
scipy.optimize._lsq.trf_linear.regularized_lsq_operator

# Solve regularized least squares using information from QR-decomposition.
scipy.optimize._lsq.trf_linear.regularized_lsq_with_qr

# Return J diag(d) as LinearOperator.
scipy.optimize._lsq.trf_linear.right_multiplied_operator

# Select the best step according to Trust Region Reflective algorithm.
scipy.optimize._lsq.trf_linear.select_step

# Solve the equation ``a @ x = b`` for ``x``, where `a` is a triangular matrix.
scipy.optimize._lsq.trf_linear.solve_triangular

# Compute a min_step size required to reach a bound.
scipy.optimize._lsq.trf_linear.step_size_to_bound

scipy.optimize._lsq.trf_linear.trf_linear

# Bounds constraint on the variables.
scipy.optimize._milp.Bounds

# Linear constraint on the variables.
scipy.optimize._milp.LinearConstraint

# Represents the optimization result.
scipy.optimize._milp.OptimizeResult

# Visible deprecation warning.
scipy.optimize._milp.VisibleDeprecationWarning

# Compressed Sparse Column array.
scipy.optimize._milp.csc_array

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._milp.issparse

# Mixed-integer linear programming
scipy.optimize._milp.milp

# NumPy
scipy.optimize._milp.np

# Stack sparse arrays vertically (row wise)
scipy.optimize._milp.vstack

# Python part of the warnings subsystem.
scipy.optimize._milp.warnings

# Minimization of scalar function of one or more variables.
scipy.optimize._minimize.minimize

# Local minimization of scalar function of one variable.
scipy.optimize._minimize.minimize_scalar

scipy.optimize._minpack.error

# Use non-linear least squares to fit a function, f, to data.
scipy.optimize._minpack_py.curve_fit

# Find a fixed point of the function.
scipy.optimize._minpack_py.fixed_point

# Find the roots of a function.
scipy.optimize._minpack_py.fsolve

# Minimize the sum of squares of a set of equations.
scipy.optimize._minpack_py.leastsq

# NumPy
scipy.optimize._moduleTNC.np

scipy.optimize._moduleTNC.tnc_minimize

# Solve ``argmin_x || Ax - b ||_2`` for ``x>=0``.
scipy.optimize._nnls.nnls

# Find a root of a function, using Broyden's first Jacobian approximation.
scipy.optimize._nonlin.BroydenFirst

# A simple wrapper that inverts the Jacobian using the `solve` method.
scipy.optimize._nonlin.InverseJacobian

# Find a root of a function, using Krylov approximation for inverse Jacobian.
scipy.optimize._nonlin.KrylovJacobian

# Exception raised when nonlinear solver fails to converge within the specified
scipy.optimize._nonlin.NoConvergence

# Find a root of a function, using (extended) Anderson mixing.
scipy.optimize._nonlin.anderson

# Find a root of a function, using Broyden's first Jacobian approximation.
scipy.optimize._nonlin.broyden1

# Find a root of a function, using Broyden's second Jacobian approximation.
scipy.optimize._nonlin.broyden2

# Find a root of a function, using diagonal Broyden Jacobian approximation.
scipy.optimize._nonlin.diagbroyden

# Find a root of a function, using a tuned diagonal Jacobian approximation.
scipy.optimize._nonlin.excitingmixing

# Find a root of a function, using a scalar Jacobian approximation.
scipy.optimize._nonlin.linearmixing

# Find a root of a function, using Krylov approximation for inverse Jacobian.
scipy.optimize._nonlin.newton_krylov

# Common interface for performing matrix vector products
scipy.optimize._numdiff.LinearOperator

# Parallelisation wrapper for working with map-like callables, such as
scipy.optimize._numdiff.MapWrapper

# Compute finite difference approximation of the derivatives of a
scipy.optimize._numdiff.approx_derivative

# Get the array API compatible namespace for the arrays xs.
scipy.optimize._numdiff.array_namespace

# Check correctness of a function computing derivatives (Jacobian or
scipy.optimize._numdiff.check_derivative

# Compressed Sparse Column array.
scipy.optimize._numdiff.csc_array

# Compressed Sparse Row array.
scipy.optimize._numdiff.csr_array

# Compressed Sparse Row matrix.
scipy.optimize._numdiff.csr_matrix

# Return the indices and values of the nonzero elements of a matrix
scipy.optimize._numdiff.find

# functools.py - Tools for working with functions and callable objects
scipy.optimize._numdiff.functools

# Group columns of a 2-D matrix for sparse finite differencing [1]_.
scipy.optimize._numdiff.group_columns

# Supported prototypes:
scipy.optimize._numdiff.group_dense

# Supported prototypes:
scipy.optimize._numdiff.group_sparse

# Is `x` of a sparse array or sparse matrix type?
scipy.optimize._numdiff.issparse

# Is `x` of a sparse matrix type?
scipy.optimize._numdiff.isspmatrix

# Matrix or vector norm.
scipy.optimize._numdiff.norm

# NumPy
scipy.optimize._numdiff.np

# Extra array functions built on top of the array API standard.
scipy.optimize._numdiff.xpx

# Represents the optimization result.
scipy.optimize._optimize.OptimizeResult

# General warning for :mod:`scipy.optimize`.
scipy.optimize._optimize.OptimizeWarning

# Finite difference approximation of the derivatives of a
scipy.optimize._optimize.approx_fprime

# Bracket the minimum of a function.
scipy.optimize._optimize.bracket

# Given a function of one variable and a possible bracket, return
scipy.optimize._optimize.brent

# Minimize a function over a given range by brute force.
scipy.optimize._optimize.brute

# Check the correctness of a gradient function by comparing it against a
scipy.optimize._optimize.check_grad

# Minimize a function using the downhill simplex algorithm.
scipy.optimize._optimize.fmin

# Minimize a function using the BFGS algorithm.
scipy.optimize._optimize.fmin_bfgs

# Minimize a function using a nonlinear conjugate gradient algorithm.
scipy.optimize._optimize.fmin_cg

# Unconstrained minimization of a function using the Newton-CG method.
scipy.optimize._optimize.fmin_ncg

# Minimize a function using modified Powell's method.
scipy.optimize._optimize.fmin_powell

# Bounded minimization for scalar functions.
scipy.optimize._optimize.fminbound

# Return the minimizer of a function of one variable using the golden section
scipy.optimize._optimize.golden

# Find alpha that satisfies strong Wolfe conditions.
scipy.optimize._optimize.line_search

# The Rosenbrock function.
scipy.optimize._optimize.rosen

# The derivative (i.e. gradient) of the Rosenbrock function.
scipy.optimize._optimize.rosen_der

# The Hessian matrix of the Rosenbrock function.
scipy.optimize._optimize.rosen_hess

# Product of the Hessian matrix of the Rosenbrock function with a vector.
scipy.optimize._optimize.rosen_hess_prod

# Show documentation for additional options of optimization solvers.
scipy.optimize._optimize.show_options

# pava(x: numpy.ndarray[numpy.float64], w: numpy.ndarray[numpy.float64], indices: numpy.ndarray[numpy.int64]) -> tuple[numpy.ndarray[numpy.float64], numpy.ndarray[numpy.float64], numpy.ndarray[numpy.int64], int]
scipy.optimize._pava_pybind.pava

# Represents the optimization result.
scipy.optimize._qap.OptimizeResult

# Built-in mutable sequence.
scipy.optimize._qap.QUADRATIC_ASSIGNMENT_METHODS

# Turn `seed` into a `np.random.RandomState` instance.
scipy.optimize._qap.check_random_state

# Functional tools for creating and using iterators.
scipy.optimize._qap.itertools

# Solve the linear sum assignment problem.
scipy.optimize._qap.linear_sum_assignment

# NumPy
scipy.optimize._qap.np

# Abstract Base Classes (ABCs) for numbers, according to PEP 3141.
scipy.optimize._qap.numbers

# Operator interface.
scipy.optimize._qap.operator

# Approximates solution to the quadratic assignment problem and
scipy.optimize._qap.quadratic_assignment

# Python part of the warnings subsystem.
scipy.optimize._qap.warnings

scipy.optimize._remove_redundancy.bg_update_dense

# x = dtrsm(alpha,a,b,[side,lower,trans_a,diag,overwrite_b])
scipy.optimize._remove_redundancy.dtrsm

# Compute ID of a matrix.
scipy.optimize._remove_redundancy.interp_decomp

# NumPy
scipy.optimize._remove_redundancy.np

# SciPy: A scientific computing package for Python
scipy.optimize._remove_redundancy.scipy

# Singular Value Decomposition.
scipy.optimize._remove_redundancy.svd

# Find a root of a vector function.
scipy.optimize._root.root

# Find a root of a scalar function.
scipy.optimize._root_scalar.root_scalar

# Finds the global minimum of a function using SHG optimization.
scipy.optimize._shgo.shgo

# Base class for a simplicial complex described as a cache of vertices
scipy.optimize._shgo_lib._complex.Complex

scipy.optimize._shgo_lib._complex.VertexCacheField

scipy.optimize._shgo_lib._complex.VertexCacheIndex

# Simple lightweight unbounded cache.  Sometimes called "memoize".
scipy.optimize._shgo_lib._complex.cache

# Generic (shallow and deep) copying operations.
scipy.optimize._shgo_lib._complex.copy

# Decimal fixed-point and floating-point arithmetic.
scipy.optimize._shgo_lib._complex.decimal

# Functional tools for creating and using iterators.
scipy.optimize._shgo_lib._complex.itertools

# Logging package for Python. Based on PEP 282 and comments thereto in
scipy.optimize._shgo_lib._complex.logging

# NumPy
scipy.optimize._shgo_lib._complex.np

# Helper class that provides a standard way to create an ABC using
scipy.optimize._shgo_lib._vertex.ABC

# Object to wrap constraints to pass to `multiprocessing.Pool`.
scipy.optimize._shgo_lib._vertex.ConstraintWrapper

# Object to wrap field to pass to `multiprocessing.Pool`.
scipy.optimize._shgo_lib._vertex.FieldWrapper

# Parallelisation wrapper for working with map-like callables, such as
scipy.optimize._shgo_lib._vertex.MapWrapper

# Base class for a vertex.
scipy.optimize._shgo_lib._vertex.VertexBase

# Base class for a vertex cache for a simplicial complex.
scipy.optimize._shgo_lib._vertex.VertexCacheBase

scipy.optimize._shgo_lib._vertex.VertexCacheField

scipy.optimize._shgo_lib._vertex.VertexCacheIndex

# Vertex class to be used for a pure simplicial complex with no associated
scipy.optimize._shgo_lib._vertex.VertexCube

# Add homology properties of a scalar field f: R^n --> R associated with
scipy.optimize._shgo_lib._vertex.VertexScalarField

# Add homology properties of a scalar field f: R^n --> R^m associated with
scipy.optimize._shgo_lib._vertex.VertexVectorField

# A decorator indicating abstract methods.
scipy.optimize._shgo_lib._vertex.abstractmethod

# This module implements specialized container datatypes providing
scipy.optimize._shgo_lib._vertex.collections

# NumPy
scipy.optimize._shgo_lib._vertex.np

# Approximate the Jacobian matrix of a callable function.
scipy.optimize._slsqp_py.approx_jacobian

# Minimize a function using Sequential Least Squares Programming
scipy.optimize._slsqp_py.fmin_slsqp

scipy.optimize._slsqplib.error

# Compute the nonnegative least squares solution.
scipy.optimize._slsqplib.nnls

# Sequential Least Squares Programming (SLSQP) optimizer.
scipy.optimize._slsqplib.slsqp

# Represents the optimization result.
scipy.optimize._spectral.OptimizeResult

# This module implements specialized container datatypes providing
scipy.optimize._spectral.collections

# NumPy
scipy.optimize._spectral.np

# Minimize a function with variables subject to bounds, using
scipy.optimize._tnc.fmin_tnc

# Base/abstract class defining the quadratic model for trust-region
scipy.optimize._trlib._trlib.BaseQuadraticSubproblem

scipy.optimize._trlib._trlib.TRLIBQuadraticSubproblem

# NumPy
scipy.optimize._trlib._trlib.np

# Canonical constraint to use with trust-constr algorithm.
scipy.optimize._trustregion_constr.canonical_constraint.CanonicalConstraint

# Convert initial values of the constraints to the canonical format.
scipy.optimize._trustregion_constr.canonical_constraint.initial_constraints_as_canonical

# NumPy
scipy.optimize._trustregion_constr.canonical_constraint.np

# ===================================
scipy.optimize._trustregion_constr.canonical_constraint.sps

# Solve nonlinear equality-constrained problem using trust-region SQP.
scipy.optimize._trustregion_constr.equality_constrained_sqp.equality_constrained_sqp

# Broyden-Fletcher-Goldfarb-Shanno (BFGS) Hessian update strategy.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.BFGS

scipy.optimize._trustregion_constr.minimize_trustregion_constr.BasicReport

# Bounds constraint on the variables.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.Bounds

# Canonical constraint to use with trust-constr algorithm.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.CanonicalConstraint

# Build LinearOperator from hessp
scipy.optimize._trustregion_constr.minimize_trustregion_constr.HessianLinearOperator

scipy.optimize._trustregion_constr.minimize_trustregion_constr.IPReport

# The Hessian of the Lagrangian as LinearOperator.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.LagrangianHessian

# Linear constraint on the variables.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.LinearConstraint

# Common interface for performing matrix vector products
scipy.optimize._trustregion_constr.minimize_trustregion_constr.LinearOperator

# Nonlinear constraint on the variables.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.NonlinearConstraint

# Represents the optimization result.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.OptimizeResult

# Constraint prepared from a user defined constraint.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.PreparedConstraint

scipy.optimize._trustregion_constr.minimize_trustregion_constr.SQPReport

# Scalar function and its derivatives.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.ScalarFunction

# dict() -> new empty dictionary
scipy.optimize._trustregion_constr.minimize_trustregion_constr.TERMINATION_MESSAGES

# Vector function and its derivatives.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.VectorFunction

# Solve nonlinear equality-constrained problem using trust-region SQP.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.equality_constrained_sqp

# Convert initial values of the constraints to the canonical format.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.initial_constraints_as_canonical

# NumPy
scipy.optimize._trustregion_constr.minimize_trustregion_constr.np

# Remove bounds which are not asked to be kept feasible.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.strict_bounds

# This module provides various functions to manipulate time values.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.time

# Trust-region interior points method.
scipy.optimize._trustregion_constr.minimize_trustregion_constr.tr_interior_point

scipy.optimize._trustregion_constr.minimize_trustregion_constr.update_state_ip

scipy.optimize._trustregion_constr.minimize_trustregion_constr.update_state_sqp

# Measure orthogonality between a vector and the null space of a matrix.
scipy.optimize._trustregion_constr.projections.orthogonality

# Return three linear operators related with a given matrix A.
scipy.optimize._trustregion_constr.projections.projections

# Find the intersection between segment (or line) and box constraints.
scipy.optimize._trustregion_constr.qp_subproblem.box_intersections

# Find the intersection between segment (or line) and box/sphere constraints.
scipy.optimize._trustregion_constr.qp_subproblem.box_sphere_intersections

# Solve equality-constrained quadratic programming (EQP) problem.
scipy.optimize._trustregion_constr.qp_subproblem.eqp_kktfact

# Check if lb <= x <= ub.
scipy.optimize._trustregion_constr.qp_subproblem.inside_box_boundaries

# Approximately  minimize ``1/2*|| A x + b ||^2`` inside trust-region.
scipy.optimize._trustregion_constr.qp_subproblem.modified_dogleg

# Solve EQP problem with projected CG method.
scipy.optimize._trustregion_constr.qp_subproblem.projected_cg

# Find the intersection between segment (or line) and spherical constraints.
scipy.optimize._trustregion_constr.qp_subproblem.sphere_intersections

scipy.optimize._trustregion_constr.report.BasicReport

scipy.optimize._trustregion_constr.report.IPReport

scipy.optimize._trustregion_constr.report.ReportBase

scipy.optimize._trustregion_constr.report.SQPReport

# Trust-region interior points method.
scipy.optimize._trustregion_constr.tr_interior_point.tr_interior_point

# Quadratic subproblem solved by nearly exact iterative method.
scipy.optimize._trustregion_exact.IterativeSubproblem

# Minimization of scalar function of one or more variables using
scipy.optimize._trustregion_exact._minimize_trustregion_exact

# Given upper triangular matrix ``U`` estimate the smallest singular
scipy.optimize._trustregion_exact.estimate_smallest_singular_value

# Compute term that makes the leading ``k`` by ``k``
scipy.optimize._trustregion_exact.singular_leading_submatrix

# Minimization of a scalar function of one or more variables using
scipy.optimize._trustregion_krylov._minimize_trust_krylov

# Straightforward sum of trigonometric function and polynomial
scipy.optimize._tstutils.aps01_f

scipy.optimize._tstutils.aps01_fp

scipy.optimize._tstutils.aps01_fpp

# poles at x=n**2, 1st and 2nd derivatives at root are also close to 0
scipy.optimize._tstutils.aps02_f

scipy.optimize._tstutils.aps02_fp

scipy.optimize._tstutils.aps02_fpp

# Rapidly changing at the root
scipy.optimize._tstutils.aps03_f

scipy.optimize._tstutils.aps03_fp

scipy.optimize._tstutils.aps03_fpp

# Medium-degree polynomial
scipy.optimize._tstutils.aps04_f

scipy.optimize._tstutils.aps04_fp

scipy.optimize._tstutils.aps04_fpp

# Simple Trigonometric function
scipy.optimize._tstutils.aps05_f

scipy.optimize._tstutils.aps05_fp

scipy.optimize._tstutils.aps05_fpp

# Exponential rapidly changing from -1 to 1 at x=0
scipy.optimize._tstutils.aps06_f

scipy.optimize._tstutils.aps06_fp

scipy.optimize._tstutils.aps06_fpp

# Upside down parabola with parametrizable height
scipy.optimize._tstutils.aps07_f

scipy.optimize._tstutils.aps07_fp

scipy.optimize._tstutils.aps07_fpp

# Degree n polynomial
scipy.optimize._tstutils.aps08_f

scipy.optimize._tstutils.aps08_fp

scipy.optimize._tstutils.aps08_fpp

# Upside down quartic with parametrizable height
scipy.optimize._tstutils.aps09_f

scipy.optimize._tstutils.aps09_fp

scipy.optimize._tstutils.aps09_fpp

# Exponential plus a polynomial
scipy.optimize._tstutils.aps10_f

scipy.optimize._tstutils.aps10_fp

scipy.optimize._tstutils.aps10_fpp

# Rational function with a zero at x=1/n and a pole at x=0
scipy.optimize._tstutils.aps11_f

scipy.optimize._tstutils.aps11_fp

scipy.optimize._tstutils.aps11_fpp

# nth root of x, with a zero at x=n
scipy.optimize._tstutils.aps12_f

scipy.optimize._tstutils.aps12_fp

scipy.optimize._tstutils.aps12_fpp

# Function with *all* derivatives 0 at the root
scipy.optimize._tstutils.aps13_f

scipy.optimize._tstutils.aps13_fp

scipy.optimize._tstutils.aps13_fpp

# 0 for negative x-values, trigonometric+linear for x positive
scipy.optimize._tstutils.aps14_f

scipy.optimize._tstutils.aps14_fp

scipy.optimize._tstutils.aps14_fpp

# piecewise linear, constant outside of [0, 0.002/(1+n)]
scipy.optimize._tstutils.aps15_f

scipy.optimize._tstutils.aps15_fp

scipy.optimize._tstutils.aps15_fpp

# Get the array API compatible namespace for the arrays xs.
scipy.optimize._tstutils.array_namespace

scipy.optimize._tstutils.cc

# z**n-a:  Use to find the nth root of a
scipy.optimize._tstutils.cplx01_f

scipy.optimize._tstutils.cplx01_fp

scipy.optimize._tstutils.cplx01_fpp

# e**z - a: Use to find the log of a
scipy.optimize._tstutils.cplx02_f

scipy.optimize._tstutils.cplx02_fp

scipy.optimize._tstutils.cplx02_fpp

# str(object='') -> str
scipy.optimize._tstutils.description

# f1 is a quadratic with roots at 0 and 1
scipy.optimize._tstutils.f1

scipy.optimize._tstutils.f1_fp

scipy.optimize._tstutils.f1_fpp

# f2 is a symmetric parabola, x**2 - 1
scipy.optimize._tstutils.f2

scipy.optimize._tstutils.f2_fp

scipy.optimize._tstutils.f2_fpp

# A quartic with roots at 0, 1, 2 and 3
scipy.optimize._tstutils.f3

scipy.optimize._tstutils.f3_fp

scipy.optimize._tstutils.f3_fpp

# Piecewise linear, left- and right- discontinuous at x=1, the root.
scipy.optimize._tstutils.f4

# Hyperbola with a pole at x=1, but pole replaced with 0. Not continuous at root.
scipy.optimize._tstutils.f5

scipy.optimize._tstutils.f6

# Built-in mutable sequence.
scipy.optimize._tstutils.fstrings

scipy.optimize._tstutils.fun1

scipy.optimize._tstutils.fun2

scipy.optimize._tstutils.fun3

scipy.optimize._tstutils.fun4

scipy.optimize._tstutils.fun5

scipy.optimize._tstutils.fun6

scipy.optimize._tstutils.fun7

scipy.optimize._tstutils.fun8

scipy.optimize._tstutils.fun9

# Built-in mutable sequence.
scipy.optimize._tstutils.functions

# Return the requested collection of test cases, as an array of dicts with subset-specific keys
scipy.optimize._tstutils.get_tests

# Built-in mutable sequence.
scipy.optimize._tstutils.methods

# Built-in mutable sequence.
scipy.optimize._tstutils.mstrings

# NumPy
scipy.optimize._tstutils.np

# random() -> x in the interval [0, 1).
scipy.optimize._tstutils.random

# Represents the root finding result.
scipy.optimize._zeros_py.RootResults

# Find root of a function within an interval using bisection.
scipy.optimize._zeros_py.bisect

# Find a root of a function in a bracketing interval using Brent's
scipy.optimize._zeros_py.brenth

# Find a root of a function in a bracketing interval using Brent's method.
scipy.optimize._zeros_py.brentq

# Find a root of a real or complex function using the Newton-Raphson
scipy.optimize._zeros_py.newton

# Find a root of a function in an interval using Ridder's method.
scipy.optimize._zeros_py.ridder

# Find a root using TOMS Algorithm 748 method.
scipy.optimize._zeros_py.toms748

# Represents the optimization result.
scipy.optimize.cobyla.OptimizeResult

# Minimize a function using the Constrained Optimization By Linear
scipy.optimize.cobyla.fmin_cobyla

# dict() -> new empty dictionary
scipy.optimize.cython_optimize._zeros.EXAMPLES_MAP

# Example of Cython optimize zeros functions with full output.
scipy.optimize.cython_optimize._zeros.full_output_example

# Example of Cython optimize zeros functions with map.
scipy.optimize.cython_optimize._zeros.loop_example

# Bracket the minimum of a unimodal, real-valued function of a real variable.
scipy.optimize.elementwise.bracket_minimum

# Bracket the root of a monotonic, real-valued function of a real variable.
scipy.optimize.elementwise.bracket_root

# Find the minimum of an unimodal, real-valued function of a real variable.
scipy.optimize.elementwise.find_minimum

# Find the root of a monotonic, real-valued function of a real variable.
scipy.optimize.elementwise.find_root

# Linear operator for the L-BFGS approximate inverse Hessian.
scipy.optimize.lbfgsb.LbfgsInvHessProduct

# Represents the optimization result.
scipy.optimize.lbfgsb.OptimizeResult

# Minimize a function func using the L-BFGS-B algorithm.
scipy.optimize.lbfgsb.fmin_l_bfgs_b

# zeros(shape, dtype=float, order='C', *, like=None)
scipy.optimize.lbfgsb.zeros

# As `scalar_search_wolfe1` but do a line search to direction `pk`
scipy.optimize.linesearch.line_search

# Represents the optimization result.
scipy.optimize.minpack.OptimizeResult

# General warning for :mod:`scipy.optimize`.
scipy.optimize.minpack.OptimizeWarning

# Use non-linear least squares to fit a function, f, to data.
scipy.optimize.minpack.curve_fit

# Find a fixed point of the function.
scipy.optimize.minpack.fixed_point

# Find the roots of a function.
scipy.optimize.minpack.fsolve

# Solve a nonlinear least-squares problem with bounds on the variables.
scipy.optimize.minpack.least_squares

# Minimize the sum of squares of a set of equations.
scipy.optimize.minpack.leastsq

# zeros(shape, dtype=float, order='C', *, like=None)
scipy.optimize.minpack.zeros

# Find a root of a function, using Broyden's first Jacobian approximation.
scipy.optimize.nonlin.BroydenFirst

# A simple wrapper that inverts the Jacobian using the `solve` method.
scipy.optimize.nonlin.InverseJacobian

# Find a root of a function, using Krylov approximation for inverse Jacobian.
scipy.optimize.nonlin.KrylovJacobian

# Find a root of a function, using (extended) Anderson mixing.
scipy.optimize.nonlin.anderson

# Find a root of a function, using Broyden's first Jacobian approximation.
scipy.optimize.nonlin.broyden1

# Find a root of a function, using Broyden's second Jacobian approximation.
scipy.optimize.nonlin.broyden2

# Find a root of a function, using diagonal Broyden Jacobian approximation.
scipy.optimize.nonlin.diagbroyden

# Find a root of a function, using a tuned diagonal Jacobian approximation.
scipy.optimize.nonlin.excitingmixing

# Find a root of a function, using a scalar Jacobian approximation.
scipy.optimize.nonlin.linearmixing

# Find a root of a function, using Krylov approximation for inverse Jacobian.
scipy.optimize.nonlin.newton_krylov

# Represents the optimization result.
scipy.optimize.optimize.OptimizeResult

# General warning for :mod:`scipy.optimize`.
scipy.optimize.optimize.OptimizeWarning

# Finite difference approximation of the derivatives of a
scipy.optimize.optimize.approx_fprime

# Bracket the minimum of a function.
scipy.optimize.optimize.bracket

# Given a function of one variable and a possible bracket, return
scipy.optimize.optimize.brent

# Minimize a function over a given range by brute force.
scipy.optimize.optimize.brute

# Check the correctness of a gradient function by comparing it against a
scipy.optimize.optimize.check_grad

# Minimize a function using the downhill simplex algorithm.
scipy.optimize.optimize.fmin

# Minimize a function using the BFGS algorithm.
scipy.optimize.optimize.fmin_bfgs

# Minimize a function using a nonlinear conjugate gradient algorithm.
scipy.optimize.optimize.fmin_cg

# Unconstrained minimization of a function using the Newton-CG method.
scipy.optimize.optimize.fmin_ncg

# Minimize a function using modified Powell's method.
scipy.optimize.optimize.fmin_powell

# Bounded minimization for scalar functions.
scipy.optimize.optimize.fminbound

# Return the minimizer of a function of one variable using the golden section
scipy.optimize.optimize.golden

# Find alpha that satisfies strong Wolfe conditions.
scipy.optimize.optimize.line_search

# The Rosenbrock function.
scipy.optimize.optimize.rosen

# The derivative (i.e. gradient) of the Rosenbrock function.
scipy.optimize.optimize.rosen_der

# The Hessian matrix of the Rosenbrock function.
scipy.optimize.optimize.rosen_hess

# Product of the Hessian matrix of the Rosenbrock function with a vector.
scipy.optimize.optimize.rosen_hess_prod

# Show documentation for additional options of optimization solvers.
scipy.optimize.optimize.show_options

# zeros(shape, dtype=float, order='C', *, like=None)
scipy.optimize.optimize.zeros

# Represents the optimization result.
scipy.optimize.slsqp.OptimizeResult

# Minimize a function using Sequential Least Squares Programming
scipy.optimize.slsqp.fmin_slsqp

# Sequential Least Squares Programming (SLSQP) optimizer.
scipy.optimize.slsqp.slsqp

# Represents the optimization result.
scipy.optimize.tnc.OptimizeResult

# Minimize a function with variables subject to bounds, using
scipy.optimize.tnc.fmin_tnc

# zeros(shape, dtype=float, order='C', *, like=None)
scipy.optimize.tnc.zeros

# Represents the root finding result.
scipy.optimize.zeros.RootResults

# Find root of a function within an interval using bisection.
scipy.optimize.zeros.bisect

# Find a root of a function in a bracketing interval using Brent's
scipy.optimize.zeros.brenth

# Find a root of a function in a bracketing interval using Brent's method.
scipy.optimize.zeros.brentq

# Find a root of a real or complex function using the Newton-Raphson
scipy.optimize.zeros.newton

# Find a root of a function in an interval using Ridder's method.
scipy.optimize.zeros.ridder

# Find a root using TOMS Algorithm 748 method.
scipy.optimize.zeros.toms748

# Reverse the 1-D slices of `a` along axis `axis`.
scipy.signal._arraytools.axis_reverse

# Take a slice along axis 'axis' from 'a'.
scipy.signal._arraytools.axis_slice

# Constant extension at the boundaries of an array
scipy.signal._arraytools.const_ext

# Even extension at the boundaries of an array
scipy.signal._arraytools.even_ext

# NumPy
scipy.signal._arraytools.np

# Odd extension at the boundaries of an array
scipy.signal._arraytools.odd_ext

# Zero padding at the boundaries of an array
scipy.signal._arraytools.zero_ext

# Create a callable chirp z-transform function.
scipy.signal._czt.CZT

# Create a callable zoom FFT transform function.
scipy.signal._czt.ZoomFFT

# Compute the frequency response around a spiral in the Z plane.
scipy.signal._czt.czt

# Return the points at which the chirp z-transform is computed.
scipy.signal._czt.czt_points

# Compute the DFT of `x` only for frequencies in range `fn`.
scipy.signal._czt.zoom_fft

scipy.signal._delegators.abcd_normalize_signature

scipy.signal._delegators.argrelextrema_signature

scipy.signal._delegators.argrelmax_signature

scipy.signal._delegators.argrelmin_signature

# Get the array API compatible namespace for the arrays xs.
scipy.signal._delegators.array_namespace

scipy.signal._delegators.band_stop_obj_signature

scipy.signal._delegators.bessel_signature

scipy.signal._delegators.besselap_signature

scipy.signal._delegators.bilinear_signature

scipy.signal._delegators.bilinear_zpk_signature

scipy.signal._delegators.bode_signature

scipy.signal._delegators.buttap_signature

scipy.signal._delegators.butter_signature

scipy.signal._delegators.buttord_signature

scipy.signal._delegators.cheb1ap_signature

scipy.signal._delegators.cheb1ord_signature

scipy.signal._delegators.cheb2ap_signature

scipy.signal._delegators.cheb2ord_signature

scipy.signal._delegators.cheby1_signature

scipy.signal._delegators.cheby2_signature

scipy.signal._delegators.check_COLA_signature

scipy.signal._delegators.check_NOLA_signature

scipy.signal._delegators.chirp_signature

scipy.signal._delegators.choose_conv_method_signature

scipy.signal._delegators.coherence_signature

scipy.signal._delegators.cont2discrete_signature

scipy.signal._delegators.convolve2d_signature

scipy.signal._delegators.convolve_signature

scipy.signal._delegators.correlate2d_signature

scipy.signal._delegators.correlate_signature

scipy.signal._delegators.correlation_lags_signature

scipy.signal._delegators.csd_signature

scipy.signal._delegators.cspline1d_eval_signature

scipy.signal._delegators.cspline1d_signature

scipy.signal._delegators.cspline2d_signature

scipy.signal._delegators.czt_points_signature

scipy.signal._delegators.czt_signature

scipy.signal._delegators.dbode_signature

scipy.signal._delegators.decimate_signature

scipy.signal._delegators.deconvolve_signature

scipy.signal._delegators.detrend_signature

scipy.signal._delegators.dfreqresp_signature

scipy.signal._delegators.dimpulse_signature

scipy.signal._delegators.dlsim_signature

scipy.signal._delegators.dstep_signature

scipy.signal._delegators.ellip_signature

scipy.signal._delegators.ellipap_signature

scipy.signal._delegators.ellipord_signature

scipy.signal._delegators.envelope_signature

scipy.signal._delegators.fftconvolve_signature

scipy.signal._delegators.filtfilt_signature

scipy.signal._delegators.find_peaks_cwt_signature

scipy.signal._delegators.find_peaks_signature

scipy.signal._delegators.findfreqs_signature

scipy.signal._delegators.firls_signature

scipy.signal._delegators.firwin2_signature

scipy.signal._delegators.firwin_signature

scipy.signal._delegators.freqresp_signature

scipy.signal._delegators.freqs_signature

scipy.signal._delegators.freqs_zpk_signature

scipy.signal._delegators.freqz_signature

scipy.signal._delegators.freqz_sos_signature

scipy.signal._delegators.freqz_zpk_signature

scipy.signal._delegators.gammatone_signature

scipy.signal._delegators.gauss_spline_signature

scipy.signal._delegators.gausspulse_signature

scipy.signal._delegators.get_window_signature

scipy.signal._delegators.group_delay_signature

scipy.signal._delegators.hilbert2_signature

scipy.signal._delegators.hilbert_signature

scipy.signal._delegators.iircomb_signature

scipy.signal._delegators.iirdesign_signature

scipy.signal._delegators.iirfilter_signature

scipy.signal._delegators.iirnotch_signature

scipy.signal._delegators.iirpeak_signature

scipy.signal._delegators.impulse_signature

scipy.signal._delegators.invres_signature

scipy.signal._delegators.invresz_signature

scipy.signal._delegators.istft_signature

scipy.signal._delegators.kaiser_atten_signature

scipy.signal._delegators.kaiser_beta_signature

scipy.signal._delegators.kaiserord_signature

scipy.signal._delegators.lfilter_signature

scipy.signal._delegators.lfilter_zi_signature

scipy.signal._delegators.lfiltic_signature

scipy.signal._delegators.lombscargle_signature

scipy.signal._delegators.lp2bp_signature

scipy.signal._delegators.lp2bp_zpk_signature

scipy.signal._delegators.lp2bs_signature

scipy.signal._delegators.lp2bs_zpk_signature

scipy.signal._delegators.lp2hp_signature

scipy.signal._delegators.lp2hp_zpk_signature

scipy.signal._delegators.lp2lp_signature

scipy.signal._delegators.lp2lp_zpk_signature

scipy.signal._delegators.lsim_signature

scipy.signal._delegators.max_len_seq_signature

scipy.signal._delegators.medfilt2d_signature

scipy.signal._delegators.medfilt_signature

scipy.signal._delegators.minimum_phase_signature

scipy.signal._delegators.normalize_signature

# NumPy
scipy.signal._delegators.np

scipy.signal._delegators.np_compat

scipy.signal._delegators.oaconvolve_signature

scipy.signal._delegators.order_filter_signature

scipy.signal._delegators.peak_prominences_signature

scipy.signal._delegators.peak_widths_signature

scipy.signal._delegators.periodogram_signature

scipy.signal._delegators.place_poles_signature

scipy.signal._delegators.qspline1d_eval_signature

scipy.signal._delegators.qspline1d_signature

scipy.signal._delegators.qspline2d_signature

scipy.signal._delegators.remez_signature

scipy.signal._delegators.resample_poly_signature

scipy.signal._delegators.resample_signature

scipy.signal._delegators.residue_signature

scipy.signal._delegators.residuez_signature

scipy.signal._delegators.savgol_coeffs_signature

scipy.signal._delegators.savgol_filter_signature

scipy.signal._delegators.sawtooth_signature

scipy.signal._delegators.sepfir2d_signature

scipy.signal._delegators.sos2tf_signature

scipy.signal._delegators.sos2zpk_signature

scipy.signal._delegators.sosfilt_signature

scipy.signal._delegators.sosfilt_zi_signature

scipy.signal._delegators.sosfiltfilt_signature

scipy.signal._delegators.sosfreqz_signature

scipy.signal._delegators.spectrogram_signature

scipy.signal._delegators.spline_filter_signature

scipy.signal._delegators.square_signature

scipy.signal._delegators.ss2tf_signature

scipy.signal._delegators.ss2zpk_signature

scipy.signal._delegators.step_signature

scipy.signal._delegators.stft_signature

scipy.signal._delegators.sweep_poly_signature

scipy.signal._delegators.symiirorder1_signature

scipy.signal._delegators.symiirorder2_signature

scipy.signal._delegators.tf2sos_signature

scipy.signal._delegators.tf2ss_signature

scipy.signal._delegators.tf2zpk_signature

scipy.signal._delegators.unique_roots_signature

scipy.signal._delegators.unit_impulse_signature

scipy.signal._delegators.upfirdn_signature

scipy.signal._delegators.vectorstrength_signature

scipy.signal._delegators.welch_signature

scipy.signal._delegators.wiener_signature

scipy.signal._delegators.zoom_fft_signature

scipy.signal._delegators.zpk2sos_signature

scipy.signal._delegators.zpk2ss_signature

scipy.signal._delegators.zpk2tf_signature

# Warning about badly conditioned filter coefficients
scipy.signal._filter_design.BadCoefficients

# Band Stop Objective Function for order minimization.
scipy.signal._filter_design.band_stop_obj

# Bessel/Thomson digital and analog filter design.
scipy.signal._filter_design.bessel

# Return (z,p,k) for analog prototype of an Nth-order Bessel filter.
scipy.signal._filter_design.besselap

# Calculate a digital IIR filter from an analog transfer function by utilizing
scipy.signal._filter_design.bilinear

# Return a digital IIR filter from an analog one using a bilinear transform.
scipy.signal._filter_design.bilinear_zpk

# Return (z,p,k) for analog prototype of Nth-order Butterworth filter.
scipy.signal._filter_design.buttap

# Butterworth digital and analog filter design.
scipy.signal._filter_design.butter

# Butterworth filter order selection.
scipy.signal._filter_design.buttord

# Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.
scipy.signal._filter_design.cheb1ap

# Chebyshev type I filter order selection.
scipy.signal._filter_design.cheb1ord

# Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter.
scipy.signal._filter_design.cheb2ap

# Chebyshev type II filter order selection.
scipy.signal._filter_design.cheb2ord

# Chebyshev type I digital and analog filter design.
scipy.signal._filter_design.cheby1

# Chebyshev type II digital and analog filter design.
scipy.signal._filter_design.cheby2

# Elliptic (Cauer) digital and analog filter design.
scipy.signal._filter_design.ellip

# Return (z,p,k) of Nth-order elliptic analog lowpass filter.
scipy.signal._filter_design.ellipap

# Elliptic (Cauer) filter order selection.
scipy.signal._filter_design.ellipord

# Find array of frequencies for computing the response of an analog filter.
scipy.signal._filter_design.findfreqs

# Compute frequency response of analog filter.
scipy.signal._filter_design.freqs

# Compute frequency response of analog filter.
scipy.signal._filter_design.freqs_zpk

# Compute the frequency response of a digital filter.
scipy.signal._filter_design.freqz

# Compute the frequency response of a digital filter in SOS format.
scipy.signal._filter_design.freqz_sos

# Compute the frequency response of a digital filter in ZPK form.
scipy.signal._filter_design.freqz_zpk

# Gammatone filter design.
scipy.signal._filter_design.gammatone

# Compute the group delay of a digital filter.
scipy.signal._filter_design.group_delay

# Design IIR notching or peaking digital comb filter.
scipy.signal._filter_design.iircomb

# Complete IIR digital and analog filter design.
scipy.signal._filter_design.iirdesign

# IIR digital and analog filter design given order and critical points.
scipy.signal._filter_design.iirfilter

# Design second-order IIR notch digital filter.
scipy.signal._filter_design.iirnotch

# Design second-order IIR peak (resonant) digital filter.
scipy.signal._filter_design.iirpeak

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal._filter_design.lp2bp

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal._filter_design.lp2bp_zpk

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal._filter_design.lp2bs

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal._filter_design.lp2bs_zpk

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal._filter_design.lp2hp

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal._filter_design.lp2hp_zpk

# Transform a lowpass filter prototype to a different frequency.
scipy.signal._filter_design.lp2lp

# Transform a lowpass filter prototype to a different frequency.
scipy.signal._filter_design.lp2lp_zpk

# Normalize numerator/denominator of a continuous-time transfer function.
scipy.signal._filter_design.normalize

# Return a single transfer function from a series of second-order sections
scipy.signal._filter_design.sos2tf

# Return zeros, poles, and gain of a series of second-order sections
scipy.signal._filter_design.sos2zpk

# Compute the frequency response of a digital filter in SOS format (legacy).
scipy.signal._filter_design.sosfreqz

# Return second-order sections from transfer function representation
scipy.signal._filter_design.tf2sos

# Return zero, pole, gain (z, p, k) representation from a numerator,
scipy.signal._filter_design.tf2zpk

# Return second-order sections from zeros, poles, and gain of a system
scipy.signal._filter_design.zpk2sos

# Return polynomial transfer function representation from zeros and poles
scipy.signal._filter_design.zpk2tf

# FIR filter design using least-squares error minimization.
scipy.signal._fir_filter_design.firls

# FIR filter design using the window method.
scipy.signal._fir_filter_design.firwin

# FIR filter design using the window method.
scipy.signal._fir_filter_design.firwin2

# 2D FIR filter design using the window method.
scipy.signal._fir_filter_design.firwin_2d

# Compute the attenuation of a Kaiser FIR filter.
scipy.signal._fir_filter_design.kaiser_atten

# Compute the Kaiser parameter `beta`, given the attenuation `a`.
scipy.signal._fir_filter_design.kaiser_beta

# Determine the filter window parameters for the Kaiser window method.
scipy.signal._fir_filter_design.kaiserord

# Convert a linear-phase FIR filter to minimum phase
scipy.signal._fir_filter_design.minimum_phase

# Calculate the minimax optimal filter using the Remez exchange algorithm.
scipy.signal._fir_filter_design.remez

# Check state-space matrices and ensure they are 2-D.
scipy.signal._lti_conversion.abcd_normalize

# Transform a continuous to a discrete state-space system.
scipy.signal._lti_conversion.cont2discrete

# State-space to transfer function.
scipy.signal._lti_conversion.ss2tf

# State-space representation to zero-pole-gain representation.
scipy.signal._lti_conversion.ss2zpk

# Transfer function to state-space representation.
scipy.signal._lti_conversion.tf2ss

# Zero-pole-gain representation to state-space representation
scipy.signal._lti_conversion.zpk2ss

# Linear Time Invariant system in state-space form.
scipy.signal._ltisys.StateSpace

# Linear Time Invariant system class in transfer function form.
scipy.signal._ltisys.TransferFunction

# Linear Time Invariant system class in zeros, poles, gain form.
scipy.signal._ltisys.ZerosPolesGain

# Calculate Bode magnitude and phase data of a continuous-time system.
scipy.signal._ltisys.bode

# Calculate Bode magnitude and phase data of a discrete-time system.
scipy.signal._ltisys.dbode

# Calculate the frequency response of a discrete-time system.
scipy.signal._ltisys.dfreqresp

# Impulse response of discrete-time system.
scipy.signal._ltisys.dimpulse

# Simulate output of a discrete-time linear system.
scipy.signal._ltisys.dlsim

# Discrete-time linear time invariant system base class.
scipy.signal._ltisys.dlti

# Step response of discrete-time system.
scipy.signal._ltisys.dstep

# Calculate the frequency response of a continuous-time system.
scipy.signal._ltisys.freqresp

# Impulse response of continuous-time system.
scipy.signal._ltisys.impulse

# Simulate output of a continuous-time linear system.
scipy.signal._ltisys.lsim

# Continuous-time linear time invariant system base class.
scipy.signal._ltisys.lti

# Compute K such that eigenvalues (A - dot(B, K))=poles.
scipy.signal._ltisys.place_poles

# Step response of continuous-time system.
scipy.signal._ltisys.step

# Maximum length sequence (MLS) generator.
scipy.signal._max_len_seq.max_len_seq

# Calculate the relative extrema of `data`.
scipy.signal._peak_finding.argrelextrema

# Calculate the relative maxima of `data`.
scipy.signal._peak_finding.argrelmax

# Calculate the relative minima of `data`.
scipy.signal._peak_finding.argrelmin

# Find peaks inside a signal based on peak properties.
scipy.signal._peak_finding.find_peaks

# Find peaks in a 1-D array with wavelet transformation.
scipy.signal._peak_finding.find_peaks_cwt

# Calculate the prominence of each peak in a signal.
scipy.signal._peak_finding.peak_prominences

# Calculate the width of each peak in a signal.
scipy.signal._peak_finding.peak_widths

# Find local maxima in a 1D array.
scipy.signal._peak_finding_utils._local_maxima_1d

# Calculate the prominence of each peak in a signal.
scipy.signal._peak_finding_utils._peak_prominences

# Calculate the width of each each peak in a signal.
scipy.signal._peak_finding_utils._peak_widths

# Evaluate which peaks fulfill the distance condition.
scipy.signal._peak_finding_utils._select_by_peak_distance

scipy.signal._polyutils.npp_polyval

scipy.signal._polyutils.npp_polyvalfromroots

scipy.signal._polyutils.poly

scipy.signal._polyutils.polymul

# numpy.roots, best-effor replacement
scipy.signal._polyutils.polyroots

# Old-style polynomial, `np.polyval`
scipy.signal._polyutils.polyval

# Query the namespace-dependent default floating-point dtype.
scipy.signal._polyutils.xp_default_dtype

# Promotes elements of *args to result dtype, ignoring `None`s.
scipy.signal._polyutils.xp_promote

# Extra array functions built on top of the array API standard.
scipy.signal._polyutils.xpx

# Take a slice along axis 'axis' from 'a'.
scipy.signal._savitzky_golay.axis_slice

# Calculate a 1-D convolution along the given axis.
scipy.signal._savitzky_golay.convolve1d

# Compute the factorial and return as a float
scipy.signal._savitzky_golay.float_factorial

# Compute least-squares solution to the equation ``a @ x = b``.
scipy.signal._savitzky_golay.lstsq

# NumPy
scipy.signal._savitzky_golay.np

# Compute the coefficients for a 1-D Savitzky-Golay FIR filter.
scipy.signal._savitzky_golay.savgol_coeffs

# Apply a Savitzky-Golay filter to an array.
scipy.signal._savitzky_golay.savgol_filter

# Provide a parametrized discrete Short-time Fourier transform (stft)
scipy.signal._short_time_fft.ShortTimeFFT

# Calculate the STFT dual window of a given window closest to a desired dual
scipy.signal._short_time_fft.closest_STFT_dual_window

# Warning about badly conditioned filter coefficients
scipy.signal._signal_api.BadCoefficients

# Create a callable chirp z-transform function.
scipy.signal._signal_api.CZT

# Provide a parametrized discrete Short-time Fourier transform (stft)
scipy.signal._signal_api.ShortTimeFFT

# Linear Time Invariant system in state-space form.
scipy.signal._signal_api.StateSpace

# Linear Time Invariant system class in transfer function form.
scipy.signal._signal_api.TransferFunction

# Linear Time Invariant system class in zeros, poles, gain form.
scipy.signal._signal_api.ZerosPolesGain

# Create a callable zoom FFT transform function.
scipy.signal._signal_api.ZoomFFT

# Check state-space matrices and ensure they are 2-D.
scipy.signal._signal_api.abcd_normalize

# Calculate the relative extrema of `data`.
scipy.signal._signal_api.argrelextrema

# Calculate the relative maxima of `data`.
scipy.signal._signal_api.argrelmax

# Calculate the relative minima of `data`.
scipy.signal._signal_api.argrelmin

# Band Stop Objective Function for order minimization.
scipy.signal._signal_api.band_stop_obj

# Bessel/Thomson digital and analog filter design.
scipy.signal._signal_api.bessel

# Return (z,p,k) for analog prototype of an Nth-order Bessel filter.
scipy.signal._signal_api.besselap

# Calculate a digital IIR filter from an analog transfer function by utilizing
scipy.signal._signal_api.bilinear

# Return a digital IIR filter from an analog one using a bilinear transform.
scipy.signal._signal_api.bilinear_zpk

# Calculate Bode magnitude and phase data of a continuous-time system.
scipy.signal._signal_api.bode

# Return (z,p,k) for analog prototype of Nth-order Butterworth filter.
scipy.signal._signal_api.buttap

# Butterworth digital and analog filter design.
scipy.signal._signal_api.butter

# Butterworth filter order selection.
scipy.signal._signal_api.buttord

# Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.
scipy.signal._signal_api.cheb1ap

# Chebyshev type I filter order selection.
scipy.signal._signal_api.cheb1ord

# Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter.
scipy.signal._signal_api.cheb2ap

# Chebyshev type II filter order selection.
scipy.signal._signal_api.cheb2ord

# Chebyshev type I digital and analog filter design.
scipy.signal._signal_api.cheby1

# Chebyshev type II digital and analog filter design.
scipy.signal._signal_api.cheby2

# Check whether the Constant OverLap Add (COLA) constraint is met
scipy.signal._signal_api.check_COLA

# Check whether the Nonzero Overlap Add (NOLA) constraint is met.
scipy.signal._signal_api.check_NOLA

# Frequency-swept cosine generator.
scipy.signal._signal_api.chirp

# Find the fastest convolution/correlation method.
scipy.signal._signal_api.choose_conv_method

# Calculate the STFT dual window of a given window closest to a desired dual
scipy.signal._signal_api.closest_STFT_dual_window

# Estimate the magnitude squared coherence estimate, Cxy, of
scipy.signal._signal_api.coherence

# Transform a continuous to a discrete state-space system.
scipy.signal._signal_api.cont2discrete

# Convolve two N-dimensional arrays.
scipy.signal._signal_api.convolve

# Convolve two 2-dimensional arrays.
scipy.signal._signal_api.convolve2d

# Cross-correlate two N-dimensional arrays.
scipy.signal._signal_api.correlate

# Cross-correlate two 2-dimensional arrays.
scipy.signal._signal_api.correlate2d

# Calculates the lag / displacement indices array for 1D cross-correlation.
scipy.signal._signal_api.correlation_lags

# Estimate the cross power spectral density, Pxy, using Welch's method.
scipy.signal._signal_api.csd

# Compute cubic spline coefficients for rank-1 array.
scipy.signal._signal_api.cspline1d

# Evaluate a cubic spline at the new set of points.
scipy.signal._signal_api.cspline1d_eval

# Coefficients for 2-D cubic (3rd order) B-spline.
scipy.signal._signal_api.cspline2d

# Compute the frequency response around a spiral in the Z plane.
scipy.signal._signal_api.czt

# Return the points at which the chirp z-transform is computed.
scipy.signal._signal_api.czt_points

# Calculate Bode magnitude and phase data of a discrete-time system.
scipy.signal._signal_api.dbode

# Downsample the signal after applying an anti-aliasing filter.
scipy.signal._signal_api.decimate

# Deconvolves ``divisor`` out of ``signal`` using inverse filtering.
scipy.signal._signal_api.deconvolve

# Remove linear or constant trend along axis from data.
scipy.signal._signal_api.detrend

# Calculate the frequency response of a discrete-time system.
scipy.signal._signal_api.dfreqresp

# Impulse response of discrete-time system.
scipy.signal._signal_api.dimpulse

# Simulate output of a discrete-time linear system.
scipy.signal._signal_api.dlsim

# Discrete-time linear time invariant system base class.
scipy.signal._signal_api.dlti

# Step response of discrete-time system.
scipy.signal._signal_api.dstep

# Elliptic (Cauer) digital and analog filter design.
scipy.signal._signal_api.ellip

# Return (z,p,k) of Nth-order elliptic analog lowpass filter.
scipy.signal._signal_api.ellipap

# Elliptic (Cauer) filter order selection.
scipy.signal._signal_api.ellipord

# Compute the envelope of a real- or complex-valued signal.
scipy.signal._signal_api.envelope

# Convolve two N-dimensional arrays using FFT.
scipy.signal._signal_api.fftconvolve

# Apply a digital filter forward and backward to a signal.
scipy.signal._signal_api.filtfilt

# Find peaks inside a signal based on peak properties.
scipy.signal._signal_api.find_peaks

# Find peaks in a 1-D array with wavelet transformation.
scipy.signal._signal_api.find_peaks_cwt

# Find array of frequencies for computing the response of an analog filter.
scipy.signal._signal_api.findfreqs

# FIR filter design using least-squares error minimization.
scipy.signal._signal_api.firls

# FIR filter design using the window method.
scipy.signal._signal_api.firwin

# FIR filter design using the window method.
scipy.signal._signal_api.firwin2

# 2D FIR filter design using the window method.
scipy.signal._signal_api.firwin_2d

# Calculate the frequency response of a continuous-time system.
scipy.signal._signal_api.freqresp

# Compute frequency response of analog filter.
scipy.signal._signal_api.freqs

# Compute frequency response of analog filter.
scipy.signal._signal_api.freqs_zpk

# Compute the frequency response of a digital filter.
scipy.signal._signal_api.freqz

# Compute the frequency response of a digital filter in SOS format.
scipy.signal._signal_api.freqz_sos

# Compute the frequency response of a digital filter in ZPK form.
scipy.signal._signal_api.freqz_zpk

# Gammatone filter design.
scipy.signal._signal_api.gammatone

# Gaussian approximation to B-spline basis function of order n.
scipy.signal._signal_api.gauss_spline

# Return a Gaussian modulated sinusoid:
scipy.signal._signal_api.gausspulse

# Return a window of a given length and type.
scipy.signal._signal_api.get_window

# Compute the group delay of a digital filter.
scipy.signal._signal_api.group_delay

# FFT-based computation of the analytic signal.
scipy.signal._signal_api.hilbert

# Compute the '2-D' analytic signal of `x`
scipy.signal._signal_api.hilbert2

# Design IIR notching or peaking digital comb filter.
scipy.signal._signal_api.iircomb

# Complete IIR digital and analog filter design.
scipy.signal._signal_api.iirdesign

# IIR digital and analog filter design given order and critical points.
scipy.signal._signal_api.iirfilter

# Design second-order IIR notch digital filter.
scipy.signal._signal_api.iirnotch

# Design second-order IIR peak (resonant) digital filter.
scipy.signal._signal_api.iirpeak

# Impulse response of continuous-time system.
scipy.signal._signal_api.impulse

# Compute b(s) and a(s) from partial fraction expansion.
scipy.signal._signal_api.invres

# Compute b(z) and a(z) from partial fraction expansion.
scipy.signal._signal_api.invresz

# Perform the inverse Short Time Fourier transform (legacy function).
scipy.signal._signal_api.istft

# Compute the attenuation of a Kaiser FIR filter.
scipy.signal._signal_api.kaiser_atten

# Compute the Kaiser parameter `beta`, given the attenuation `a`.
scipy.signal._signal_api.kaiser_beta

# Determine the filter window parameters for the Kaiser window method.
scipy.signal._signal_api.kaiserord

# Filter data along one-dimension with an IIR or FIR filter.
scipy.signal._signal_api.lfilter

# Construct initial conditions for lfilter for step response steady-state.
scipy.signal._signal_api.lfilter_zi

# Construct initial conditions for lfilter given input and output vectors.
scipy.signal._signal_api.lfiltic

# Compute the generalized Lomb-Scargle periodogram.
scipy.signal._signal_api.lombscargle

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal._signal_api.lp2bp

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal._signal_api.lp2bp_zpk

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal._signal_api.lp2bs

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal._signal_api.lp2bs_zpk

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal._signal_api.lp2hp

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal._signal_api.lp2hp_zpk

# Transform a lowpass filter prototype to a different frequency.
scipy.signal._signal_api.lp2lp

# Transform a lowpass filter prototype to a different frequency.
scipy.signal._signal_api.lp2lp_zpk

# Simulate output of a continuous-time linear system.
scipy.signal._signal_api.lsim

# Continuous-time linear time invariant system base class.
scipy.signal._signal_api.lti

# Maximum length sequence (MLS) generator.
scipy.signal._signal_api.max_len_seq

# Perform a median filter on an N-dimensional array.
scipy.signal._signal_api.medfilt

# Median filter a 2-dimensional array.
scipy.signal._signal_api.medfilt2d

# Convert a linear-phase FIR filter to minimum phase
scipy.signal._signal_api.minimum_phase

# Normalize numerator/denominator of a continuous-time transfer function.
scipy.signal._signal_api.normalize

# Convolve two N-dimensional arrays using the overlap-add method.
scipy.signal._signal_api.oaconvolve

# Perform an order filter on an N-D array.
scipy.signal._signal_api.order_filter

# Calculate the prominence of each peak in a signal.
scipy.signal._signal_api.peak_prominences

# Calculate the width of each peak in a signal.
scipy.signal._signal_api.peak_widths

# Estimate power spectral density using a periodogram.
scipy.signal._signal_api.periodogram

# Compute K such that eigenvalues (A - dot(B, K))=poles.
scipy.signal._signal_api.place_poles

# Compute quadratic spline coefficients for rank-1 array.
scipy.signal._signal_api.qspline1d

# Evaluate a quadratic spline at the new set of points.
scipy.signal._signal_api.qspline1d_eval

# Coefficients for 2-D quadratic (2nd order) B-spline.
scipy.signal._signal_api.qspline2d

# Calculate the minimax optimal filter using the Remez exchange algorithm.
scipy.signal._signal_api.remez

# Resample `x` to `num` samples using the Fourier method along the given `axis`.
scipy.signal._signal_api.resample

# Resample `x` along the given axis using polyphase filtering.
scipy.signal._signal_api.resample_poly

# Compute partial-fraction expansion of b(s) / a(s).
scipy.signal._signal_api.residue

# Compute partial-fraction expansion of b(z) / a(z).
scipy.signal._signal_api.residuez

# Compute the coefficients for a 1-D Savitzky-Golay FIR filter.
scipy.signal._signal_api.savgol_coeffs

# Apply a Savitzky-Golay filter to an array.
scipy.signal._signal_api.savgol_filter

# Return a periodic sawtooth or triangle waveform.
scipy.signal._signal_api.sawtooth

# out = sepfir2d(input, hrow, hcol)
scipy.signal._signal_api.sepfir2d

# Return a single transfer function from a series of second-order sections
scipy.signal._signal_api.sos2tf

# Return zeros, poles, and gain of a series of second-order sections
scipy.signal._signal_api.sos2zpk

# Filter data along one dimension using cascaded second-order sections.
scipy.signal._signal_api.sosfilt

# Construct initial conditions for sosfilt for step response steady-state.
scipy.signal._signal_api.sosfilt_zi

# A forward-backward digital filter using cascaded second-order sections.
scipy.signal._signal_api.sosfiltfilt

# Compute the frequency response of a digital filter in SOS format (legacy).
scipy.signal._signal_api.sosfreqz

# Compute a spectrogram with consecutive Fourier transforms (legacy function).
scipy.signal._signal_api.spectrogram

# Smoothing spline (cubic) filtering of a rank-2 array.
scipy.signal._signal_api.spline_filter

# Return a periodic square-wave waveform.
scipy.signal._signal_api.square

# State-space to transfer function.
scipy.signal._signal_api.ss2tf

# State-space representation to zero-pole-gain representation.
scipy.signal._signal_api.ss2zpk

# Step response of continuous-time system.
scipy.signal._signal_api.step

# Compute the Short Time Fourier Transform (legacy function).
scipy.signal._signal_api.stft

# Frequency-swept cosine generator, with a time-dependent frequency.
scipy.signal._signal_api.sweep_poly

# Implement a smoothing IIR filter with mirror-symmetric boundary conditions
scipy.signal._signal_api.symiirorder1

# Implement a smoothing IIR filter with mirror-symmetric boundary conditions
scipy.signal._signal_api.symiirorder2

# Return second-order sections from transfer function representation
scipy.signal._signal_api.tf2sos

# Transfer function to state-space representation.
scipy.signal._signal_api.tf2ss

# Return zero, pole, gain (z, p, k) representation from a numerator,
scipy.signal._signal_api.tf2zpk

# Determine unique roots and their multiplicities from a list of roots.
scipy.signal._signal_api.unique_roots

# Unit impulse signal (discrete delta function) or unit basis vector.
scipy.signal._signal_api.unit_impulse

# Upsample, FIR filter, and downsample.
scipy.signal._signal_api.upfirdn

# Determine the vector strength of the events corresponding to the given
scipy.signal._signal_api.vectorstrength

# Estimate power spectral density using Welch's method.
scipy.signal._signal_api.welch

# Perform a Wiener filter on an N-dimensional array.
scipy.signal._signal_api.wiener

# Window functions (:mod:`scipy.signal.windows`)
scipy.signal._signal_api.windows

# Compute the DFT of `x` only for frequencies in range `fn`.
scipy.signal._signal_api.zoom_fft

# Return second-order sections from zeros, poles, and gain of a system
scipy.signal._signal_api.zpk2sos

# Zero-pole-gain representation to state-space representation
scipy.signal._signal_api.zpk2ss

# Return polynomial transfer function representation from zeros and poles
scipy.signal._signal_api.zpk2tf

# Find the fastest convolution/correlation method.
scipy.signal._signaltools.choose_conv_method

# Convolve two N-dimensional arrays.
scipy.signal._signaltools.convolve

# Convolve two 2-dimensional arrays.
scipy.signal._signaltools.convolve2d

# Cross-correlate two N-dimensional arrays.
scipy.signal._signaltools.correlate

# Cross-correlate two 2-dimensional arrays.
scipy.signal._signaltools.correlate2d

# Calculates the lag / displacement indices array for 1D cross-correlation.
scipy.signal._signaltools.correlation_lags

# Downsample the signal after applying an anti-aliasing filter.
scipy.signal._signaltools.decimate

# Deconvolves ``divisor`` out of ``signal`` using inverse filtering.
scipy.signal._signaltools.deconvolve

# Remove linear or constant trend along axis from data.
scipy.signal._signaltools.detrend

# Compute the envelope of a real- or complex-valued signal.
scipy.signal._signaltools.envelope

# Convolve two N-dimensional arrays using FFT.
scipy.signal._signaltools.fftconvolve

# Apply a digital filter forward and backward to a signal.
scipy.signal._signaltools.filtfilt

# FFT-based computation of the analytic signal.
scipy.signal._signaltools.hilbert

# Compute the '2-D' analytic signal of `x`
scipy.signal._signaltools.hilbert2

# Compute b(s) and a(s) from partial fraction expansion.
scipy.signal._signaltools.invres

# Compute b(z) and a(z) from partial fraction expansion.
scipy.signal._signaltools.invresz

# Filter data along one-dimension with an IIR or FIR filter.
scipy.signal._signaltools.lfilter

# Construct initial conditions for lfilter for step response steady-state.
scipy.signal._signaltools.lfilter_zi

# Construct initial conditions for lfilter given input and output vectors.
scipy.signal._signaltools.lfiltic

# Perform a median filter on an N-dimensional array.
scipy.signal._signaltools.medfilt

# Median filter a 2-dimensional array.
scipy.signal._signaltools.medfilt2d

# Convolve two N-dimensional arrays using the overlap-add method.
scipy.signal._signaltools.oaconvolve

# Perform an order filter on an N-D array.
scipy.signal._signaltools.order_filter

# Resample `x` to `num` samples using the Fourier method along the given `axis`.
scipy.signal._signaltools.resample

# Resample `x` along the given axis using polyphase filtering.
scipy.signal._signaltools.resample_poly

# Compute partial-fraction expansion of b(s) / a(s).
scipy.signal._signaltools.residue

# Compute partial-fraction expansion of b(z) / a(z).
scipy.signal._signaltools.residuez

# Filter data along one dimension using cascaded second-order sections.
scipy.signal._signaltools.sosfilt

# Construct initial conditions for sosfilt for step response steady-state.
scipy.signal._signaltools.sosfilt_zi

# A forward-backward digital filter using cascaded second-order sections.
scipy.signal._signaltools.sosfiltfilt

# Determine unique roots and their multiplicities from a list of roots.
scipy.signal._signaltools.unique_roots

# Determine the vector strength of the events corresponding to the given
scipy.signal._signaltools.vectorstrength

# Perform a Wiener filter on an N-dimensional array.
scipy.signal._signaltools.wiener

# Check whether the Constant OverLap Add (COLA) constraint is met
scipy.signal._spectral_py.check_COLA

# Check whether the Nonzero Overlap Add (NOLA) constraint is met.
scipy.signal._spectral_py.check_NOLA

# Estimate the magnitude squared coherence estimate, Cxy, of
scipy.signal._spectral_py.coherence

# Estimate the cross power spectral density, Pxy, using Welch's method.
scipy.signal._spectral_py.csd

# Perform the inverse Short Time Fourier transform (legacy function).
scipy.signal._spectral_py.istft

# Compute the generalized Lomb-Scargle periodogram.
scipy.signal._spectral_py.lombscargle

# Estimate power spectral density using a periodogram.
scipy.signal._spectral_py.periodogram

# Compute a spectrogram with consecutive Fourier transforms (legacy function).
scipy.signal._spectral_py.spectrogram

# Compute the Short Time Fourier Transform (legacy function).
scipy.signal._spectral_py.stft

# Estimate power spectral density using Welch's method.
scipy.signal._spectral_py.welch

# out = sepfir2d(input, hrow, hcol)
scipy.signal._spline.sepfir2d

# out = symiirorder1_ic(input, z1, precision=-1.0)
scipy.signal._spline.symiirorder1_ic

# out = symiirorder2_ic_bwd(input, r, omega, precision=-1.0)
scipy.signal._spline.symiirorder2_ic_bwd

# out = symiirorder2_ic_fwd(input, r, omega, precision=-1.0)
scipy.signal._spline.symiirorder2_ic_fwd

# Compute cubic spline coefficients for rank-1 array.
scipy.signal._spline_filters.cspline1d

# Evaluate a cubic spline at the new set of points.
scipy.signal._spline_filters.cspline1d_eval

# Coefficients for 2-D cubic (3rd order) B-spline.
scipy.signal._spline_filters.cspline2d

# Gaussian approximation to B-spline basis function of order n.
scipy.signal._spline_filters.gauss_spline

# Compute quadratic spline coefficients for rank-1 array.
scipy.signal._spline_filters.qspline1d

# Evaluate a quadratic spline at the new set of points.
scipy.signal._spline_filters.qspline1d_eval

# Coefficients for 2-D quadratic (2nd order) B-spline.
scipy.signal._spline_filters.qspline2d

# Smoothing spline (cubic) filtering of a rank-2 array.
scipy.signal._spline_filters.spline_filter

# Implement a smoothing IIR filter with mirror-symmetric boundary conditions
scipy.signal._spline_filters.symiirorder1

# Implement a smoothing IIR filter with mirror-symmetric boundary conditions
scipy.signal._spline_filters.symiirorder2

# Warning about badly conditioned filter coefficients
scipy.signal._support_alternative_backends.BadCoefficients

# Create a callable chirp z-transform function.
scipy.signal._support_alternative_backends.CZT

# Provide a parametrized discrete Short-time Fourier transform (stft)
scipy.signal._support_alternative_backends.ShortTimeFFT

# Linear Time Invariant system in state-space form.
scipy.signal._support_alternative_backends.StateSpace

# Linear Time Invariant system class in transfer function form.
scipy.signal._support_alternative_backends.TransferFunction

# Linear Time Invariant system class in zeros, poles, gain form.
scipy.signal._support_alternative_backends.ZerosPolesGain

# Create a callable zoom FFT transform function.
scipy.signal._support_alternative_backends.ZoomFFT

# Check state-space matrices and ensure they are 2-D.
scipy.signal._support_alternative_backends.abcd_normalize

# Calculate the relative extrema of `data`.
scipy.signal._support_alternative_backends.argrelextrema

# Calculate the relative maxima of `data`.
scipy.signal._support_alternative_backends.argrelmax

# Calculate the relative minima of `data`.
scipy.signal._support_alternative_backends.argrelmin

# Band Stop Objective Function for order minimization.
scipy.signal._support_alternative_backends.band_stop_obj

# Bessel/Thomson digital and analog filter design.
scipy.signal._support_alternative_backends.bessel

# Return (z,p,k) for analog prototype of an Nth-order Bessel filter.
scipy.signal._support_alternative_backends.besselap

# Calculate a digital IIR filter from an analog transfer function by utilizing
scipy.signal._support_alternative_backends.bilinear

# Return a digital IIR filter from an analog one using a bilinear transform.
scipy.signal._support_alternative_backends.bilinear_zpk

# Calculate Bode magnitude and phase data of a continuous-time system.
scipy.signal._support_alternative_backends.bode

# Return (z,p,k) for analog prototype of Nth-order Butterworth filter.
scipy.signal._support_alternative_backends.buttap

# Butterworth digital and analog filter design.
scipy.signal._support_alternative_backends.butter

# Butterworth filter order selection.
scipy.signal._support_alternative_backends.buttord

# Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.
scipy.signal._support_alternative_backends.cheb1ap

# Chebyshev type I filter order selection.
scipy.signal._support_alternative_backends.cheb1ord

# Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter.
scipy.signal._support_alternative_backends.cheb2ap

# Chebyshev type II filter order selection.
scipy.signal._support_alternative_backends.cheb2ord

# Chebyshev type I digital and analog filter design.
scipy.signal._support_alternative_backends.cheby1

# Chebyshev type II digital and analog filter design.
scipy.signal._support_alternative_backends.cheby2

# Check whether the Constant OverLap Add (COLA) constraint is met
scipy.signal._support_alternative_backends.check_COLA

# Check whether the Nonzero Overlap Add (NOLA) constraint is met.
scipy.signal._support_alternative_backends.check_NOLA

# Frequency-swept cosine generator.
scipy.signal._support_alternative_backends.chirp

# Find the fastest convolution/correlation method.
scipy.signal._support_alternative_backends.choose_conv_method

# Calculate the STFT dual window of a given window closest to a desired dual
scipy.signal._support_alternative_backends.closest_STFT_dual_window

# Estimate the magnitude squared coherence estimate, Cxy, of
scipy.signal._support_alternative_backends.coherence

# Transform a continuous to a discrete state-space system.
scipy.signal._support_alternative_backends.cont2discrete

# Convolve two N-dimensional arrays.
scipy.signal._support_alternative_backends.convolve

# Convolve two 2-dimensional arrays.
scipy.signal._support_alternative_backends.convolve2d

# Cross-correlate two N-dimensional arrays.
scipy.signal._support_alternative_backends.correlate

# Cross-correlate two 2-dimensional arrays.
scipy.signal._support_alternative_backends.correlate2d

# Calculates the lag / displacement indices array for 1D cross-correlation.
scipy.signal._support_alternative_backends.correlation_lags

# Estimate the cross power spectral density, Pxy, using Welch's method.
scipy.signal._support_alternative_backends.csd

# Compute cubic spline coefficients for rank-1 array.
scipy.signal._support_alternative_backends.cspline1d

# Evaluate a cubic spline at the new set of points.
scipy.signal._support_alternative_backends.cspline1d_eval

# Coefficients for 2-D cubic (3rd order) B-spline.
scipy.signal._support_alternative_backends.cspline2d

# Compute the frequency response around a spiral in the Z plane.
scipy.signal._support_alternative_backends.czt

# Return the points at which the chirp z-transform is computed.
scipy.signal._support_alternative_backends.czt_points

# Calculate Bode magnitude and phase data of a discrete-time system.
scipy.signal._support_alternative_backends.dbode

# Downsample the signal after applying an anti-aliasing filter.
scipy.signal._support_alternative_backends.decimate

# Deconvolves ``divisor`` out of ``signal`` using inverse filtering.
scipy.signal._support_alternative_backends.deconvolve

# Remove linear or constant trend along axis from data.
scipy.signal._support_alternative_backends.detrend

# Calculate the frequency response of a discrete-time system.
scipy.signal._support_alternative_backends.dfreqresp

# Impulse response of discrete-time system.
scipy.signal._support_alternative_backends.dimpulse

# Simulate output of a discrete-time linear system.
scipy.signal._support_alternative_backends.dlsim

# Discrete-time linear time invariant system base class.
scipy.signal._support_alternative_backends.dlti

# Step response of discrete-time system.
scipy.signal._support_alternative_backends.dstep

# Elliptic (Cauer) digital and analog filter design.
scipy.signal._support_alternative_backends.ellip

# Return (z,p,k) of Nth-order elliptic analog lowpass filter.
scipy.signal._support_alternative_backends.ellipap

# Elliptic (Cauer) filter order selection.
scipy.signal._support_alternative_backends.ellipord

# Compute the envelope of a real- or complex-valued signal.
scipy.signal._support_alternative_backends.envelope

# Convolve two N-dimensional arrays using FFT.
scipy.signal._support_alternative_backends.fftconvolve

# Apply a digital filter forward and backward to a signal.
scipy.signal._support_alternative_backends.filtfilt

# Find peaks inside a signal based on peak properties.
scipy.signal._support_alternative_backends.find_peaks

# Find peaks in a 1-D array with wavelet transformation.
scipy.signal._support_alternative_backends.find_peaks_cwt

# Find array of frequencies for computing the response of an analog filter.
scipy.signal._support_alternative_backends.findfreqs

# FIR filter design using least-squares error minimization.
scipy.signal._support_alternative_backends.firls

# FIR filter design using the window method.
scipy.signal._support_alternative_backends.firwin

# FIR filter design using the window method.
scipy.signal._support_alternative_backends.firwin2

# 2D FIR filter design using the window method.
scipy.signal._support_alternative_backends.firwin_2d

# Calculate the frequency response of a continuous-time system.
scipy.signal._support_alternative_backends.freqresp

# Compute frequency response of analog filter.
scipy.signal._support_alternative_backends.freqs

# Compute frequency response of analog filter.
scipy.signal._support_alternative_backends.freqs_zpk

# Compute the frequency response of a digital filter.
scipy.signal._support_alternative_backends.freqz

# Compute the frequency response of a digital filter in SOS format.
scipy.signal._support_alternative_backends.freqz_sos

# Compute the frequency response of a digital filter in ZPK form.
scipy.signal._support_alternative_backends.freqz_zpk

# Gammatone filter design.
scipy.signal._support_alternative_backends.gammatone

# Gaussian approximation to B-spline basis function of order n.
scipy.signal._support_alternative_backends.gauss_spline

# Return a Gaussian modulated sinusoid:
scipy.signal._support_alternative_backends.gausspulse

# Return a window of a given length and type.
scipy.signal._support_alternative_backends.get_window

# Compute the group delay of a digital filter.
scipy.signal._support_alternative_backends.group_delay

# FFT-based computation of the analytic signal.
scipy.signal._support_alternative_backends.hilbert

# Compute the '2-D' analytic signal of `x`
scipy.signal._support_alternative_backends.hilbert2

# Design IIR notching or peaking digital comb filter.
scipy.signal._support_alternative_backends.iircomb

# Complete IIR digital and analog filter design.
scipy.signal._support_alternative_backends.iirdesign

# IIR digital and analog filter design given order and critical points.
scipy.signal._support_alternative_backends.iirfilter

# Design second-order IIR notch digital filter.
scipy.signal._support_alternative_backends.iirnotch

# Design second-order IIR peak (resonant) digital filter.
scipy.signal._support_alternative_backends.iirpeak

# Impulse response of continuous-time system.
scipy.signal._support_alternative_backends.impulse

# Compute b(s) and a(s) from partial fraction expansion.
scipy.signal._support_alternative_backends.invres

# Compute b(z) and a(z) from partial fraction expansion.
scipy.signal._support_alternative_backends.invresz

# Perform the inverse Short Time Fourier transform (legacy function).
scipy.signal._support_alternative_backends.istft

# Compute the attenuation of a Kaiser FIR filter.
scipy.signal._support_alternative_backends.kaiser_atten

# Compute the Kaiser parameter `beta`, given the attenuation `a`.
scipy.signal._support_alternative_backends.kaiser_beta

# Determine the filter window parameters for the Kaiser window method.
scipy.signal._support_alternative_backends.kaiserord

# Filter data along one-dimension with an IIR or FIR filter.
scipy.signal._support_alternative_backends.lfilter

# Construct initial conditions for lfilter for step response steady-state.
scipy.signal._support_alternative_backends.lfilter_zi

# Construct initial conditions for lfilter given input and output vectors.
scipy.signal._support_alternative_backends.lfiltic

# Compute the generalized Lomb-Scargle periodogram.
scipy.signal._support_alternative_backends.lombscargle

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal._support_alternative_backends.lp2bp

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal._support_alternative_backends.lp2bp_zpk

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal._support_alternative_backends.lp2bs

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal._support_alternative_backends.lp2bs_zpk

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal._support_alternative_backends.lp2hp

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal._support_alternative_backends.lp2hp_zpk

# Transform a lowpass filter prototype to a different frequency.
scipy.signal._support_alternative_backends.lp2lp

# Transform a lowpass filter prototype to a different frequency.
scipy.signal._support_alternative_backends.lp2lp_zpk

# Simulate output of a continuous-time linear system.
scipy.signal._support_alternative_backends.lsim

# Continuous-time linear time invariant system base class.
scipy.signal._support_alternative_backends.lti

# Maximum length sequence (MLS) generator.
scipy.signal._support_alternative_backends.max_len_seq

# Perform a median filter on an N-dimensional array.
scipy.signal._support_alternative_backends.medfilt

# Median filter a 2-dimensional array.
scipy.signal._support_alternative_backends.medfilt2d

# Convert a linear-phase FIR filter to minimum phase
scipy.signal._support_alternative_backends.minimum_phase

# Normalize numerator/denominator of a continuous-time transfer function.
scipy.signal._support_alternative_backends.normalize

# Convolve two N-dimensional arrays using the overlap-add method.
scipy.signal._support_alternative_backends.oaconvolve

# Perform an order filter on an N-D array.
scipy.signal._support_alternative_backends.order_filter

# Calculate the prominence of each peak in a signal.
scipy.signal._support_alternative_backends.peak_prominences

# Calculate the width of each peak in a signal.
scipy.signal._support_alternative_backends.peak_widths

# Estimate power spectral density using a periodogram.
scipy.signal._support_alternative_backends.periodogram

# Compute K such that eigenvalues (A - dot(B, K))=poles.
scipy.signal._support_alternative_backends.place_poles

# Compute quadratic spline coefficients for rank-1 array.
scipy.signal._support_alternative_backends.qspline1d

# Evaluate a quadratic spline at the new set of points.
scipy.signal._support_alternative_backends.qspline1d_eval

# Coefficients for 2-D quadratic (2nd order) B-spline.
scipy.signal._support_alternative_backends.qspline2d

# Calculate the minimax optimal filter using the Remez exchange algorithm.
scipy.signal._support_alternative_backends.remez

# Resample `x` to `num` samples using the Fourier method along the given `axis`.
scipy.signal._support_alternative_backends.resample

# Resample `x` along the given axis using polyphase filtering.
scipy.signal._support_alternative_backends.resample_poly

# Compute partial-fraction expansion of b(s) / a(s).
scipy.signal._support_alternative_backends.residue

# Compute partial-fraction expansion of b(z) / a(z).
scipy.signal._support_alternative_backends.residuez

# Compute the coefficients for a 1-D Savitzky-Golay FIR filter.
scipy.signal._support_alternative_backends.savgol_coeffs

# Apply a Savitzky-Golay filter to an array.
scipy.signal._support_alternative_backends.savgol_filter

# Return a periodic sawtooth or triangle waveform.
scipy.signal._support_alternative_backends.sawtooth

# out = sepfir2d(input, hrow, hcol)
scipy.signal._support_alternative_backends.sepfir2d

# Return a single transfer function from a series of second-order sections
scipy.signal._support_alternative_backends.sos2tf

# Return zeros, poles, and gain of a series of second-order sections
scipy.signal._support_alternative_backends.sos2zpk

# Filter data along one dimension using cascaded second-order sections.
scipy.signal._support_alternative_backends.sosfilt

# Construct initial conditions for sosfilt for step response steady-state.
scipy.signal._support_alternative_backends.sosfilt_zi

# A forward-backward digital filter using cascaded second-order sections.
scipy.signal._support_alternative_backends.sosfiltfilt

# Compute the frequency response of a digital filter in SOS format (legacy).
scipy.signal._support_alternative_backends.sosfreqz

# Compute a spectrogram with consecutive Fourier transforms (legacy function).
scipy.signal._support_alternative_backends.spectrogram

# Smoothing spline (cubic) filtering of a rank-2 array.
scipy.signal._support_alternative_backends.spline_filter

# Return a periodic square-wave waveform.
scipy.signal._support_alternative_backends.square

# State-space to transfer function.
scipy.signal._support_alternative_backends.ss2tf

# State-space representation to zero-pole-gain representation.
scipy.signal._support_alternative_backends.ss2zpk

# Step response of continuous-time system.
scipy.signal._support_alternative_backends.step

# Compute the Short Time Fourier Transform (legacy function).
scipy.signal._support_alternative_backends.stft

# Frequency-swept cosine generator, with a time-dependent frequency.
scipy.signal._support_alternative_backends.sweep_poly

# Implement a smoothing IIR filter with mirror-symmetric boundary conditions
scipy.signal._support_alternative_backends.symiirorder1

# Implement a smoothing IIR filter with mirror-symmetric boundary conditions
scipy.signal._support_alternative_backends.symiirorder2

# Return second-order sections from transfer function representation
scipy.signal._support_alternative_backends.tf2sos

# Transfer function to state-space representation.
scipy.signal._support_alternative_backends.tf2ss

# Return zero, pole, gain (z, p, k) representation from a numerator,
scipy.signal._support_alternative_backends.tf2zpk

# Determine unique roots and their multiplicities from a list of roots.
scipy.signal._support_alternative_backends.unique_roots

# Unit impulse signal (discrete delta function) or unit basis vector.
scipy.signal._support_alternative_backends.unit_impulse

# Upsample, FIR filter, and downsample.
scipy.signal._support_alternative_backends.upfirdn

# Determine the vector strength of the events corresponding to the given
scipy.signal._support_alternative_backends.vectorstrength

# Estimate power spectral density using Welch's method.
scipy.signal._support_alternative_backends.welch

# Perform a Wiener filter on an N-dimensional array.
scipy.signal._support_alternative_backends.wiener

# Window functions (:mod:`scipy.signal.windows`)
scipy.signal._support_alternative_backends.windows

# Compute the DFT of `x` only for frequencies in range `fn`.
scipy.signal._support_alternative_backends.zoom_fft

# Return second-order sections from zeros, poles, and gain of a system
scipy.signal._support_alternative_backends.zpk2sos

# Zero-pole-gain representation to state-space representation
scipy.signal._support_alternative_backends.zpk2ss

# Return polynomial transfer function representation from zeros and poles
scipy.signal._support_alternative_backends.zpk2tf

# The output length that results from a given input
scipy.signal._upfirdn._output_len

# Upsample, FIR filter, and downsample.
scipy.signal._upfirdn.upfirdn

scipy.signal._upfirdn_apply.mode_enum

# NumPy
scipy.signal._upfirdn_apply.np

# Frequency-swept cosine generator.
scipy.signal._waveforms.chirp

# Return a Gaussian modulated sinusoid:
scipy.signal._waveforms.gausspulse

# Return a periodic sawtooth or triangle waveform.
scipy.signal._waveforms.sawtooth

# Return a periodic square-wave waveform.
scipy.signal._waveforms.square

# Frequency-swept cosine generator, with a time-dependent frequency.
scipy.signal._waveforms.sweep_poly

# Unit impulse signal (discrete delta function) or unit basis vector.
scipy.signal._waveforms.unit_impulse

# Convolve two N-dimensional arrays.
scipy.signal._wavelets.convolve

# NumPy
scipy.signal._wavelets.np

# Compute cubic spline coefficients for rank-1 array.
scipy.signal.bsplines.cspline1d

# Evaluate a cubic spline at the new set of points.
scipy.signal.bsplines.cspline1d_eval

# Coefficients for 2-D cubic (3rd order) B-spline.
scipy.signal.bsplines.cspline2d

# Gaussian approximation to B-spline basis function of order n.
scipy.signal.bsplines.gauss_spline

# Compute quadratic spline coefficients for rank-1 array.
scipy.signal.bsplines.qspline1d

# Evaluate a quadratic spline at the new set of points.
scipy.signal.bsplines.qspline1d_eval

# out = sepfir2d(input, hrow, hcol)
scipy.signal.bsplines.sepfir2d

# Smoothing spline (cubic) filtering of a rank-2 array.
scipy.signal.bsplines.spline_filter

# Warning about badly conditioned filter coefficients
scipy.signal.filter_design.BadCoefficients

# Band Stop Objective Function for order minimization.
scipy.signal.filter_design.band_stop_obj

# Bessel/Thomson digital and analog filter design.
scipy.signal.filter_design.bessel

# Return (z,p,k) for analog prototype of an Nth-order Bessel filter.
scipy.signal.filter_design.besselap

# Calculate a digital IIR filter from an analog transfer function by utilizing
scipy.signal.filter_design.bilinear

# Return a digital IIR filter from an analog one using a bilinear transform.
scipy.signal.filter_design.bilinear_zpk

# Return (z,p,k) for analog prototype of Nth-order Butterworth filter.
scipy.signal.filter_design.buttap

# Butterworth digital and analog filter design.
scipy.signal.filter_design.butter

# Butterworth filter order selection.
scipy.signal.filter_design.buttord

# Return (z,p,k) for Nth-order Chebyshev type I analog lowpass filter.
scipy.signal.filter_design.cheb1ap

# Chebyshev type I filter order selection.
scipy.signal.filter_design.cheb1ord

# Return (z,p,k) for Nth-order Chebyshev type II analog lowpass filter.
scipy.signal.filter_design.cheb2ap

# Chebyshev type II filter order selection.
scipy.signal.filter_design.cheb2ord

# Chebyshev type I digital and analog filter design.
scipy.signal.filter_design.cheby1

# Chebyshev type II digital and analog filter design.
scipy.signal.filter_design.cheby2

# Elliptic (Cauer) digital and analog filter design.
scipy.signal.filter_design.ellip

# Return (z,p,k) of Nth-order elliptic analog lowpass filter.
scipy.signal.filter_design.ellipap

# Elliptic (Cauer) filter order selection.
scipy.signal.filter_design.ellipord

# Find array of frequencies for computing the response of an analog filter.
scipy.signal.filter_design.findfreqs

# Compute frequency response of analog filter.
scipy.signal.filter_design.freqs

# Compute frequency response of analog filter.
scipy.signal.filter_design.freqs_zpk

# Compute the frequency response of a digital filter.
scipy.signal.filter_design.freqz

# Compute the frequency response of a digital filter in SOS format.
scipy.signal.filter_design.freqz_sos

# Compute the frequency response of a digital filter in ZPK form.
scipy.signal.filter_design.freqz_zpk

# Gammatone filter design.
scipy.signal.filter_design.gammatone

# Compute the group delay of a digital filter.
scipy.signal.filter_design.group_delay

# Design IIR notching or peaking digital comb filter.
scipy.signal.filter_design.iircomb

# Complete IIR digital and analog filter design.
scipy.signal.filter_design.iirdesign

# IIR digital and analog filter design given order and critical points.
scipy.signal.filter_design.iirfilter

# Design second-order IIR notch digital filter.
scipy.signal.filter_design.iirnotch

# Design second-order IIR peak (resonant) digital filter.
scipy.signal.filter_design.iirpeak

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal.filter_design.lp2bp

# Transform a lowpass filter prototype to a bandpass filter.
scipy.signal.filter_design.lp2bp_zpk

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal.filter_design.lp2bs

# Transform a lowpass filter prototype to a bandstop filter.
scipy.signal.filter_design.lp2bs_zpk

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal.filter_design.lp2hp

# Transform a lowpass filter prototype to a highpass filter.
scipy.signal.filter_design.lp2hp_zpk

# Transform a lowpass filter prototype to a different frequency.
scipy.signal.filter_design.lp2lp

# Transform a lowpass filter prototype to a different frequency.
scipy.signal.filter_design.lp2lp_zpk

# Normalize numerator/denominator of a continuous-time transfer function.
scipy.signal.filter_design.normalize

# Return a single transfer function from a series of second-order sections
scipy.signal.filter_design.sos2tf

# Return zeros, poles, and gain of a series of second-order sections
scipy.signal.filter_design.sos2zpk

# Compute the frequency response of a digital filter in SOS format (legacy).
scipy.signal.filter_design.sosfreqz

# Return second-order sections from transfer function representation
scipy.signal.filter_design.tf2sos

# Return zero, pole, gain (z, p, k) representation from a numerator,
scipy.signal.filter_design.tf2zpk

# Return second-order sections from zeros, poles, and gain of a system
scipy.signal.filter_design.zpk2sos

# Return polynomial transfer function representation from zeros and poles
scipy.signal.filter_design.zpk2tf

# FIR filter design using least-squares error minimization.
scipy.signal.fir_filter_design.firls

# FIR filter design using the window method.
scipy.signal.fir_filter_design.firwin

# FIR filter design using the window method.
scipy.signal.fir_filter_design.firwin2

# 2D FIR filter design using the window method.
scipy.signal.fir_filter_design.firwin_2d

# Compute the attenuation of a Kaiser FIR filter.
scipy.signal.fir_filter_design.kaiser_atten

# Compute the Kaiser parameter `beta`, given the attenuation `a`.
scipy.signal.fir_filter_design.kaiser_beta

# Determine the filter window parameters for the Kaiser window method.
scipy.signal.fir_filter_design.kaiserord

# Convert a linear-phase FIR filter to minimum phase
scipy.signal.fir_filter_design.minimum_phase

# Calculate the minimax optimal filter using the Remez exchange algorithm.
scipy.signal.fir_filter_design.remez

# Check state-space matrices and ensure they are 2-D.
scipy.signal.lti_conversion.abcd_normalize

# Transform a continuous to a discrete state-space system.
scipy.signal.lti_conversion.cont2discrete

# Normalize numerator/denominator of a continuous-time transfer function.
scipy.signal.lti_conversion.normalize

# State-space to transfer function.
scipy.signal.lti_conversion.ss2tf

# State-space representation to zero-pole-gain representation.
scipy.signal.lti_conversion.ss2zpk

# Transfer function to state-space representation.
scipy.signal.lti_conversion.tf2ss

# Return zero, pole, gain (z, p, k) representation from a numerator,
scipy.signal.lti_conversion.tf2zpk

# Zero-pole-gain representation to state-space representation
scipy.signal.lti_conversion.zpk2ss

# Return polynomial transfer function representation from zeros and poles
scipy.signal.lti_conversion.zpk2tf

# Linear Time Invariant system in state-space form.
scipy.signal.ltisys.StateSpace

# Linear Time Invariant system class in transfer function form.
scipy.signal.ltisys.TransferFunction

# Linear Time Invariant system class in zeros, poles, gain form.
scipy.signal.ltisys.ZerosPolesGain

# Check state-space matrices and ensure they are 2-D.
scipy.signal.ltisys.abcd_normalize

# Calculate Bode magnitude and phase data of a continuous-time system.
scipy.signal.ltisys.bode

# Transform a continuous to a discrete state-space system.
scipy.signal.ltisys.cont2discrete

# Calculate Bode magnitude and phase data of a discrete-time system.
scipy.signal.ltisys.dbode

# Calculate the frequency response of a discrete-time system.
scipy.signal.ltisys.dfreqresp

# Impulse response of discrete-time system.
scipy.signal.ltisys.dimpulse

# Simulate output of a discrete-time linear system.
scipy.signal.ltisys.dlsim

# Discrete-time linear time invariant system base class.
scipy.signal.ltisys.dlti

# Step response of discrete-time system.
scipy.signal.ltisys.dstep

# Calculate the frequency response of a continuous-time system.
scipy.signal.ltisys.freqresp

# Compute frequency response of analog filter.
scipy.signal.ltisys.freqs

# Compute frequency response of analog filter.
scipy.signal.ltisys.freqs_zpk

# Compute the frequency response of a digital filter.
scipy.signal.ltisys.freqz

# Compute the frequency response of a digital filter in ZPK form.
scipy.signal.ltisys.freqz_zpk

# Impulse response of continuous-time system.
scipy.signal.ltisys.impulse

# Simulate output of a continuous-time linear system.
scipy.signal.ltisys.lsim

# Continuous-time linear time invariant system base class.
scipy.signal.ltisys.lti

# Normalize numerator/denominator of a continuous-time transfer function.
scipy.signal.ltisys.normalize

# Compute K such that eigenvalues (A - dot(B, K))=poles.
scipy.signal.ltisys.place_poles

# State-space to transfer function.
scipy.signal.ltisys.ss2tf

# State-space representation to zero-pole-gain representation.
scipy.signal.ltisys.ss2zpk

# Step response of continuous-time system.
scipy.signal.ltisys.step

# Transfer function to state-space representation.
scipy.signal.ltisys.tf2ss

# Return zero, pole, gain (z, p, k) representation from a numerator,
scipy.signal.ltisys.tf2zpk

# Zero-pole-gain representation to state-space representation
scipy.signal.ltisys.zpk2ss

# Return polynomial transfer function representation from zeros and poles
scipy.signal.ltisys.zpk2tf

# Chebyshev type I digital and analog filter design.
scipy.signal.signaltools.cheby1

# Find the fastest convolution/correlation method.
scipy.signal.signaltools.choose_conv_method

# Convolve two N-dimensional arrays.
scipy.signal.signaltools.convolve

# Convolve two 2-dimensional arrays.
scipy.signal.signaltools.convolve2d

# Cross-correlate two N-dimensional arrays.
scipy.signal.signaltools.correlate

# Cross-correlate two 2-dimensional arrays.
scipy.signal.signaltools.correlate2d

# Calculates the lag / displacement indices array for 1D cross-correlation.
scipy.signal.signaltools.correlation_lags

# Downsample the signal after applying an anti-aliasing filter.
scipy.signal.signaltools.decimate

# Deconvolves ``divisor`` out of ``signal`` using inverse filtering.
scipy.signal.signaltools.deconvolve

# Remove linear or constant trend along axis from data.
scipy.signal.signaltools.detrend

# Discrete-time linear time invariant system base class.
scipy.signal.signaltools.dlti

# Convolve two N-dimensional arrays using FFT.
scipy.signal.signaltools.fftconvolve

# Apply a digital filter forward and backward to a signal.
scipy.signal.signaltools.filtfilt

# FIR filter design using the window method.
scipy.signal.signaltools.firwin

# Return a window of a given length and type.
scipy.signal.signaltools.get_window

# FFT-based computation of the analytic signal.
scipy.signal.signaltools.hilbert

# Compute the '2-D' analytic signal of `x`
scipy.signal.signaltools.hilbert2

# Compute b(s) and a(s) from partial fraction expansion.
scipy.signal.signaltools.invres

# Compute b(z) and a(z) from partial fraction expansion.
scipy.signal.signaltools.invresz

# Filter data along one-dimension with an IIR or FIR filter.
scipy.signal.signaltools.lfilter

# Construct initial conditions for lfilter for step response steady-state.
scipy.signal.signaltools.lfilter_zi

# Construct initial conditions for lfilter given input and output vectors.
scipy.signal.signaltools.lfiltic

# Perform a median filter on an N-dimensional array.
scipy.signal.signaltools.medfilt

# Median filter a 2-dimensional array.
scipy.signal.signaltools.medfilt2d

# Convolve two N-dimensional arrays using the overlap-add method.
scipy.signal.signaltools.oaconvolve

# Perform an order filter on an N-D array.
scipy.signal.signaltools.order_filter

# Resample `x` to `num` samples using the Fourier method along the given `axis`.
scipy.signal.signaltools.resample

# Resample `x` along the given axis using polyphase filtering.
scipy.signal.signaltools.resample_poly

# Compute partial-fraction expansion of b(s) / a(s).
scipy.signal.signaltools.residue

# Compute partial-fraction expansion of b(z) / a(z).
scipy.signal.signaltools.residuez

# Filter data along one dimension using cascaded second-order sections.
scipy.signal.signaltools.sosfilt

# Construct initial conditions for sosfilt for step response steady-state.
scipy.signal.signaltools.sosfilt_zi

# A forward-backward digital filter using cascaded second-order sections.
scipy.signal.signaltools.sosfiltfilt

# Determine unique roots and their multiplicities from a list of roots.
scipy.signal.signaltools.unique_roots

# Upsample, FIR filter, and downsample.
scipy.signal.signaltools.upfirdn

# Determine the vector strength of the events corresponding to the given
scipy.signal.signaltools.vectorstrength

# Perform a Wiener filter on an N-dimensional array.
scipy.signal.signaltools.wiener

# Check whether the Constant OverLap Add (COLA) constraint is met
scipy.signal.spectral.check_COLA

# Check whether the Nonzero Overlap Add (NOLA) constraint is met.
scipy.signal.spectral.check_NOLA

# Estimate the magnitude squared coherence estimate, Cxy, of
scipy.signal.spectral.coherence

# Estimate the cross power spectral density, Pxy, using Welch's method.
scipy.signal.spectral.csd

# Return a window of a given length and type.
scipy.signal.spectral.get_window

# Perform the inverse Short Time Fourier transform (legacy function).
scipy.signal.spectral.istft

# Compute the generalized Lomb-Scargle periodogram.
scipy.signal.spectral.lombscargle

# Estimate power spectral density using a periodogram.
scipy.signal.spectral.periodogram

# Compute a spectrogram with consecutive Fourier transforms (legacy function).
scipy.signal.spectral.spectrogram

# Compute the Short Time Fourier Transform (legacy function).
scipy.signal.spectral.stft

# Estimate power spectral density using Welch's method.
scipy.signal.spectral.welch

# out = sepfir2d(input, hrow, hcol)
scipy.signal.spline.sepfir2d

# Frequency-swept cosine generator.
scipy.signal.waveforms.chirp

# Return a Gaussian modulated sinusoid:
scipy.signal.waveforms.gausspulse

# Return a periodic sawtooth or triangle waveform.
scipy.signal.waveforms.sawtooth

# Return a periodic square-wave waveform.
scipy.signal.waveforms.square

# Frequency-swept cosine generator, with a time-dependent frequency.
scipy.signal.waveforms.sweep_poly

# Unit impulse signal (discrete delta function) or unit basis vector.
scipy.signal.waveforms.unit_impulse

# Return a modified Bartlett-Hann window.
scipy.signal.windows._windows.barthann

# Return a Bartlett window.
scipy.signal.windows._windows.bartlett

# Return a Blackman window.
scipy.signal.windows._windows.blackman

# Return a minimum 4-term Blackman-Harris window.
scipy.signal.windows._windows.blackmanharris

# Return a Bohman window.
scipy.signal.windows._windows.bohman

# Return a boxcar or rectangular window.
scipy.signal.windows._windows.boxcar

# Return a Dolph-Chebyshev window.
scipy.signal.windows._windows.chebwin

# Return a window with a simple cosine shape.
scipy.signal.windows._windows.cosine

# Compute the Discrete Prolate Spheroidal Sequences (DPSS).
scipy.signal.windows._windows.dpss

# Return an exponential (or Poisson) window.
scipy.signal.windows._windows.exponential

# Return a flat top window.
scipy.signal.windows._windows.flattop

# Return a Gaussian window.
scipy.signal.windows._windows.gaussian

# Generic weighted sum of cosine terms window
scipy.signal.windows._windows.general_cosine

# Return a window with a generalized Gaussian shape.
scipy.signal.windows._windows.general_gaussian

# Return a generalized Hamming window.
scipy.signal.windows._windows.general_hamming

# Return a window of a given length and type.
scipy.signal.windows._windows.get_window

# Return a Hamming window.
scipy.signal.windows._windows.hamming

# Return a Hann window.
scipy.signal.windows._windows.hann

# Return a Kaiser window.
scipy.signal.windows._windows.kaiser

# Return a Kaiser-Bessel derived window.
scipy.signal.windows._windows.kaiser_bessel_derived

# Return a Lanczos window also known as a sinc window.
scipy.signal.windows._windows.lanczos

# Return a minimum 4-term Blackman-Harris window according to Nuttall.
scipy.signal.windows._windows.nuttall

# Return a Parzen window.
scipy.signal.windows._windows.parzen

# Return a Taylor window.
scipy.signal.windows._windows.taylor

# Return a triangular window.
scipy.signal.windows._windows.triang

# Return a Tukey window, also known as a tapered cosine window.
scipy.signal.windows._windows.tukey

# Return a modified Bartlett-Hann window.
scipy.signal.windows.windows.barthann

# Return a Bartlett window.
scipy.signal.windows.windows.bartlett

# Return a Blackman window.
scipy.signal.windows.windows.blackman

# Return a minimum 4-term Blackman-Harris window.
scipy.signal.windows.windows.blackmanharris

# Return a Bohman window.
scipy.signal.windows.windows.bohman

# Return a boxcar or rectangular window.
scipy.signal.windows.windows.boxcar

# Return a Dolph-Chebyshev window.
scipy.signal.windows.windows.chebwin

# Return a window with a simple cosine shape.
scipy.signal.windows.windows.cosine

# Compute the Discrete Prolate Spheroidal Sequences (DPSS).
scipy.signal.windows.windows.dpss

# Return an exponential (or Poisson) window.
scipy.signal.windows.windows.exponential

# Return a flat top window.
scipy.signal.windows.windows.flattop

# Return a Gaussian window.
scipy.signal.windows.windows.gaussian

# Generic weighted sum of cosine terms window
scipy.signal.windows.windows.general_cosine

# Return a window with a generalized Gaussian shape.
scipy.signal.windows.windows.general_gaussian

# Return a generalized Hamming window.
scipy.signal.windows.windows.general_hamming

# Return a window of a given length and type.
scipy.signal.windows.windows.get_window

# Return a Hamming window.
scipy.signal.windows.windows.hamming

# Return a Hann window.
scipy.signal.windows.windows.hann

# Return a Kaiser window.
scipy.signal.windows.windows.kaiser

# Return a minimum 4-term Blackman-Harris window according to Nuttall.
scipy.signal.windows.windows.nuttall

# Return a Parzen window.
scipy.signal.windows.windows.parzen

# Return a Taylor window.
scipy.signal.windows.windows.taylor

# Return a triangular window.
scipy.signal.windows.windows.triang

# Return a Tukey window, also known as a tapered cosine window.
scipy.signal.windows.windows.tukey

# The warning emitted when the operation is
scipy.sparse._base.SparseEfficiencyWarning

# General warning for :mod:`scipy.sparse`.
scipy.sparse._base.SparseWarning

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse._base.issparse

# Is `x` of a sparse matrix type?
scipy.sparse._base.isspmatrix

# This class provides a base class for all sparse arrays.  It
scipy.sparse._base.sparray

# Block Sparse Row format sparse array.
scipy.sparse._bsr.bsr_array

# Block Sparse Row format sparse matrix.
scipy.sparse._bsr.bsr_matrix

# Is `x` of a bsr_matrix type?
scipy.sparse._bsr.isspmatrix_bsr

# Build a sparse array from sparse sub-blocks
scipy.sparse._construct.block_array

# Build a block diagonal sparse matrix or array from provided matrices.
scipy.sparse._construct.block_diag

# Build a sparse array or matrix from sparse sub-blocks
scipy.sparse._construct.bmat

# Construct a sparse matrix from diagonals.
scipy.sparse._construct.diags

# Construct a sparse array from diagonals.
scipy.sparse._construct.diags_array

# Sparse matrix of chosen shape with ones on the kth diagonal and zeros elsewhere.
scipy.sparse._construct.eye

# Sparse array of chosen shape with ones on the kth diagonal and zeros elsewhere.
scipy.sparse._construct.eye_array

# Stack sparse matrices horizontally (column wise)
scipy.sparse._construct.hstack

# Identity matrix in sparse format
scipy.sparse._construct.identity

# kronecker product of sparse matrices A and B
scipy.sparse._construct.kron

# kronecker sum of square sparse matrices A and B
scipy.sparse._construct.kronsum

# Generate a sparse matrix of the given shape and density with uniformly
scipy.sparse._construct.rand

# Generate a sparse matrix of the given shape and density with randomly
scipy.sparse._construct.random

# Return a sparse array of uniformly random numbers in [0, 1)
scipy.sparse._construct.random_array

# Return a sparse matrix from diagonals.
scipy.sparse._construct.spdiags

# Stack sparse arrays vertically (row wise)
scipy.sparse._construct.vstack

# A sparse array in COOrdinate format.
scipy.sparse._coo.coo_array

# A sparse matrix in COOrdinate format.
scipy.sparse._coo.coo_matrix

# Is `x` of coo_matrix type?
scipy.sparse._coo.isspmatrix_coo

# Compressed Sparse Column array.
scipy.sparse._csc.csc_array

# Compressed Sparse Column matrix.
scipy.sparse._csc.csc_matrix

# Is `x` of csc_matrix type?
scipy.sparse._csc.isspmatrix_csc

# Get multiple items at given indices in LIL matrix and store to
scipy.sparse._csparsetools.lil_fancy_get

# Set multiple items to a LIL matrix.
scipy.sparse._csparsetools.lil_fancy_set

scipy.sparse._csparsetools.lil_flatten_to_array

# Get a single item from LIL matrix.
scipy.sparse._csparsetools.lil_get1

scipy.sparse._csparsetools.lil_get_lengths

# Column-slicing fast path for LIL matrices.
scipy.sparse._csparsetools.lil_get_row_ranges

# Insert a single item to LIL matrix.
scipy.sparse._csparsetools.lil_insert

# NumPy
scipy.sparse._csparsetools.np

# Compressed Sparse Row array.
scipy.sparse._csr.csr_array

# Compressed Sparse Row matrix.
scipy.sparse._csr.csr_matrix

# Is `x` of csr_matrix type?
scipy.sparse._csr.isspmatrix_csr

# Sparse array with DIAgonal storage.
scipy.sparse._dia.dia_array

# Sparse matrix with DIAgonal storage.
scipy.sparse._dia.dia_matrix

# Is `x` of dia_matrix type?
scipy.sparse._dia.isspmatrix_dia

# Dictionary Of Keys based sparse array.
scipy.sparse._dok.dok_array

# Dictionary Of Keys based sparse matrix.
scipy.sparse._dok.dok_matrix

# Is `x` of dok_array type?
scipy.sparse._dok.isspmatrix_dok

# Return the indices and values of the nonzero elements of a matrix
scipy.sparse._extract.find

# Return the lower triangular portion of a sparse array or matrix
scipy.sparse._extract.tril

# Return the upper triangular portion of a sparse array or matrix
scipy.sparse._extract.triu

# Built-in immutable sequence.
scipy.sparse._index.INT_TYPES

# This class provides common dispatching and validation logic for indexing.
scipy.sparse._index.IndexMixin

# Is x appropriate as an index into a sparse matrix? Returns True
scipy.sparse._index.isintlike

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse._index.issparse

# NumPy
scipy.sparse._index.np

# This class provides a base class for all sparse arrays.  It
scipy.sparse._index.sparray

# Is `x` of lil_matrix type?
scipy.sparse._lil.isspmatrix_lil

# Row-based LIst of Lists sparse array.
scipy.sparse._lil.lil_array

# Row-based LIst of Lists sparse matrix.
scipy.sparse._lil.lil_matrix

# This class provides a base class for all sparse matrix classes.
scipy.sparse._matrix.spmatrix

# Load a sparse array/matrix from a file using ``.npz`` format.
scipy.sparse._matrix_io.load_npz

# Save a sparse matrix or array to a file using ``.npz`` format.
scipy.sparse._matrix_io.save_npz

scipy.sparse._sparsetools.bsr_diagonal

scipy.sparse._sparsetools.bsr_eldiv_bsr

scipy.sparse._sparsetools.bsr_elmul_bsr

scipy.sparse._sparsetools.bsr_ge_bsr

scipy.sparse._sparsetools.bsr_gt_bsr

scipy.sparse._sparsetools.bsr_le_bsr

scipy.sparse._sparsetools.bsr_lt_bsr

scipy.sparse._sparsetools.bsr_matmat

scipy.sparse._sparsetools.bsr_matvec

scipy.sparse._sparsetools.bsr_matvecs

scipy.sparse._sparsetools.bsr_maximum_bsr

scipy.sparse._sparsetools.bsr_minimum_bsr

scipy.sparse._sparsetools.bsr_minus_bsr

scipy.sparse._sparsetools.bsr_ne_bsr

scipy.sparse._sparsetools.bsr_plus_bsr

scipy.sparse._sparsetools.bsr_scale_columns

scipy.sparse._sparsetools.bsr_scale_rows

scipy.sparse._sparsetools.bsr_sort_indices

scipy.sparse._sparsetools.bsr_tocsr

scipy.sparse._sparsetools.bsr_transpose

scipy.sparse._sparsetools.coo_matmat_dense

scipy.sparse._sparsetools.coo_matmat_dense_nd

scipy.sparse._sparsetools.coo_matvec

scipy.sparse._sparsetools.coo_matvec_nd

scipy.sparse._sparsetools.coo_tocsr

scipy.sparse._sparsetools.coo_todense

scipy.sparse._sparsetools.coo_todense_nd

scipy.sparse._sparsetools.cs_graph_components

scipy.sparse._sparsetools.csc_matvec

scipy.sparse._sparsetools.csc_matvecs

scipy.sparse._sparsetools.csr_column_index1

scipy.sparse._sparsetools.csr_column_index2

scipy.sparse._sparsetools.csr_count_blocks

scipy.sparse._sparsetools.csr_diagonal

scipy.sparse._sparsetools.csr_eldiv_csr

scipy.sparse._sparsetools.csr_eliminate_zeros

scipy.sparse._sparsetools.csr_elmul_csr

scipy.sparse._sparsetools.csr_ge_csr

scipy.sparse._sparsetools.csr_gt_csr

scipy.sparse._sparsetools.csr_has_canonical_format

scipy.sparse._sparsetools.csr_has_sorted_indices

scipy.sparse._sparsetools.csr_hstack

scipy.sparse._sparsetools.csr_le_csr

scipy.sparse._sparsetools.csr_lt_csr

scipy.sparse._sparsetools.csr_matmat

scipy.sparse._sparsetools.csr_matmat_maxnnz

scipy.sparse._sparsetools.csr_matvec

scipy.sparse._sparsetools.csr_matvecs

scipy.sparse._sparsetools.csr_maximum_csr

scipy.sparse._sparsetools.csr_minimum_csr

scipy.sparse._sparsetools.csr_minus_csr

scipy.sparse._sparsetools.csr_ne_csr

scipy.sparse._sparsetools.csr_plus_csr

scipy.sparse._sparsetools.csr_row_index

scipy.sparse._sparsetools.csr_row_slice

scipy.sparse._sparsetools.csr_sample_offsets

scipy.sparse._sparsetools.csr_sample_values

scipy.sparse._sparsetools.csr_scale_columns

scipy.sparse._sparsetools.csr_scale_rows

scipy.sparse._sparsetools.csr_sort_indices

scipy.sparse._sparsetools.csr_sum_duplicates

scipy.sparse._sparsetools.csr_tobsr

scipy.sparse._sparsetools.csr_tocsc

scipy.sparse._sparsetools.csr_todense

scipy.sparse._sparsetools.dia_matmat

scipy.sparse._sparsetools.dia_matvec

scipy.sparse._sparsetools.dia_matvecs

scipy.sparse._sparsetools.expandptr

scipy.sparse._sparsetools.get_csr_submatrix

scipy.sparse._sparsetools.test_throw_error

# For a given blocksize=(r,c) count the number of occupied
scipy.sparse._spfuncs.count_blocks

# Attempt to determine the blocksize of a sparse matrix
scipy.sparse._spfuncs.estimate_blocksize

# Check if shapes can be broadcast and return resulting shape
scipy.sparse._sputils.broadcast_shapes

# Mimic numpy's casting for np.sum
scipy.sparse._sputils.get_sum_dtype

# This is a wrapper of `np.array(obj, dtype=dtype, copy=copy)`
scipy.sparse._sputils.getdata

# Form a supported numpy dtype based on input arguments.
scipy.sparse._sputils.getdtype

scipy.sparse._sputils.isdense

# Is x appropriate as an index into a sparse matrix? Returns True
scipy.sparse._sputils.isintlike

scipy.sparse._sputils.ismatrix

# Is x either a scalar, an array scalar, or a 0-dim array?
scipy.sparse._sputils.isscalarlike

scipy.sparse._sputils.issequence

# Is x a valid tuple of dimensions?
scipy.sparse._sputils.isshape

# Returns the nearest supported sparse dtype for the
scipy.sparse._sputils.upcast

# The warning emitted when the operation is
scipy.sparse.base.SparseEfficiencyWarning

# General warning for :mod:`scipy.sparse`.
scipy.sparse.base.SparseWarning

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.base.issparse

# Is `x` of a sparse matrix type?
scipy.sparse.base.isspmatrix

# This class provides a base class for all sparse matrix classes.
scipy.sparse.base.spmatrix

# Block Sparse Row format sparse matrix.
scipy.sparse.bsr.bsr_matrix

# Is `x` of a bsr_matrix type?
scipy.sparse.bsr.isspmatrix_bsr

# This class provides a base class for all sparse matrix classes.
scipy.sparse.bsr.spmatrix

# The warning emitted when the operation is
scipy.sparse.compressed.SparseEfficiencyWarning

# Build a block diagonal sparse matrix or array from provided matrices.
scipy.sparse.construct.block_diag

# Build a sparse array or matrix from sparse sub-blocks
scipy.sparse.construct.bmat

# Block Sparse Row format sparse matrix.
scipy.sparse.construct.bsr_matrix

# A sparse matrix in COOrdinate format.
scipy.sparse.construct.coo_matrix

# Compressed Sparse Column matrix.
scipy.sparse.construct.csc_matrix

# Compressed Sparse Row matrix.
scipy.sparse.construct.csr_matrix

# Sparse matrix with DIAgonal storage.
scipy.sparse.construct.dia_matrix

# Construct a sparse matrix from diagonals.
scipy.sparse.construct.diags

# Sparse matrix of chosen shape with ones on the kth diagonal and zeros elsewhere.
scipy.sparse.construct.eye

# Based on input (integer) arrays `a`, determine a suitable index data
scipy.sparse.construct.get_index_dtype

# Stack sparse matrices horizontally (column wise)
scipy.sparse.construct.hstack

# Identity matrix in sparse format
scipy.sparse.construct.identity

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.construct.issparse

# kronecker product of sparse matrices A and B
scipy.sparse.construct.kron

# kronecker sum of square sparse matrices A and B
scipy.sparse.construct.kronsum

# Generate a sparse matrix of the given shape and density with uniformly
scipy.sparse.construct.rand

# Generate a sparse matrix of the given shape and density with randomly
scipy.sparse.construct.random

# Return a sparse matrix from diagonals.
scipy.sparse.construct.spdiags

# Stack sparse arrays vertically (row wise)
scipy.sparse.construct.vstack

# The warning emitted when the operation is
scipy.sparse.coo.SparseEfficiencyWarning

# A sparse matrix in COOrdinate format.
scipy.sparse.coo.coo_matrix

# Is `x` of coo_matrix type?
scipy.sparse.coo.isspmatrix_coo

# This class provides a base class for all sparse matrix classes.
scipy.sparse.coo.spmatrix

# Compressed Sparse Column matrix.
scipy.sparse.csc.csc_matrix

# Is `x` of csc_matrix type?
scipy.sparse.csc.isspmatrix_csc

# This class provides a base class for all sparse matrix classes.
scipy.sparse.csc.spmatrix

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._flow.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._flow.ITYPE

# Represents the result of a maximum flow calculation.
scipy.sparse.csgraph._flow.MaximumFlowResult

# Convert a pydata/sparse array to scipy sparse matrix,
scipy.sparse.csgraph._flow.convert_pydata_sparse_to_scipy

# Compressed Sparse Row array.
scipy.sparse.csgraph._flow.csr_array

# Compressed Sparse Row matrix.
scipy.sparse.csgraph._flow.csr_matrix

# Check whether object is pydata/sparse matrix, avoiding importing the module.
scipy.sparse.csgraph._flow.is_pydata_spmatrix

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._flow.issparse

# maximum_flow(csgraph, source, sink)
scipy.sparse.csgraph._flow.maximum_flow

# NumPy
scipy.sparse.csgraph._flow.np

# Safely cast sparse array indices to `idx_dtype`.
scipy.sparse.csgraph._flow.safely_cast_index_arrays

# Common interface for performing matrix vector products
scipy.sparse.csgraph._laplacian.LinearOperator

# Convert a pydata/sparse array to scipy sparse matrix,
scipy.sparse.csgraph._laplacian.convert_pydata_sparse_to_scipy

# Check whether object is pydata/sparse matrix, avoiding importing the module.
scipy.sparse.csgraph._laplacian.is_pydata_spmatrix

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._laplacian.issparse

# Return the Laplacian of a directed graph.
scipy.sparse.csgraph._laplacian.laplacian

# NumPy
scipy.sparse.csgraph._laplacian.np

# Unsigned integer type, compatible with C ``unsigned char``.
scipy.sparse.csgraph._matching.BTYPE

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._matching.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._matching.ITYPE

# Convert a pydata/sparse array to scipy sparse matrix,
scipy.sparse.csgraph._matching.convert_pydata_sparse_to_scipy

# Compressed Sparse Row array.
scipy.sparse.csgraph._matching.csr_array

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._matching.issparse

# maximum_bipartite_matching(graph, perm_type='row')
scipy.sparse.csgraph._matching.maximum_bipartite_matching

# min_weight_full_bipartite_matching(biadjacency, maximize=False)
scipy.sparse.csgraph._matching.min_weight_full_bipartite_matching

# NumPy
scipy.sparse.csgraph._matching.np

# Safely cast sparse array indices to `idx_dtype`.
scipy.sparse.csgraph._matching.safely_cast_index_arrays

# Python part of the warnings subsystem.
scipy.sparse.csgraph._matching.warnings

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._min_spanning_tree.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._min_spanning_tree.ITYPE

# Compressed Sparse Row array.
scipy.sparse.csgraph._min_spanning_tree.csr_array

# Compressed Sparse Row matrix.
scipy.sparse.csgraph._min_spanning_tree.csr_matrix

# Check whether object is pydata/sparse matrix, avoiding importing the module.
scipy.sparse.csgraph._min_spanning_tree.is_pydata_spmatrix

# minimum_spanning_tree(csgraph, overwrite=False)
scipy.sparse.csgraph._min_spanning_tree.minimum_spanning_tree

# NumPy
scipy.sparse.csgraph._min_spanning_tree.np

# This class provides a base class for all sparse matrix classes.
scipy.sparse.csgraph._min_spanning_tree.spmatrix

# Routine for validation and conversion of csgraph inputs
scipy.sparse.csgraph._min_spanning_tree.validate_graph

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._reordering.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._reordering.ITYPE

# The warning emitted when the operation is
scipy.sparse.csgraph._reordering.SparseEfficiencyWarning

# Convert a pydata/sparse array to scipy sparse matrix,
scipy.sparse.csgraph._reordering.convert_pydata_sparse_to_scipy

# Compressed Sparse Row array.
scipy.sparse.csgraph._reordering.csr_array

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._reordering.issparse

# maximum_bipartite_matching(graph, perm_type='row')
scipy.sparse.csgraph._reordering.maximum_bipartite_matching

# NumPy
scipy.sparse.csgraph._reordering.np

# reverse_cuthill_mckee(graph, symmetric_mode=False)
scipy.sparse.csgraph._reordering.reverse_cuthill_mckee

# structural_rank(graph)
scipy.sparse.csgraph._reordering.structural_rank

# Issue a warning, or maybe ignore it or raise an exception.
scipy.sparse.csgraph._reordering.warn

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._shortest_path.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._shortest_path.ITYPE

scipy.sparse.csgraph._shortest_path.NegativeCycleError

# bellman_ford(csgraph, directed=True, indices=None, return_predecessors=False,
scipy.sparse.csgraph._shortest_path.bellman_ford

# Convert a pydata/sparse array to scipy sparse matrix,
scipy.sparse.csgraph._shortest_path.convert_pydata_sparse_to_scipy

# Compressed Sparse Row array.
scipy.sparse.csgraph._shortest_path.csr_array

# dijkstra(csgraph, directed=True, indices=None, return_predecessors=False,
scipy.sparse.csgraph._shortest_path.dijkstra

# floyd_warshall(csgraph, directed=True, return_predecessors=False,
scipy.sparse.csgraph._shortest_path.floyd_warshall

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._shortest_path.issparse

# johnson(csgraph, directed=True, indices=None, return_predecessors=False,
scipy.sparse.csgraph._shortest_path.johnson

# NumPy
scipy.sparse.csgraph._shortest_path.np

# Safely cast sparse array indices to `idx_dtype`.
scipy.sparse.csgraph._shortest_path.safely_cast_index_arrays

# shortest_path(csgraph, method='auto', directed=True, return_predecessors=False,
scipy.sparse.csgraph._shortest_path.shortest_path

# Routine for validation and conversion of csgraph inputs
scipy.sparse.csgraph._shortest_path.validate_graph

# Python part of the warnings subsystem.
scipy.sparse.csgraph._shortest_path.warnings

# yen(csgraph, source, sink, K, *, directed=True, return_predecessors=False,
scipy.sparse.csgraph._shortest_path.yen

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._tools.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._tools.ITYPE

# construct_dist_matrix(graph, predecessors, directed=True, null_value=np.inf)
scipy.sparse.csgraph._tools.construct_dist_matrix

# csgraph_from_dense(graph, null_value=0, nan_null=True, infinity_null=True)
scipy.sparse.csgraph._tools.csgraph_from_dense

# csgraph_from_masked(graph)
scipy.sparse.csgraph._tools.csgraph_from_masked

# csgraph_masked_from_dense(graph, null_value=0, nan_null=True,
scipy.sparse.csgraph._tools.csgraph_masked_from_dense

# csgraph_to_dense(csgraph, null_value=0)
scipy.sparse.csgraph._tools.csgraph_to_dense

# csgraph_to_masked(csgraph)
scipy.sparse.csgraph._tools.csgraph_to_masked

# Compressed Sparse Row array.
scipy.sparse.csgraph._tools.csr_array

# Compressed Sparse Row matrix.
scipy.sparse.csgraph._tools.csr_matrix

# Check whether object is pydata/sparse matrix, avoiding importing the module.
scipy.sparse.csgraph._tools.is_pydata_spmatrix

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._tools.issparse

# NumPy
scipy.sparse.csgraph._tools.np

# reconstruct_path(csgraph, predecessors, directed=True)
scipy.sparse.csgraph._tools.reconstruct_path

# This class provides a base class for all sparse matrix classes.
scipy.sparse.csgraph._tools.spmatrix

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._traversal.DTYPE

# Signed integer type, compatible with C ``int``.
scipy.sparse.csgraph._traversal.ITYPE

# breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True)
scipy.sparse.csgraph._traversal.breadth_first_order

# breadth_first_tree(csgraph, i_start, directed=True)
scipy.sparse.csgraph._traversal.breadth_first_tree

# connected_components(csgraph, directed=True, connection='weak',
scipy.sparse.csgraph._traversal.connected_components

# depth_first_order(csgraph, i_start, directed=True, return_predecessors=True)
scipy.sparse.csgraph._traversal.depth_first_order

# depth_first_tree(csgraph, i_start, directed=True)
scipy.sparse.csgraph._traversal.depth_first_tree

# NumPy
scipy.sparse.csgraph._traversal.np

# reconstruct_path(csgraph, predecessors, directed=True)
scipy.sparse.csgraph._traversal.reconstruct_path

# Routine for validation and conversion of csgraph inputs
scipy.sparse.csgraph._traversal.validate_graph

# Double-precision floating-point number type, compatible with Python
scipy.sparse.csgraph._validation.DTYPE

# Convert a pydata/sparse array to scipy sparse matrix,
scipy.sparse.csgraph._validation.convert_pydata_sparse_to_scipy

# csgraph_from_dense(graph, null_value=0, nan_null=True, infinity_null=True)
scipy.sparse.csgraph._validation.csgraph_from_dense

# csgraph_from_masked(graph)
scipy.sparse.csgraph._validation.csgraph_from_masked

# csgraph_masked_from_dense(graph, null_value=0, nan_null=True,
scipy.sparse.csgraph._validation.csgraph_masked_from_dense

# csgraph_to_dense(csgraph, null_value=0)
scipy.sparse.csgraph._validation.csgraph_to_dense

# Is `x` of a sparse array or sparse matrix type?
scipy.sparse.csgraph._validation.issparse

# NumPy
scipy.sparse.csgraph._validation.np

# Routine for validation and conversion of csgraph inputs
scipy.sparse.csgraph._validation.validate_graph

# Compressed Sparse Row matrix.
scipy.sparse.csr.csr_matrix

# Is `x` of csr_matrix type?
scipy.sparse.csr.isspmatrix_csr

# This class provides a base class for all sparse matrix classes.
scipy.sparse.csr.spmatrix

# Sparse matrix with DIAgonal storage.
scipy.sparse.dia.dia_matrix

# Is `x` of dia_matrix type?
scipy.sparse.dia.isspmatrix_dia

# This class provides a base class for all sparse matrix classes.
scipy.sparse.dia.spmatrix

# Dictionary Of Keys based sparse matrix.
scipy.sparse.dok.dok_matrix

# Is `x` of dok_array type?
scipy.sparse.dok.isspmatrix_dok

# This class provides a base class for all sparse matrix classes.
scipy.sparse.dok.spmatrix

# A sparse matrix in COOrdinate format.
scipy.sparse.extract.coo_matrix

# Return the indices and values of the nonzero elements of a matrix
scipy.sparse.extract.find

# Return the lower triangular portion of a sparse array or matrix
scipy.sparse.extract.tril

# Return the upper triangular portion of a sparse array or matrix
scipy.sparse.extract.triu

# Is `x` of lil_matrix type?
scipy.sparse.lil.isspmatrix_lil

# Row-based LIst of Lists sparse array.
scipy.sparse.lil.lil_array

# Row-based LIst of Lists sparse matrix.
scipy.sparse.lil.lil_matrix

# Add documentation to an existing object, typically one defined in C
scipy.sparse.linalg._dsolve._add_newdocs.add_newdoc

# LU factorization of a sparse matrix.
scipy.sparse.linalg._dsolve._superlu.SuperLU

# Direct inversion of sparse matrix.
scipy.sparse.linalg._dsolve._superlu.gssv

# gstrf(A, ...)
scipy.sparse.linalg._dsolve._superlu.gstrf

# gstrs(trans, L..., U..., b)
scipy.sparse.linalg._dsolve._superlu.gstrs

# Warning for exactly singular matrices.
scipy.sparse.linalg._dsolve.linsolve.MatrixRankWarning

# Return a function for solving a sparse linear system, with A pre-factorized.
scipy.sparse.linalg._dsolve.linsolve.factorized

# Returns 2-tuple indicating lower/upper triangular structure for sparse ``A``
scipy.sparse.linalg._dsolve.linsolve.is_sptriangular

# Return the lower and upper bandwidth of a 2D numeric array.
scipy.sparse.linalg._dsolve.linsolve.spbandwidth

# Compute an incomplete LU decomposition for a sparse, square matrix.
scipy.sparse.linalg._dsolve.linsolve.spilu

# Compute the LU decomposition of a sparse, square matrix.
scipy.sparse.linalg._dsolve.linsolve.splu

# Solve the sparse linear system Ax=b, where b may be a vector or a matrix.
scipy.sparse.linalg._dsolve.linsolve.spsolve

# Solve the equation ``A x = b`` for `x`, assuming A is a triangular matrix.
scipy.sparse.linalg._dsolve.linsolve.spsolve_triangular

# Select default sparse direct solver to be used.
scipy.sparse.linalg._dsolve.linsolve.use_solver

# Partial singular value decomposition of a sparse matrix.
scipy.sparse.linalg._eigen._svds.svds

# ido,tol,resid,v,iparam,ipntr,info = cnaupd(ido,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,rwork,info,[n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.cnaupd

# d,z,info = cneupd(rvec,howmny,select,sigma,workev,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,rwork,info,[ldz,n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.cneupd

# logfil : 'i'-scalar
scipy.sparse.linalg._eigen.arpack._arpack.debug

# ido,tol,resid,v,iparam,ipntr,info = dnaupd(ido,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.dnaupd

# dr,di,z,info = dneupd(rvec,howmny,select,sigmar,sigmai,workev,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[ldz,n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.dneupd

# ido,tol,resid,v,iparam,ipntr,info = dsaupd(ido,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.dsaupd

# d,z,info = dseupd(rvec,howmny,select,sigma,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[ldz,n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.dseupd

# ido,tol,resid,v,iparam,ipntr,info = snaupd(ido,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.snaupd

# dr,di,z,info = sneupd(rvec,howmny,select,sigmar,sigmai,workev,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[ldz,n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.sneupd

# ido,tol,resid,v,iparam,ipntr,info = ssaupd(ido,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.ssaupd

# d,z,info = sseupd(rvec,howmny,select,sigma,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,info,[ldz,n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.sseupd

# nopx : 'i'-scalar
scipy.sparse.linalg._eigen.arpack._arpack.timing

# ido,tol,resid,v,iparam,ipntr,info = znaupd(ido,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,rwork,info,[n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.znaupd

# d,z,info = zneupd(rvec,howmny,select,sigma,workev,bmat,which,nev,tol,resid,v,iparam,ipntr,workd,workl,rwork,info,[ldz,n,ncv,ldv,lworkl])
scipy.sparse.linalg._eigen.arpack._arpack.zneupd

# ARPACK error
scipy.sparse.linalg._eigen.arpack.arpack.ArpackError

# ARPACK iteration did not converge
scipy.sparse.linalg._eigen.arpack.arpack.ArpackNoConvergence

# Find k eigenvalues and eigenvectors of the square matrix A.
scipy.sparse.linalg._eigen.arpack.arpack.eigs

# Find k eigenvalues and eigenvectors of the real symmetric square matrix
scipy.sparse.linalg._eigen.arpack.arpack.eigsh

# Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).
scipy.sparse.linalg._eigen.lobpcg.lobpcg.lobpcg

# Compute the action of the matrix exponential of A on B.
scipy.sparse.linalg._expm_multiply.expm_multiply

# Common interface for performing matrix vector products
scipy.sparse.linalg._interface.LinearOperator

# Return A as a LinearOperator.
scipy.sparse.linalg._interface.aslinearoperator

# Solve ``Ax = b`` with the flexible GCROT(m,k) algorithm.
scipy.sparse.linalg._isolve._gcrotmk.gcrotmk

# Solve ``Ax = b`` with the BIConjugate Gradient method.
scipy.sparse.linalg._isolve.iterative.bicg

# Solve ``Ax = b`` with the BIConjugate Gradient STABilized method.
scipy.sparse.linalg._isolve.iterative.bicgstab

# Solve ``Ax = b`` with the Conjugate Gradient method, for a symmetric,
scipy.sparse.linalg._isolve.iterative.cg

# Solve ``Ax = b`` with the Conjugate Gradient Squared method.
scipy.sparse.linalg._isolve.iterative.cgs

# Solve ``Ax = b`` with the Generalized Minimal RESidual method.
scipy.sparse.linalg._isolve.iterative.gmres

# Solve ``Ax = b`` with the Quasi-Minimal Residual method.
scipy.sparse.linalg._isolve.iterative.qmr

# Solve ``Ax = b`` with the LGMRES algorithm.
scipy.sparse.linalg._isolve.lgmres.lgmres

# Iterative solver for least-squares problems.
scipy.sparse.linalg._isolve.lsmr.lsmr

# Find the least-squares solution to a large, sparse, linear system
scipy.sparse.linalg._isolve.lsqr.lsqr

# Solve ``Ax = b`` with the MINimum RESidual method, for a symmetric `A`.
scipy.sparse.linalg._isolve.minres.minres

# Solve ``Ax = b`` with the Transpose-Free Quasi-Minimal Residual method.
scipy.sparse.linalg._isolve.tfqmr.tfqmr

# Compute the matrix exponential using Pade approximation.
scipy.sparse.linalg._matfuncs.expm

# Compute the inverse of a sparse arrays
scipy.sparse.linalg._matfuncs.inv

# Raise a square matrix to the integer power, `power`.
scipy.sparse.linalg._matfuncs.matrix_power

# Norm of a sparse matrix
scipy.sparse.linalg._norm.norm

# Compute a lower bound of the 1-norm of a sparse array.
scipy.sparse.linalg._onenormest.onenormest

# The grid Laplacian in ``N`` dimensions and its eigenvalues/eigenvectors.
scipy.sparse.linalg._special_sparse_arrays.LaplacianNd

# Compute the singular value decomposition of a linear operator using PROPACK
scipy.sparse.linalg._svdp._svdp

# Warning for exactly singular matrices.
scipy.sparse.linalg.dsolve.MatrixRankWarning

# LU factorization of a sparse matrix.
scipy.sparse.linalg.dsolve.SuperLU

# Return a function for solving a sparse linear system, with A pre-factorized.
scipy.sparse.linalg.dsolve.factorized

# Compute an incomplete LU decomposition for a sparse, square matrix.
scipy.sparse.linalg.dsolve.spilu

# Compute the LU decomposition of a sparse, square matrix.
scipy.sparse.linalg.dsolve.splu

# Solve the sparse linear system Ax=b, where b may be a vector or a matrix.
scipy.sparse.linalg.dsolve.spsolve

# Solve the equation ``A x = b`` for `x`, assuming A is a triangular matrix.
scipy.sparse.linalg.dsolve.spsolve_triangular

# Run tests for this namespace
scipy.sparse.linalg.dsolve.test

# Select default sparse direct solver to be used.
scipy.sparse.linalg.dsolve.use_solver

# ARPACK error
scipy.sparse.linalg.eigen.ArpackError

# ARPACK error
scipy.sparse.linalg.eigen.ArpackError

# ARPACK iteration did not converge
scipy.sparse.linalg.eigen.ArpackNoConvergence

# Find k eigenvalues and eigenvectors of the square matrix A.
scipy.sparse.linalg.eigen.eigs

# Find k eigenvalues and eigenvectors of the real symmetric square matrix
scipy.sparse.linalg.eigen.eigsh

# Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG).
scipy.sparse.linalg.eigen.lobpcg

# Partial singular value decomposition of a sparse matrix.
scipy.sparse.linalg.eigen.svds

# Run tests for this namespace
scipy.sparse.linalg.eigen.test

# Common interface for performing matrix vector products
scipy.sparse.linalg.interface.LinearOperator

# Return A as a LinearOperator.
scipy.sparse.linalg.interface.aslinearoperator

# Solve ``Ax = b`` with the BIConjugate Gradient method.
scipy.sparse.linalg.isolve.bicg

# Solve ``Ax = b`` with the BIConjugate Gradient STABilized method.
scipy.sparse.linalg.isolve.bicgstab

# Solve ``Ax = b`` with the Conjugate Gradient method, for a symmetric,
scipy.sparse.linalg.isolve.cg

# Solve ``Ax = b`` with the Conjugate Gradient Squared method.
scipy.sparse.linalg.isolve.cgs

# Solve ``Ax = b`` with the flexible GCROT(m,k) algorithm.
scipy.sparse.linalg.isolve.gcrotmk

# Solve ``Ax = b`` with the Generalized Minimal RESidual method.
scipy.sparse.linalg.isolve.gmres

# Solve ``Ax = b`` with the LGMRES algorithm.
scipy.sparse.linalg.isolve.lgmres

# Iterative solver for least-squares problems.
scipy.sparse.linalg.isolve.lsmr

# Find the least-squares solution to a large, sparse, linear system
scipy.sparse.linalg.isolve.lsqr

# Solve ``Ax = b`` with the MINimum RESidual method, for a symmetric `A`.
scipy.sparse.linalg.isolve.minres

# Solve ``Ax = b`` with the Quasi-Minimal Residual method.
scipy.sparse.linalg.isolve.qmr

# Run tests for this namespace
scipy.sparse.linalg.isolve.test

# Solve ``Ax = b`` with the Transpose-Free Quasi-Minimal Residual method.
scipy.sparse.linalg.isolve.tfqmr

# Common interface for performing matrix vector products
scipy.sparse.linalg.matfuncs.LinearOperator

# Compute the matrix exponential using Pade approximation.
scipy.sparse.linalg.matfuncs.expm

# Compute the inverse of a sparse arrays
scipy.sparse.linalg.matfuncs.inv

# Solve the sparse linear system Ax=b, where b may be a vector or a matrix.
scipy.sparse.linalg.matfuncs.spsolve

# cKDTree(data, leafsize=16, compact_nodes=True, copy_data=False,
scipy.spatial._ckdtree.cKDTree

# cdist_braycurtis(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_braycurtis

# cdist_canberra(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_canberra

# cdist_chebyshev(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_chebyshev

# cdist_cityblock(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_cityblock

# cdist_dice(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_dice

# cdist_euclidean(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_euclidean

# cdist_hamming(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_hamming

# cdist_jaccard(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_jaccard

# cdist_kulczynski1(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_kulczynski1

# cdist_minkowski(x: object, y: object, w: object = None, out: object = None, p: float = 2.0) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_minkowski

# cdist_rogerstanimoto(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_rogerstanimoto

# cdist_russellrao(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_russellrao

# cdist_sokalmichener(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_sokalmichener

# cdist_sokalsneath(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_sokalsneath

# cdist_sqeuclidean(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_sqeuclidean

# cdist_yule(x: object, y: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.cdist_yule

# pdist_braycurtis(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_braycurtis

# pdist_canberra(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_canberra

# pdist_chebyshev(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_chebyshev

# pdist_cityblock(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_cityblock

# pdist_dice(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_dice

# pdist_euclidean(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_euclidean

# pdist_hamming(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_hamming

# pdist_jaccard(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_jaccard

# pdist_kulczynski1(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_kulczynski1

# pdist_minkowski(x: object, w: object = None, out: object = None, p: float = 2.0) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_minkowski

# pdist_rogerstanimoto(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_rogerstanimoto

# pdist_russellrao(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_russellrao

# pdist_sokalmichener(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_sokalmichener

# pdist_sokalsneath(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_sokalsneath

# pdist_sqeuclidean(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_sqeuclidean

# pdist_yule(x: object, w: object = None, out: object = None) -> numpy.ndarray
scipy.spatial._distance_pybind.pdist_yule

scipy.spatial._distance_wrap.cdist_braycurtis_double_wrap

scipy.spatial._distance_wrap.cdist_canberra_double_wrap

scipy.spatial._distance_wrap.cdist_chebyshev_double_wrap

scipy.spatial._distance_wrap.cdist_cityblock_double_wrap

scipy.spatial._distance_wrap.cdist_correlation_double_wrap

scipy.spatial._distance_wrap.cdist_cosine_double_wrap

scipy.spatial._distance_wrap.cdist_dice_bool_wrap

scipy.spatial._distance_wrap.cdist_euclidean_double_wrap

scipy.spatial._distance_wrap.cdist_hamming_bool_wrap

scipy.spatial._distance_wrap.cdist_hamming_double_wrap

scipy.spatial._distance_wrap.cdist_jaccard_bool_wrap

scipy.spatial._distance_wrap.cdist_jaccard_double_wrap

scipy.spatial._distance_wrap.cdist_jensenshannon_double_wrap

scipy.spatial._distance_wrap.cdist_kulczynski1_bool_wrap

scipy.spatial._distance_wrap.cdist_mahalanobis_double_wrap

scipy.spatial._distance_wrap.cdist_minkowski_double_wrap

scipy.spatial._distance_wrap.cdist_rogerstanimoto_bool_wrap

scipy.spatial._distance_wrap.cdist_russellrao_bool_wrap

scipy.spatial._distance_wrap.cdist_seuclidean_double_wrap

scipy.spatial._distance_wrap.cdist_sokalmichener_bool_wrap

scipy.spatial._distance_wrap.cdist_sokalsneath_bool_wrap

scipy.spatial._distance_wrap.cdist_sqeuclidean_double_wrap

scipy.spatial._distance_wrap.cdist_weighted_chebyshev_double_wrap

scipy.spatial._distance_wrap.cdist_weighted_minkowski_double_wrap

scipy.spatial._distance_wrap.cdist_yule_bool_wrap

scipy.spatial._distance_wrap.pdist_braycurtis_double_wrap

scipy.spatial._distance_wrap.pdist_canberra_double_wrap

scipy.spatial._distance_wrap.pdist_chebyshev_double_wrap

scipy.spatial._distance_wrap.pdist_cityblock_double_wrap

scipy.spatial._distance_wrap.pdist_correlation_double_wrap

scipy.spatial._distance_wrap.pdist_cosine_double_wrap

scipy.spatial._distance_wrap.pdist_dice_bool_wrap

scipy.spatial._distance_wrap.pdist_euclidean_double_wrap

scipy.spatial._distance_wrap.pdist_hamming_bool_wrap

scipy.spatial._distance_wrap.pdist_hamming_double_wrap

scipy.spatial._distance_wrap.pdist_jaccard_bool_wrap

scipy.spatial._distance_wrap.pdist_jaccard_double_wrap

scipy.spatial._distance_wrap.pdist_jensenshannon_double_wrap

scipy.spatial._distance_wrap.pdist_kulczynski1_bool_wrap

scipy.spatial._distance_wrap.pdist_mahalanobis_double_wrap

scipy.spatial._distance_wrap.pdist_minkowski_double_wrap

scipy.spatial._distance_wrap.pdist_rogerstanimoto_bool_wrap

scipy.spatial._distance_wrap.pdist_russellrao_bool_wrap

scipy.spatial._distance_wrap.pdist_seuclidean_double_wrap

scipy.spatial._distance_wrap.pdist_sokalmichener_bool_wrap

scipy.spatial._distance_wrap.pdist_sokalsneath_bool_wrap

scipy.spatial._distance_wrap.pdist_sqeuclidean_double_wrap

scipy.spatial._distance_wrap.pdist_weighted_chebyshev_double_wrap

scipy.spatial._distance_wrap.pdist_weighted_minkowski_double_wrap

scipy.spatial._distance_wrap.pdist_yule_bool_wrap

scipy.spatial._distance_wrap.to_squareform_from_vector_wrap

scipy.spatial._distance_wrap.to_vector_from_squareform_wrap

# Geometric spherical linear interpolation.
scipy.spatial._geometric_slerp.geometric_slerp

scipy.spatial._hausdorff.directed_hausdorff

# kd-tree for quick nearest-neighbor lookup.
scipy.spatial._kdtree.KDTree

# Hyperrectangle class.
scipy.spatial._kdtree.Rectangle

# Compute the distance matrix.
scipy.spatial._kdtree.distance_matrix

# Compute the L**p distance between two arrays.
scipy.spatial._kdtree.minkowski_distance

# Compute the pth power of the L**p distance between two arrays.
scipy.spatial._kdtree.minkowski_distance_p

# Plot the given convex hull diagram in 2-D
scipy.spatial._plotutils.convex_hull_plot_2d

# Plot the given Delaunay triangulation in 2-D
scipy.spatial._plotutils.delaunay_plot_2d

# Plot the given Voronoi diagram in 2-D
scipy.spatial._plotutils.voronoi_plot_2d

# Procrustes analysis, a similarity test for two data sets.
scipy.spatial._procrustes.procrustes

# ConvexHull(points, incremental=False, qhull_options=None)
scipy.spatial._qhull.ConvexHull

# Delaunay(points, furthest_site=False, incremental=False, qhull_options=None)
scipy.spatial._qhull.Delaunay

# HalfspaceIntersection(halfspaces, interior_point, incremental=False, qhull_options=None)
scipy.spatial._qhull.HalfspaceIntersection

# Raised when Qhull encounters an error condition, such as 
scipy.spatial._qhull.QhullError

# Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)
scipy.spatial._qhull.Voronoi

# tsearch(tri, xi)
scipy.spatial._qhull.tsearch

# Voronoi diagrams on the surface of a sphere.
scipy.spatial._spherical_voronoi.SphericalVoronoi

scipy.spatial._voronoi.sort_vertices_of_regions

# cKDTree(data, leafsize=16, compact_nodes=True, copy_data=False,
scipy.spatial.ckdtree.cKDTree

# Compute the Bray-Curtis distance between two 1-D arrays.
scipy.spatial.distance.braycurtis

# Compute the Canberra distance between two 1-D arrays.
scipy.spatial.distance.canberra

# Compute distance between each pair of the two collections of inputs.
scipy.spatial.distance.cdist

# Compute the Chebyshev distance.
scipy.spatial.distance.chebyshev

# Compute the City Block (Manhattan) distance.
scipy.spatial.distance.cityblock

# Compute the correlation distance between two 1-D arrays.
scipy.spatial.distance.correlation

# Compute the Cosine distance between 1-D arrays.
scipy.spatial.distance.cosine

# Compute the Dice dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.dice

# Compute the directed Hausdorff distance between two 2-D arrays.
scipy.spatial.distance.directed_hausdorff

# Computes the Euclidean distance between two 1-D arrays.
scipy.spatial.distance.euclidean

# Compute the Hamming distance between two 1-D arrays.
scipy.spatial.distance.hamming

# Return True if input array is a valid distance matrix.
scipy.spatial.distance.is_valid_dm

# Return True if the input array is a valid condensed distance matrix.
scipy.spatial.distance.is_valid_y

# Compute the Jaccard dissimilarity between two boolean vectors.
scipy.spatial.distance.jaccard

# Compute the Jensen-Shannon distance (metric) between
scipy.spatial.distance.jensenshannon

# Compute the Kulczynski 1 dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.kulczynski1

# Compute the Mahalanobis distance between two 1-D arrays.
scipy.spatial.distance.mahalanobis

# Compute the Minkowski distance between two 1-D arrays.
scipy.spatial.distance.minkowski

# Return the number of original observations that correspond to a
scipy.spatial.distance.num_obs_dm

# Return the number of original observations that correspond to a
scipy.spatial.distance.num_obs_y

# Pairwise distances between observations in n-dimensional space.
scipy.spatial.distance.pdist

# Compute the Rogers-Tanimoto dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.rogerstanimoto

# Compute the Russell-Rao dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.russellrao

# Return the standardized Euclidean distance between two 1-D arrays.
scipy.spatial.distance.seuclidean

# Compute the Sokal-Michener dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.sokalmichener

# Compute the Sokal-Sneath dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.sokalsneath

# Compute the squared Euclidean distance between two 1-D arrays.
scipy.spatial.distance.sqeuclidean

# Convert a vector-form distance vector to a square-form distance
scipy.spatial.distance.squareform

# Compute the Yule dissimilarity between two boolean 1-D arrays.
scipy.spatial.distance.yule

# kd-tree for quick nearest-neighbor lookup.
scipy.spatial.kdtree.KDTree

# Hyperrectangle class.
scipy.spatial.kdtree.Rectangle

# cKDTree(data, leafsize=16, compact_nodes=True, copy_data=False,
scipy.spatial.kdtree.cKDTree

# Compute the distance matrix.
scipy.spatial.kdtree.distance_matrix

# Compute the L**p distance between two arrays.
scipy.spatial.kdtree.minkowski_distance

# Compute the pth power of the L**p distance between two arrays.
scipy.spatial.kdtree.minkowski_distance_p

# ConvexHull(points, incremental=False, qhull_options=None)
scipy.spatial.qhull.ConvexHull

# Delaunay(points, furthest_site=False, incremental=False, qhull_options=None)
scipy.spatial.qhull.Delaunay

# HalfspaceIntersection(halfspaces, interior_point, incremental=False, qhull_options=None)
scipy.spatial.qhull.HalfspaceIntersection

# Raised when Qhull encounters an error condition, such as 
scipy.spatial.qhull.QhullError

# Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)
scipy.spatial.qhull.Voronoi

# tsearch(tri, xi)
scipy.spatial.qhull.tsearch

# Rigid transform in 3 dimensions.
scipy.spatial.transform._rigid_transform.RigidTransform

# Rotation in 3 dimensions.
scipy.spatial.transform._rigid_transform.Rotation

# Composition of quaternions.
scipy.spatial.transform._rigid_transform.compose_quat

# Normalize dual quaternion.
scipy.spatial.transform._rigid_transform.normalize_dual_quaternion

# NumPy
scipy.spatial.transform._rigid_transform.np

# Rotation in 3 dimensions.
scipy.spatial.transform._rotation.Rotation

# Spherical Linear Interpolation of Rotations.
scipy.spatial.transform._rotation.Slerp

# Turn `seed` into a `np.random.RandomState` instance.
scipy.spatial.transform._rotation.check_random_state

# Composition of quaternions.
scipy.spatial.transform._rotation.compose_quat

scipy.spatial.transform._rotation.create_group

# NumPy
scipy.spatial.transform._rotation.np

# Support for regular expressions (RE).
scipy.spatial.transform._rotation.re

# Python part of the warnings subsystem.
scipy.spatial.transform._rotation.warnings

scipy.spatial.transform._rotation_groups.create_group

scipy.spatial.transform._rotation_groups.cyclic

scipy.spatial.transform._rotation_groups.dicyclic

scipy.spatial.transform._rotation_groups.icosahedral

# NumPy
scipy.spatial.transform._rotation_groups.np

scipy.spatial.transform._rotation_groups.octahedral

# Convert a string or number to a floating-point number, if possible.
scipy.spatial.transform._rotation_groups.phi

scipy.spatial.transform._rotation_groups.tetrahedral

# Rotation in 3 dimensions.
scipy.spatial.transform._rotation_spline.Rotation

# Interpolate rotations with continuous angular rate and acceleration.
scipy.spatial.transform._rotation_spline.RotationSpline

# NumPy
scipy.spatial.transform._rotation_spline.np

# Solve the equation ``a @ x = b`` for ``x``, where ``a`` is the banded matrix
scipy.spatial.transform._rotation_spline.solve_banded

# Rotation in 3 dimensions.
scipy.spatial.transform.rotation.Rotation

# Spherical Linear Interpolation of Rotations.
scipy.spatial.transform.rotation.Slerp

scipy.special._add_newdocs.add_newdoc

# dict() -> new empty dictionary
scipy.special._add_newdocs.docdict

scipy.special._add_newdocs.get

# Compute `nt` zeros and values of the Airy function Ai and its derivative.
scipy.special._basic.ai_zeros

# Compute the generalized (associated) Laguerre polynomial of degree n and order k.
scipy.special._basic.assoc_laguerre

# Compute nt zeros of the Kelvin function bei.
scipy.special._basic.bei_zeros

# Compute nt zeros of the derivative of the Kelvin function bei.
scipy.special._basic.beip_zeros

# Compute nt zeros of the Kelvin function ber.
scipy.special._basic.ber_zeros

# Bernoulli numbers B0..Bn (inclusive).
scipy.special._basic.bernoulli

# Compute nt zeros of the derivative of the Kelvin function ber.
scipy.special._basic.berp_zeros

# Compute `nt` zeros and values of the Airy function Bi and its derivative.
scipy.special._basic.bi_zeros

# Associated Legendre function of the first kind for complex arguments.
scipy.special._basic.clpmn

# The number of combinations of N things taken k at a time.
scipy.special._basic.comb

# psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._basic.digamma

# Periodic sinc function, also called the Dirichlet function.
scipy.special._basic.diric

# Compute the first nt zero in the first quadrant, ordered by absolute value.
scipy.special._basic.erf_zeros

# Euler numbers E(0), E(1), ..., E(n).
scipy.special._basic.euler

# The factorial of a number or array of numbers.
scipy.special._basic.factorial

# Double factorial.
scipy.special._basic.factorial2

# Multifactorial of n of order k, n(!!...!).
scipy.special._basic.factorialk

# Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).
scipy.special._basic.fresnel_zeros

# Compute nt complex zeros of cosine Fresnel integral C(z).
scipy.special._basic.fresnelc_zeros

# Compute nt complex zeros of sine Fresnel integral S(z).
scipy.special._basic.fresnels_zeros

# Compute derivatives of Hankel function H1v(z) with respect to `z`.
scipy.special._basic.h1vp

# Compute derivatives of Hankel function H2v(z) with respect to `z`.
scipy.special._basic.h2vp

# Compute derivatives of modified Bessel functions of the first kind.
scipy.special._basic.ivp

# Compute zeros of integer-order Bessel functions Jn.
scipy.special._basic.jn_zeros

# Compute zeros of integer-order Bessel functions Jn and Jn'.
scipy.special._basic.jnjnp_zeros

# Compute zeros of integer-order Bessel function derivatives Jn'.
scipy.special._basic.jnp_zeros

# Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x).
scipy.special._basic.jnyn_zeros

# Compute derivatives of Bessel functions of the first kind.
scipy.special._basic.jvp

# Compute nt zeros of the Kelvin function kei.
scipy.special._basic.kei_zeros

# Compute nt zeros of the derivative of the Kelvin function kei.
scipy.special._basic.keip_zeros

# Compute nt zeros of all Kelvin functions.
scipy.special._basic.kelvin_zeros

# Compute nt zeros of the Kelvin function ker.
scipy.special._basic.ker_zeros

# Compute nt zeros of the derivative of the Kelvin function ker.
scipy.special._basic.kerp_zeros

# Compute derivatives of real-order modified Bessel function Kv(z)
scipy.special._basic.kvp

# Jahnke-Emden Lambda function, Lambdav(x).
scipy.special._basic.lmbda

# Sequence of associated Legendre functions of the first kind.
scipy.special._basic.lpmn

# Legendre function of the first kind.
scipy.special._basic.lpn

# Sequence of associated Legendre functions of the second kind.
scipy.special._basic.lqmn

# Legendre function of the second kind.
scipy.special._basic.lqn

# Fourier coefficients for even Mathieu and modified Mathieu functions.
scipy.special._basic.mathieu_even_coef

# Fourier coefficients for even Mathieu and modified Mathieu functions.
scipy.special._basic.mathieu_odd_coef

# Characteristic values for oblate spheroidal wave functions.
scipy.special._basic.obl_cv_seq

# Parabolic cylinder functions Dn(z) and derivatives.
scipy.special._basic.pbdn_seq

# Parabolic cylinder functions Dv(x) and derivatives.
scipy.special._basic.pbdv_seq

# Parabolic cylinder functions Vv(x) and derivatives.
scipy.special._basic.pbvv_seq

# Permutations of N things taken k at a time, i.e., k-permutations of N.
scipy.special._basic.perm

# Polygamma functions.
scipy.special._basic.polygamma

# Characteristic values for prolate spheroidal wave functions.
scipy.special._basic.pro_cv_seq

# Compute Ricatti-Bessel function of the first kind and its derivative.
scipy.special._basic.riccati_jn

# Compute Ricatti-Bessel function of the second kind and its derivative.
scipy.special._basic.riccati_yn

# Return the normalized sinc function.
scipy.special._basic.sinc

# Compute the softplus function element-wise.
scipy.special._basic.softplus

# Generate Stirling number(s) of the second kind.
scipy.special._basic.stirling2

# Compute nt zeros of Bessel function Y0(z), and derivative at each zero.
scipy.special._basic.y0_zeros

# Compute nt zeros of Bessel function Y1(z), and derivative at each zero.
scipy.special._basic.y1_zeros

# Compute nt zeros of Bessel derivative Y1'(z), and value at each zero.
scipy.special._basic.y1p_zeros

# Compute zeros of integer-order Bessel function Yn(x).
scipy.special._basic.yn_zeros

# Compute zeros of integer-order Bessel function derivatives Yn'(x).
scipy.special._basic.ynp_zeros

# Compute derivatives of Bessel functions of the second kind.
scipy.special._basic.yvp

# Riemann or Hurwitz zeta function.
scipy.special._basic.zeta

# Ellipsoidal harmonic functions E^p_n(l)
scipy.special._ellip_harm.ellip_harm

# Ellipsoidal harmonic functions F^p_n(l)
scipy.special._ellip_harm.ellip_harm_2

# Ellipsoidal harmonic normalization constants gamma^p_n
scipy.special._ellip_harm.ellip_normal

# NumPy
scipy.special._ellip_harm.np

# Low-level callback function.
scipy.special._ellip_harm_2.LowLevelCallable

# Convert a string or number to a floating-point number, if possible.
scipy.special._ellip_harm_2.nan

# dict() -> new empty dictionary
scipy.special._gufuncs.assoc_legendre_p_all

# Built-in immutable sequence.
scipy.special._gufuncs.legendre_p_all

# Built-in immutable sequence.
scipy.special._gufuncs.sph_harm_y_all

# Built-in immutable sequence.
scipy.special._gufuncs.sph_legendre_p_all

# This module provides access to the mathematical functions
scipy.special._input_validation.math

# Operator interface.
scipy.special._input_validation.operator

# lambertw(z, k=0, tol=1e-8)
scipy.special._lambertw.lambertw

# NumPy
scipy.special._lambertw.np

# Compute the logarithm of the softmax function.
scipy.special._logsumexp.log_softmax

# Compute the log of the sum of exponentials of input elements.
scipy.special._logsumexp.logsumexp

# Compute the softmax function.
scipy.special._logsumexp.softmax

# Generate a set of numbers on the real axis, concentrating on
scipy.special._mptestutils.Arg

scipy.special._mptestutils.ComplexArg

scipy.special._mptestutils.FixedArg

scipy.special._mptestutils.IntArg

scipy.special._mptestutils.MpmathData

# Returns True when the argument is true, False otherwise.
scipy.special._mptestutils.POSIX

scipy.special._mptestutils.TimeoutError

# Assert that works in release mode.
scipy.special._mptestutils.assert_

scipy.special._mptestutils.assert_func_equal

scipy.special._mptestutils.assert_mpmath_equal

# Decorate function to return nan if it raises an exception
scipy.special._mptestutils.exception_to_nan

scipy.special._mptestutils.get_args

# Decorate function to return nan if it returns inf
scipy.special._mptestutils.inf_to_nan

# Compare lists of mpmath.mpf's or mpmath.mpc's directly so that it
scipy.special._mptestutils.mp_assert_allclose

scipy.special._mptestutils.mpc2complex

# Convert an mpf to the nearest floating point number. Just using
scipy.special._mptestutils.mpf2float

scipy.special._mptestutils.nonfunctional_tooslow

# NumPy
scipy.special._mptestutils.np

# OS routines for NT or Posix depending on what system we're on.
scipy.special._mptestutils.os

# pytest: unit and functional testing with Python.
scipy.special._mptestutils.pytest

scipy.special._mptestutils.signal

# This module provides access to some objects used or maintained by the
scipy.special._mptestutils.sys

# This module provides various functions to manipulate time values.
scipy.special._mptestutils.time

# Decorator for setting a timeout for pure-Python functions.
scipy.special._mptestutils.time_limited

scipy.special._mptestutils.trace_args

# Return a zip_longest object whose .__next__() method returns a tuple where
scipy.special._mptestutils.zip_longest

# assoc_legendre_p(n, m, z, *, branch_cut=2, norm=False, diff_n=0)
scipy.special._multiufuncs.assoc_legendre_p

# assoc_legendre_p_all(n, m, z, *, branch_cut=2, norm=False, diff_n=0)
scipy.special._multiufuncs.assoc_legendre_p_all

# legendre_p(n, z, *, diff_n=0)
scipy.special._multiufuncs.legendre_p

# legendre_p_all(n, z, *, diff_n=0)
scipy.special._multiufuncs.legendre_p_all

# sph_harm_y(n, m, theta, phi, *, diff_n=0)
scipy.special._multiufuncs.sph_harm_y

# sph_harm_y_all(n, m, theta, phi, *, diff_n=0)
scipy.special._multiufuncs.sph_harm_y_all

# sph_legendre_p(n, m, theta, *, diff_n=0)
scipy.special._multiufuncs.sph_legendre_p

# sph_legendre_p_all(n, m, theta, *, diff_n=0)
scipy.special._multiufuncs.sph_legendre_p_all

# Gauss-Chebyshev (first kind) quadrature.
scipy.special._orthogonal.c_roots

# Gauss-Gegenbauer quadrature.
scipy.special._orthogonal.cg_roots

# Chebyshev polynomial of the first kind on :math:`[-2, 2]`.
scipy.special._orthogonal.chebyc

# Chebyshev polynomial of the second kind on :math:`[-2, 2]`.
scipy.special._orthogonal.chebys

# Chebyshev polynomial of the first kind.
scipy.special._orthogonal.chebyt

# Chebyshev polynomial of the second kind.
scipy.special._orthogonal.chebyu

# Gegenbauer (ultraspherical) polynomial.
scipy.special._orthogonal.gegenbauer

# Generalized (associated) Laguerre polynomial.
scipy.special._orthogonal.genlaguerre

# Gauss-Hermite (physicist's) quadrature.
scipy.special._orthogonal.h_roots

# Gauss-Hermite (statistician's) quadrature.
scipy.special._orthogonal.he_roots

# Physicist's Hermite polynomial.
scipy.special._orthogonal.hermite

# Normalized (probabilist's) Hermite polynomial.
scipy.special._orthogonal.hermitenorm

# Gauss-Jacobi quadrature.
scipy.special._orthogonal.j_roots

# Jacobi polynomial.
scipy.special._orthogonal.jacobi

# Gauss-Jacobi (shifted) quadrature.
scipy.special._orthogonal.js_roots

# Gauss-Laguerre quadrature.
scipy.special._orthogonal.l_roots

# Gauss-generalized Laguerre quadrature.
scipy.special._orthogonal.la_roots

# Laguerre polynomial.
scipy.special._orthogonal.laguerre

# Legendre polynomial.
scipy.special._orthogonal.legendre

# Gauss-Legendre quadrature.
scipy.special._orthogonal.p_roots

# Gauss-Legendre (shifted) quadrature.
scipy.special._orthogonal.ps_roots

# Gauss-Chebyshev (first kind) quadrature.
scipy.special._orthogonal.roots_chebyc

# Gauss-Chebyshev (second kind) quadrature.
scipy.special._orthogonal.roots_chebys

# Gauss-Chebyshev (first kind) quadrature.
scipy.special._orthogonal.roots_chebyt

# Gauss-Chebyshev (second kind) quadrature.
scipy.special._orthogonal.roots_chebyu

# Gauss-Gegenbauer quadrature.
scipy.special._orthogonal.roots_gegenbauer

# Gauss-generalized Laguerre quadrature.
scipy.special._orthogonal.roots_genlaguerre

# Gauss-Hermite (physicist's) quadrature.
scipy.special._orthogonal.roots_hermite

# Gauss-Hermite (statistician's) quadrature.
scipy.special._orthogonal.roots_hermitenorm

# Gauss-Jacobi quadrature.
scipy.special._orthogonal.roots_jacobi

# Gauss-Laguerre quadrature.
scipy.special._orthogonal.roots_laguerre

# Gauss-Legendre quadrature.
scipy.special._orthogonal.roots_legendre

# Gauss-Chebyshev (first kind, shifted) quadrature.
scipy.special._orthogonal.roots_sh_chebyt

# Gauss-Chebyshev (second kind, shifted) quadrature.
scipy.special._orthogonal.roots_sh_chebyu

# Gauss-Jacobi (shifted) quadrature.
scipy.special._orthogonal.roots_sh_jacobi

# Gauss-Legendre (shifted) quadrature.
scipy.special._orthogonal.roots_sh_legendre

# Gauss-Chebyshev (second kind) quadrature.
scipy.special._orthogonal.s_roots

# Shifted Chebyshev polynomial of the first kind.
scipy.special._orthogonal.sh_chebyt

# Shifted Chebyshev polynomial of the second kind.
scipy.special._orthogonal.sh_chebyu

# Shifted Jacobi polynomial.
scipy.special._orthogonal.sh_jacobi

# Shifted Legendre polynomial.
scipy.special._orthogonal.sh_legendre

# Gauss-Chebyshev (first kind) quadrature.
scipy.special._orthogonal.t_roots

# Gauss-Chebyshev (first kind, shifted) quadrature.
scipy.special._orthogonal.ts_roots

# Gauss-Chebyshev (second kind) quadrature.
scipy.special._orthogonal.u_roots

# Gauss-Chebyshev (second kind, shifted) quadrature.
scipy.special._orthogonal.us_roots

# str(object='') -> str
scipy.special._precompute.expn_asy.WARNING

scipy.special._precompute.expn_asy.generate_A

scipy.special._precompute.expn_asy.main

# OS routines for NT or Posix depending on what system we're on.
scipy.special._precompute.expn_asy.os

# a_k from DLMF 5.11.6
scipy.special._precompute.gammainc_asy.compute_a

# alpha_n from DLMF 8.12.13
scipy.special._precompute.gammainc_asy.compute_alpha

# d_{k, n} from DLMF 8.12.12
scipy.special._precompute.gammainc_asy.compute_d

# g_k from DLMF 5.11.3/5.11.5
scipy.special._precompute.gammainc_asy.compute_g

# Function from DLMF 8.12.1 shifted to be centered at 0.
scipy.special._precompute.gammainc_asy.eta

# str(object='') -> str
scipy.special._precompute.gammainc_asy.footer

# str(object='') -> str
scipy.special._precompute.gammainc_asy.header

# Given a series
scipy.special._precompute.gammainc_asy.lagrange_inversion

scipy.special._precompute.gammainc_asy.main

# OS routines for NT or Posix depending on what system we're on.
scipy.special._precompute.gammainc_asy.os

# Compute gammainc exactly like mpmath does but allow for more
scipy.special._precompute.gammainc_data.gammainc

# Compute gammaincc exactly like mpmath does but allow for more
scipy.special._precompute.gammainc_data.gammaincc

scipy.special._precompute.gammainc_data.main

# Convert an mpf to the nearest floating point number. Just using
scipy.special._precompute.gammainc_data.mpf2float

# NumPy
scipy.special._precompute.gammainc_data.np

# OS routines for NT or Posix depending on what system we're on.
scipy.special._precompute.gammainc_data.os

# Convert a string or number to a floating-point number, if possible.
scipy.special._precompute.gammainc_data.pi

# time() -> floating-point number
scipy.special._precompute.gammainc_data.time

# Returns a process pool object
scipy.special._precompute.hyp2f1_data.Pool

# Command-line parsing library
scipy.special._precompute.hyp2f1_data.argparse

# CSV parsing and writing.
scipy.special._precompute.hyp2f1_data.csv

# Assign numbers for regions where hyp2f1 must be handled differently.
scipy.special._precompute.hyp2f1_data.get_region

# Get results for given parameter and value combination.
scipy.special._precompute.hyp2f1_data.get_result

# Get results for given parameter and value combination.
scipy.special._precompute.hyp2f1_data.get_result_no_mp

# Batch compute results for multiple parameter and argument values.
scipy.special._precompute.hyp2f1_data.get_results

# hyp2f1(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._precompute.hyp2f1_data.hyp2f1

scipy.special._precompute.hyp2f1_data.main

# Generate string for a list of test cases for test_hyp2f1.py.
scipy.special._precompute.hyp2f1_data.make_hyp2f1_test_cases

# Return mpmath hyp2f1 calculated on same branch as scipy hyp2f1.
scipy.special._precompute.hyp2f1_data.mp_hyp2f1

# NumPy
scipy.special._precompute.hyp2f1_data.np

# OS routines for NT or Posix depending on what system we're on.
scipy.special._precompute.hyp2f1_data.os

# Cartesian product of input iterables.  Equivalent to nested for-loops.
scipy.special._precompute.hyp2f1_data.product

scipy.special._precompute.lambertw.lambertw_pade

scipy.special._precompute.lambertw.main

# NumPy
scipy.special._precompute.lambertw.np

scipy.special._precompute.loggamma.main

scipy.special._precompute.loggamma.stirling_series

scipy.special._precompute.loggamma.taylor_series_at_1

# Given a series
scipy.special._precompute.utils.lagrange_inversion

# Object for parsing command line strings into Python objects.
scipy.special._precompute.wright_bessel.ArgumentParser

# Help message formatter which retains formatting of all help text.
scipy.special._precompute.wright_bessel.RawTextHelpFormatter

# Asymptotic expansion for large x.
scipy.special._precompute.wright_bessel.asymptotic_series

# Use non-linear least squares to fit a function, f, to data.
scipy.special._precompute.wright_bessel.curve_fit

# Symbolic expansion of digamma(z) in z=0 to order n.
scipy.special._precompute.wright_bessel.dg_series

scipy.special._precompute.wright_bessel.main

# Local minimization of scalar function of one variable.
scipy.special._precompute.wright_bessel.minimize_scalar

# NumPy
scipy.special._precompute.wright_bessel.np

# Fit optimal choice of epsilon for integral representation.
scipy.special._precompute.wright_bessel.optimal_epsilon_integral

# Symbolic expansion of polygamma(k, z) in z=0 to order n.
scipy.special._precompute.wright_bessel.pg_series

# Compute a definite integral.
scipy.special._precompute.wright_bessel.quad

# Tylor series expansion of Phi(a, b, x) in a=0 up to order 5.
scipy.special._precompute.wright_bessel.series_small_a

# Tylor series expansion of Phi(a, b, x) in a=0 and b=0 up to order 5.
scipy.special._precompute.wright_bessel.series_small_a_small_b

# time() -> floating-point number
scipy.special._precompute.wright_bessel.time

# Convert a string or number to a floating-point number, if possible.
scipy.special._precompute.wright_bessel_data.exp_inf

# Least-recently-used cache decorator.
scipy.special._precompute.wright_bessel_data.lru_cache

scipy.special._precompute.wright_bessel_data.main

# Compute Wright's generalized Bessel function as Series with mpmath.
scipy.special._precompute.wright_bessel_data.mp_wright_bessel

# Convert an mpf to the nearest floating point number. Just using
scipy.special._precompute.wright_bessel_data.mpf2float

# NumPy
scipy.special._precompute.wright_bessel_data.np

# OS routines for NT or Posix depending on what system we're on.
scipy.special._precompute.wright_bessel_data.os

scipy.special._precompute.wright_bessel_data.rgamma_cached

# time() -> floating-point number
scipy.special._precompute.wright_bessel_data.time

scipy.special._precompute.wrightomega.main

scipy.special._precompute.wrightomega.mpmath_wrightomega

# NumPy
scipy.special._precompute.wrightomega.np

scipy.special._precompute.wrightomega.wrightomega_exp_error

scipy.special._precompute.wrightomega.wrightomega_series_error

scipy.special._precompute.zetac.main

scipy.special._precompute.zetac.zetac_series

# Exception that can be raised by special functions.
scipy.special._sf_error.SpecialFunctionError

# Warning that can be emitted by special functions.
scipy.special._sf_error.SpecialFunctionWarning

# Python part of the warnings subsystem.
scipy.special._sf_error.warnings

scipy.special._specfun.Status

# Compute the first NT zeros of Airy functions
scipy.special._specfun.airyzo

# Compute Bernoulli number Bn for n >= 2. This is a wrapper for the
scipy.special._specfun.bernob

# Evaluate the complex zeros of error function erf(z) using
scipy.special._specfun.cerzo

# Compute the parabolic cylinder functions Dn(z) and Dn'(z)
scipy.special._specfun.cpbdn

# Compute the complex zeros of Y0(z), Y1(z) and Y1'(z), and their
scipy.special._specfun.cyzo

# Compute Bernoulli number Bn for n >= 2. This is a wrapper for the
scipy.special._specfun.eulerb

# Compute expansion coefficients for Mathieu functions and modified
scipy.special._specfun.fcoef

# Compute the complex zeros of Fresnel integral C(z) or S(z) using
scipy.special._specfun.fcszo

# Compute the zeros of Bessel functions Jn(x) and Jn'(x), and
scipy.special._specfun.jdzo

# Compute the zeros of Bessel functions Jn(x), Yn(x), and their
scipy.special._specfun.jyzo

# Compute the zeros of Kelvin functions. This is a wrapper for
scipy.special._specfun.klvnzo

# Compute lambda functions and their derivatives. This is a wrapper
scipy.special._specfun.lamn

# Compute lambda function with arbitrary order v, and their derivative.
scipy.special._specfun.lamv

scipy.special._specfun.pbdv

scipy.special._specfun.pbvv

# Compute the expansion coefficients of the prolate and oblate
scipy.special._specfun.sdmn

# Compute the characteristic values of spheroidal wave functions.
scipy.special._specfun.segv

# airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.airy

# airye(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.airye

# dict() -> new empty dictionary
scipy.special._special_ufuncs.assoc_legendre_p

# bei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.bei

# beip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.beip

# ber(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ber

# berp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.berp

# besselpoly(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.besselpoly

# beta(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.beta

# betaln(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.betaln

# binom(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.binom

# cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.cbrt

# cosdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.cosdg

# cosm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.cosm1

# cotdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.cotdg

# dawsn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.dawsn

# ellipe(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ellipe

# ellipeinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ellipeinc

# ellipj(x1, x2[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ellipj

# ellipk(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ellipk

# ellipkinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ellipkinc

# ellipkm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ellipkm1

# erf(z, out=None)
scipy.special._special_ufuncs.erf

# erfc(x, out=None)
scipy.special._special_ufuncs.erfc

# erfcx(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.erfcx

# erfi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.erfi

# exp1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.exp1

# exp10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.exp10

# exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.exp2

# expi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.expi

# expit(x, out=None)
scipy.special._special_ufuncs.expit

# expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.expm1

# exprel(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.exprel

# fresnel(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.fresnel

# gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.gamma

# gammainc(a, x, out=None)
scipy.special._special_ufuncs.gammainc

# gammaincc(a, x, out=None)
scipy.special._special_ufuncs.gammaincc

# gammainccinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.gammainccinv

# gammaincinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.gammaincinv

# gammaln(x, out=None)
scipy.special._special_ufuncs.gammaln

# gammasgn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.gammasgn

# hankel1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.hankel1

# hankel1e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.hankel1e

# hankel2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.hankel2

# hankel2e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.hankel2e

# hyp2f1(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.hyp2f1

# i0(x, out=None)
scipy.special._special_ufuncs.i0

# i0e(x, out=None)
scipy.special._special_ufuncs.i0e

# i1(x, out=None)
scipy.special._special_ufuncs.i1

# i1e(x, out=None)
scipy.special._special_ufuncs.i1e

# it2i0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.it2i0k0

# it2j0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.it2j0y0

# it2struve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.it2struve0

# itairy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.itairy

# iti0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.iti0k0

# itj0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.itj0y0

# itmodstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.itmodstruve0

# itstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.itstruve0

# iv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.iv

# ive(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ive

# j0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.j0

# j1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.j1

# jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.jv

# jve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.jve

# k0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.k0

# k0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.k0e

# k1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.k1

# k1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.k1e

# kei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.kei

# keip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.keip

# kelvin(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.kelvin

# ker(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.ker

# kerp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.kerp

# kv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.kv

# kve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.kve

# Built-in immutable sequence.
scipy.special._special_ufuncs.legendre_p

# log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.log1p

# log_expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.log_expit

# log_ndtr(x, out=None)
scipy.special._special_ufuncs.log_ndtr

# log_wright_bessel(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.log_wright_bessel

# loggamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.loggamma

# logit(x, out=None)
scipy.special._special_ufuncs.logit

# mathieu_a(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_a

# mathieu_b(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_b

# mathieu_cem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_cem

# mathieu_modcem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_modcem1

# mathieu_modcem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_modcem2

# mathieu_modsem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_modsem1

# mathieu_modsem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_modsem2

# mathieu_sem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.mathieu_sem

# modfresnelm(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.modfresnelm

# modfresnelp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.modfresnelp

# modstruve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.modstruve

# ndtr(x, out=None)
scipy.special._special_ufuncs.ndtr

# obl_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_ang1

# obl_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_ang1_cv

# obl_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_cv

# obl_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_rad1

# obl_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_rad1_cv

# obl_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_rad2

# obl_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.obl_rad2_cv

# pbdv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pbdv

# pbvv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pbvv

# pbwa(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pbwa

# pro_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_ang1

# pro_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_ang1_cv

# pro_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_cv

# pro_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_rad1

# pro_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_rad1_cv

# pro_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_rad2

# pro_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.pro_rad2_cv

# psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.psi

# radian(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.radian

# rgamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.rgamma

# sindg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.sindg

# sph_harm(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.sph_harm

# Built-in immutable sequence.
scipy.special._special_ufuncs.sph_harm_y

# Built-in immutable sequence.
scipy.special._special_ufuncs.sph_legendre_p

# struve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.struve

# tandg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.tandg

# voigt_profile(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.voigt_profile

# wofz(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.wofz

# wright_bessel(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.wright_bessel

# xlog1py(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.xlog1py

# xlogy(x, y, out=None)
scipy.special._special_ufuncs.xlogy

# y0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.y0

# y1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.y1

# yv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.yv

# yve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.yve

# zetac(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._special_ufuncs.zetac

# Returns the log of multivariate gamma, also sometimes called the
scipy.special._spfun_stats.multigammaln

# NumPy
scipy.special._spherical_bessel.np

# Modified spherical Bessel function of the first kind or its derivative.
scipy.special._spherical_bessel.spherical_in

# Spherical Bessel function of the first kind or its derivative.
scipy.special._spherical_bessel.spherical_jn

# Modified spherical Bessel function of the second kind or its derivative.
scipy.special._spherical_bessel.spherical_kn

scipy.special._spherical_bessel.spherical_kn_reflection

# Spherical Bessel function of the second kind or its derivative.
scipy.special._spherical_bessel.spherical_yn

scipy.special._spherical_bessel.use_reflection

# Decorator factory to apply update_wrapper() to a wrapper function
scipy.special._spherical_bessel.wraps

# Extra array functions built on top of the array API standard.
scipy.special._spherical_bessel.xpx

# betainc(a, b, x, out=None)
scipy.special._support_alternative_backends.betainc

# betaincc(a, b, x, out=None)
scipy.special._support_alternative_backends.betaincc

# chdtr(v, x, out=None)
scipy.special._support_alternative_backends.chdtr

# chdtrc(v, x, out=None)
scipy.special._support_alternative_backends.chdtrc

# entr(x, out=None)
scipy.special._support_alternative_backends.entr

# erf(z, out=None)
scipy.special._support_alternative_backends.erf

# erfc(x, out=None)
scipy.special._support_alternative_backends.erfc

# expit(x, out=None)
scipy.special._support_alternative_backends.expit

# gammainc(a, x, out=None)
scipy.special._support_alternative_backends.gammainc

# gammaincc(a, x, out=None)
scipy.special._support_alternative_backends.gammaincc

# gammaln(x, out=None)
scipy.special._support_alternative_backends.gammaln

# i0(x, out=None)
scipy.special._support_alternative_backends.i0

# i0e(x, out=None)
scipy.special._support_alternative_backends.i0e

# i1(x, out=None)
scipy.special._support_alternative_backends.i1

# i1e(x, out=None)
scipy.special._support_alternative_backends.i1e

# log_ndtr(x, out=None)
scipy.special._support_alternative_backends.log_ndtr

# logit(x, out=None)
scipy.special._support_alternative_backends.logit

# ndtr(x, out=None)
scipy.special._support_alternative_backends.ndtr

# ndtri(y, out=None)
scipy.special._support_alternative_backends.ndtri

# rel_entr(x, y, out=None)
scipy.special._support_alternative_backends.rel_entr

# stdtr(df, t, out=None)
scipy.special._support_alternative_backends.stdtr

# stdtrit(df, p, out=None)
scipy.special._support_alternative_backends.stdtrit

# xlogy(x, y, out=None)
scipy.special._support_alternative_backends.xlogy

# Assert that works in release mode.
scipy.special._test_internal.assert_

scipy.special._test_internal.have_fenv

# NumPy
scipy.special._test_internal.np

scipy.special._test_internal.random_double

scipy.special._test_internal.test_add_round

# Data set for checking a special function.
scipy.special._testutils.FuncData

scipy.special._testutils.assert_func_equal

# Enable special function errors (such as underflow, overflow,
scipy.special._testutils.with_special_errors

# agm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.agm

# airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.airy

# airye(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.airye

# bdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.bdtr

# bdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.bdtrc

# bdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.bdtri

# bdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.bdtrik

# bdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.bdtrin

# bei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.bei

# beip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.beip

# ber(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ber

# berp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.berp

# besselpoly(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.besselpoly

# beta(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.beta

# betainc(a, b, x, out=None)
scipy.special._ufuncs.betainc

# betaincc(a, b, x, out=None)
scipy.special._ufuncs.betaincc

# betainccinv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.betainccinv

# betaincinv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.betaincinv

# betaln(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.betaln

# binom(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.binom

# boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.boxcox

# boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.boxcox1p

# btdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.btdtria

# btdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.btdtrib

# cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.cbrt

# chdtr(v, x, out=None)
scipy.special._ufuncs.chdtr

# chdtrc(v, x, out=None)
scipy.special._ufuncs.chdtrc

# chdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.chdtri

# chdtriv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.chdtriv

# chndtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.chndtr

# chndtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.chndtridf

# chndtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.chndtrinc

# chndtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.chndtrix

# cosdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.cosdg

# cosm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.cosm1

# cotdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.cotdg

# dawsn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.dawsn

# ellipe(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ellipe

# ellipeinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ellipeinc

# ellipj(x1, x2[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ellipj

# ellipk(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ellipk

# ellipkinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ellipkinc

# ellipkm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ellipkm1

# elliprc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.elliprc

# elliprd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.elliprd

# elliprf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.elliprf

# elliprg(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.elliprg

# elliprj(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.elliprj

# entr(x, out=None)
scipy.special._ufuncs.entr

# erf(z, out=None)
scipy.special._ufuncs.erf

# erfc(x, out=None)
scipy.special._ufuncs.erfc

# erfcinv(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.erfcinv

# erfcx(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.erfcx

# erfi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.erfi

# erfinv(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.erfinv

# Context manager for special-function error handling.
scipy.special._ufuncs.errstate

# eval_chebyc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_chebyc

# eval_chebys(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_chebys

# eval_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_chebyt

# eval_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_chebyu

# eval_gegenbauer(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_gegenbauer

# eval_genlaguerre(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_genlaguerre

# eval_hermite(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_hermite

# eval_hermitenorm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_hermitenorm

# eval_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_jacobi

# eval_laguerre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_laguerre

# eval_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_legendre

# eval_sh_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_sh_chebyt

# eval_sh_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_sh_chebyu

# eval_sh_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_sh_jacobi

# eval_sh_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.eval_sh_legendre

# exp1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.exp1

# exp10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.exp10

# exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.exp2

# expi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.expi

# expit(x, out=None)
scipy.special._ufuncs.expit

# expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.expm1

# expn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.expn

# exprel(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.exprel

# fdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.fdtr

# fdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.fdtrc

# fdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.fdtri

# fdtridfd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.fdtridfd

# fresnel(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.fresnel

# gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gamma

# gammainc(a, x, out=None)
scipy.special._ufuncs.gammainc

# gammaincc(a, x, out=None)
scipy.special._ufuncs.gammaincc

# gammainccinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gammainccinv

# gammaincinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gammaincinv

# gammaln(x, out=None)
scipy.special._ufuncs.gammaln

# gammaln(x, out=None)
scipy.special._ufuncs.gammaln

# gammasgn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gammasgn

# gdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gdtr

# gdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gdtrc

# gdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gdtria

# gdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gdtrib

# gdtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.gdtrix

# Get the current way of handling special-function errors.
scipy.special._ufuncs.geterr

# hankel1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hankel1

# hankel1e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hankel1e

# hankel2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hankel2

# hankel2e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hankel2e

# huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.huber

# hyp0f1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hyp0f1

# hyp1f1(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hyp1f1

# hyp2f1(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hyp2f1

# hyperu(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.hyperu

# i0(x, out=None)
scipy.special._ufuncs.i0

# i0e(x, out=None)
scipy.special._ufuncs.i0e

# i1(x, out=None)
scipy.special._ufuncs.i1

# i1e(x, out=None)
scipy.special._ufuncs.i1e

# inv_boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.inv_boxcox

# inv_boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.inv_boxcox1p

# it2i0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.it2i0k0

# it2j0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.it2j0y0

# it2struve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.it2struve0

# itairy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.itairy

# iti0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.iti0k0

# itj0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.itj0y0

# itmodstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.itmodstruve0

# itstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.itstruve0

# iv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.iv

# ive(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ive

# j0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.j0

# j1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.j1

# jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.jn

# jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.jv

# jve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.jve

# k0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.k0

# k0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.k0e

# k1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.k1

# k1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.k1e

# kei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kei

# keip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.keip

# kelvin(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kelvin

# ker(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ker

# kerp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kerp

# kl_div(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kl_div

# kn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kn

# kolmogi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kolmogi

# kolmogorov(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kolmogorov

# kv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kv

# kve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.kve

# log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.log1p

# log_expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.log_expit

# log_ndtr(x, out=None)
scipy.special._ufuncs.log_ndtr

# log_wright_bessel(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.log_wright_bessel

# loggamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.loggamma

# logit(x, out=None)
scipy.special._ufuncs.logit

# lpmv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.lpmv

# mathieu_a(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_a

# mathieu_b(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_b

# mathieu_cem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_cem

# mathieu_modcem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_modcem1

# mathieu_modcem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_modcem2

# mathieu_modsem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_modsem1

# mathieu_modsem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_modsem2

# mathieu_sem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.mathieu_sem

# modfresnelm(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.modfresnelm

# modfresnelp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.modfresnelp

# modstruve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.modstruve

# nbdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nbdtr

# nbdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nbdtrc

# nbdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nbdtri

# nbdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nbdtrik

# nbdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nbdtrin

# ncfdtr(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ncfdtr

# ncfdtri(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ncfdtri

# ncfdtridfd(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ncfdtridfd

# ncfdtridfn(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ncfdtridfn

# ncfdtrinc(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ncfdtrinc

# nctdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nctdtr

# nctdtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nctdtridf

# nctdtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nctdtrinc

# nctdtrit(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nctdtrit

# ndtr(x, out=None)
scipy.special._ufuncs.ndtr

# ndtri(y, out=None)
scipy.special._ufuncs.ndtri

# ndtri_exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.ndtri_exp

# nrdtrimn(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nrdtrimn

# nrdtrisd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.nrdtrisd

# obl_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_ang1

# obl_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_ang1_cv

# obl_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_cv

# obl_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_rad1

# obl_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_rad1_cv

# obl_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_rad2

# obl_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.obl_rad2_cv

# owens_t(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.owens_t

# pbdv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pbdv

# pbvv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pbvv

# pbwa(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pbwa

# pdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pdtr

# pdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pdtrc

# pdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pdtri

# pdtrik(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pdtrik

# poch(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.poch

# powm1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.powm1

# pro_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_ang1

# pro_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_ang1_cv

# pro_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_cv

# pro_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_rad1

# pro_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_rad1_cv

# pro_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_rad2

# pro_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pro_rad2_cv

# pseudo_huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.pseudo_huber

# psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.psi

# radian(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.radian

# rel_entr(x, y, out=None)
scipy.special._ufuncs.rel_entr

# rgamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.rgamma

# round(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.round

# Set how special-function errors are handled.
scipy.special._ufuncs.seterr

# shichi(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.shichi

# sici(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.sici

# sindg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.sindg

# smirnov(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.smirnov

# smirnovi(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.smirnovi

# spence(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.spence

# sph_harm(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.sph_harm

# stdtr(df, t, out=None)
scipy.special._ufuncs.stdtr

# stdtridf(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.stdtridf

# stdtrit(df, p, out=None)
scipy.special._ufuncs.stdtrit

# struve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.struve

# tandg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.tandg

# tklmbda(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.tklmbda

# voigt_profile(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.voigt_profile

# wofz(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.wofz

# wright_bessel(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.wright_bessel

# wrightomega(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.wrightomega

# xlog1py(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.xlog1py

# xlogy(x, y, out=None)
scipy.special._ufuncs.xlogy

# y0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.y0

# y1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.y1

# yn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.yn

# yv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.yv

# yve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.yve

# zetac(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special._ufuncs.zetac

# Compute `nt` zeros and values of the Airy function Ai and its derivative.
scipy.special.basic.ai_zeros

# Compute the generalized (associated) Laguerre polynomial of degree n and order k.
scipy.special.basic.assoc_laguerre

# Compute nt zeros of the Kelvin function bei.
scipy.special.basic.bei_zeros

# Compute nt zeros of the derivative of the Kelvin function bei.
scipy.special.basic.beip_zeros

# Compute nt zeros of the Kelvin function ber.
scipy.special.basic.ber_zeros

# Bernoulli numbers B0..Bn (inclusive).
scipy.special.basic.bernoulli

# Compute nt zeros of the derivative of the Kelvin function ber.
scipy.special.basic.berp_zeros

# Compute `nt` zeros and values of the Airy function Bi and its derivative.
scipy.special.basic.bi_zeros

# Associated Legendre function of the first kind for complex arguments.
scipy.special.basic.clpmn

# The number of combinations of N things taken k at a time.
scipy.special.basic.comb

# psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.digamma

# Periodic sinc function, also called the Dirichlet function.
scipy.special.basic.diric

# Compute the first nt zero in the first quadrant, ordered by absolute value.
scipy.special.basic.erf_zeros

# Euler numbers E(0), E(1), ..., E(n).
scipy.special.basic.euler

# The factorial of a number or array of numbers.
scipy.special.basic.factorial

# Double factorial.
scipy.special.basic.factorial2

# Multifactorial of n of order k, n(!!...!).
scipy.special.basic.factorialk

# Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).
scipy.special.basic.fresnel_zeros

# Compute nt complex zeros of cosine Fresnel integral C(z).
scipy.special.basic.fresnelc_zeros

# Compute nt complex zeros of sine Fresnel integral S(z).
scipy.special.basic.fresnels_zeros

# gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.gamma

# Compute derivatives of Hankel function H1v(z) with respect to `z`.
scipy.special.basic.h1vp

# Compute derivatives of Hankel function H2v(z) with respect to `z`.
scipy.special.basic.h2vp

# hankel1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.hankel1

# hankel2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.hankel2

# iv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.iv

# Compute derivatives of modified Bessel functions of the first kind.
scipy.special.basic.ivp

# Compute zeros of integer-order Bessel functions Jn.
scipy.special.basic.jn_zeros

# Compute zeros of integer-order Bessel functions Jn and Jn'.
scipy.special.basic.jnjnp_zeros

# Compute zeros of integer-order Bessel function derivatives Jn'.
scipy.special.basic.jnp_zeros

# Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x).
scipy.special.basic.jnyn_zeros

# jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.jv

# Compute derivatives of Bessel functions of the first kind.
scipy.special.basic.jvp

# Compute nt zeros of the Kelvin function kei.
scipy.special.basic.kei_zeros

# Compute nt zeros of the derivative of the Kelvin function kei.
scipy.special.basic.keip_zeros

# Compute nt zeros of all Kelvin functions.
scipy.special.basic.kelvin_zeros

# Compute nt zeros of the Kelvin function ker.
scipy.special.basic.ker_zeros

# Compute nt zeros of the derivative of the Kelvin function ker.
scipy.special.basic.kerp_zeros

# kv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.kv

# Compute derivatives of real-order modified Bessel function Kv(z)
scipy.special.basic.kvp

# Jahnke-Emden Lambda function, Lambdav(x).
scipy.special.basic.lmbda

# Sequence of associated Legendre functions of the first kind.
scipy.special.basic.lpmn

# Legendre function of the first kind.
scipy.special.basic.lpn

# Sequence of associated Legendre functions of the second kind.
scipy.special.basic.lqmn

# Legendre function of the second kind.
scipy.special.basic.lqn

# mathieu_a(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.mathieu_a

# mathieu_b(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.mathieu_b

# Fourier coefficients for even Mathieu and modified Mathieu functions.
scipy.special.basic.mathieu_even_coef

# Fourier coefficients for even Mathieu and modified Mathieu functions.
scipy.special.basic.mathieu_odd_coef

# Characteristic values for oblate spheroidal wave functions.
scipy.special.basic.obl_cv_seq

# Parabolic cylinder functions Dn(z) and derivatives.
scipy.special.basic.pbdn_seq

# Parabolic cylinder functions Dv(x) and derivatives.
scipy.special.basic.pbdv_seq

# Parabolic cylinder functions Vv(x) and derivatives.
scipy.special.basic.pbvv_seq

# Permutations of N things taken k at a time, i.e., k-permutations of N.
scipy.special.basic.perm

# Polygamma functions.
scipy.special.basic.polygamma

# Characteristic values for prolate spheroidal wave functions.
scipy.special.basic.pro_cv_seq

# psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.psi

# Compute Ricatti-Bessel function of the first kind and its derivative.
scipy.special.basic.riccati_jn

# Compute Ricatti-Bessel function of the second kind and its derivative.
scipy.special.basic.riccati_yn

# Return the normalized sinc function.
scipy.special.basic.sinc

# Compute nt zeros of Bessel function Y0(z), and derivative at each zero.
scipy.special.basic.y0_zeros

# Compute nt zeros of Bessel function Y1(z), and derivative at each zero.
scipy.special.basic.y1_zeros

# Compute nt zeros of Bessel derivative Y1'(z), and value at each zero.
scipy.special.basic.y1p_zeros

# Compute zeros of integer-order Bessel function Yn(x).
scipy.special.basic.yn_zeros

# Compute zeros of integer-order Bessel function derivatives Yn'(x).
scipy.special.basic.ynp_zeros

# yv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.basic.yv

# Compute derivatives of Bessel functions of the second kind.
scipy.special.basic.yvp

# Riemann or Hurwitz zeta function.
scipy.special.basic.zeta

# See the documentation for scipy.special.agm
scipy.special.cython_special.agm

# See the documentation for scipy.special.bdtr
scipy.special.cython_special.bdtr

# See the documentation for scipy.special.bdtrc
scipy.special.cython_special.bdtrc

# See the documentation for scipy.special.bdtri
scipy.special.cython_special.bdtri

# See the documentation for scipy.special.bdtrik
scipy.special.cython_special.bdtrik

# See the documentation for scipy.special.bdtrin
scipy.special.cython_special.bdtrin

# See the documentation for scipy.special.bei
scipy.special.cython_special.bei

# See the documentation for scipy.special.beip
scipy.special.cython_special.beip

# See the documentation for scipy.special.ber
scipy.special.cython_special.ber

# See the documentation for scipy.special.berp
scipy.special.cython_special.berp

# See the documentation for scipy.special.besselpoly
scipy.special.cython_special.besselpoly

scipy.special.cython_special.beta

# See the documentation for scipy.special.betainc
scipy.special.cython_special.betainc

# See the documentation for scipy.special.betaincc
scipy.special.cython_special.betaincc

# See the documentation for scipy.special.betainccinv
scipy.special.cython_special.betainccinv

# See the documentation for scipy.special.betaincinv
scipy.special.cython_special.betaincinv

# See the documentation for scipy.special.betaln
scipy.special.cython_special.betaln

# See the documentation for scipy.special.binom
scipy.special.cython_special.binom

# See the documentation for scipy.special.boxcox
scipy.special.cython_special.boxcox

# See the documentation for scipy.special.boxcox1p
scipy.special.cython_special.boxcox1p

# See the documentation for scipy.special.btdtria
scipy.special.cython_special.btdtria

# See the documentation for scipy.special.btdtrib
scipy.special.cython_special.btdtrib

# See the documentation for scipy.special.cbrt
scipy.special.cython_special.cbrt

# See the documentation for scipy.special.chdtr
scipy.special.cython_special.chdtr

# See the documentation for scipy.special.chdtrc
scipy.special.cython_special.chdtrc

# See the documentation for scipy.special.chdtri
scipy.special.cython_special.chdtri

# See the documentation for scipy.special.chdtriv
scipy.special.cython_special.chdtriv

# See the documentation for scipy.special.chndtr
scipy.special.cython_special.chndtr

# See the documentation for scipy.special.chndtridf
scipy.special.cython_special.chndtridf

# See the documentation for scipy.special.chndtrinc
scipy.special.cython_special.chndtrinc

# See the documentation for scipy.special.chndtrix
scipy.special.cython_special.chndtrix

# See the documentation for scipy.special.cosdg
scipy.special.cython_special.cosdg

# See the documentation for scipy.special.cosm1
scipy.special.cython_special.cosm1

# See the documentation for scipy.special.cotdg
scipy.special.cython_special.cotdg

# See the documentation for scipy.special.dawsn
scipy.special.cython_special.dawsn

# See the documentation for scipy.special.ellipe
scipy.special.cython_special.ellipe

# See the documentation for scipy.special.ellipeinc
scipy.special.cython_special.ellipeinc

# See the documentation for scipy.special.ellipk
scipy.special.cython_special.ellipk

# See the documentation for scipy.special.ellipkinc
scipy.special.cython_special.ellipkinc

# See the documentation for scipy.special.ellipkm1
scipy.special.cython_special.ellipkm1

# See the documentation for scipy.special.elliprc
scipy.special.cython_special.elliprc

# See the documentation for scipy.special.elliprd
scipy.special.cython_special.elliprd

# See the documentation for scipy.special.elliprf
scipy.special.cython_special.elliprf

# See the documentation for scipy.special.elliprg
scipy.special.cython_special.elliprg

# See the documentation for scipy.special.elliprj
scipy.special.cython_special.elliprj

# See the documentation for scipy.special.entr
scipy.special.cython_special.entr

# See the documentation for scipy.special.erf
scipy.special.cython_special.erf

# See the documentation for scipy.special.erfc
scipy.special.cython_special.erfc

# See the documentation for scipy.special.erfcinv
scipy.special.cython_special.erfcinv

# See the documentation for scipy.special.erfcx
scipy.special.cython_special.erfcx

# See the documentation for scipy.special.erfi
scipy.special.cython_special.erfi

# See the documentation for scipy.special.erfinv
scipy.special.cython_special.erfinv

# See the documentation for scipy.special.eval_chebyc
scipy.special.cython_special.eval_chebyc

# See the documentation for scipy.special.eval_chebys
scipy.special.cython_special.eval_chebys

# See the documentation for scipy.special.eval_chebyt
scipy.special.cython_special.eval_chebyt

# See the documentation for scipy.special.eval_chebyu
scipy.special.cython_special.eval_chebyu

# See the documentation for scipy.special.eval_gegenbauer
scipy.special.cython_special.eval_gegenbauer

# See the documentation for scipy.special.eval_genlaguerre
scipy.special.cython_special.eval_genlaguerre

# See the documentation for scipy.special.eval_hermite
scipy.special.cython_special.eval_hermite

# See the documentation for scipy.special.eval_hermitenorm
scipy.special.cython_special.eval_hermitenorm

# See the documentation for scipy.special.eval_jacobi
scipy.special.cython_special.eval_jacobi

# See the documentation for scipy.special.eval_laguerre
scipy.special.cython_special.eval_laguerre

# See the documentation for scipy.special.eval_legendre
scipy.special.cython_special.eval_legendre

# See the documentation for scipy.special.eval_sh_chebyt
scipy.special.cython_special.eval_sh_chebyt

# See the documentation for scipy.special.eval_sh_chebyu
scipy.special.cython_special.eval_sh_chebyu

# See the documentation for scipy.special.eval_sh_jacobi
scipy.special.cython_special.eval_sh_jacobi

# See the documentation for scipy.special.eval_sh_legendre
scipy.special.cython_special.eval_sh_legendre

# See the documentation for scipy.special.exp1
scipy.special.cython_special.exp1

# See the documentation for scipy.special.exp10
scipy.special.cython_special.exp10

# See the documentation for scipy.special.exp2
scipy.special.cython_special.exp2

# See the documentation for scipy.special.expi
scipy.special.cython_special.expi

# See the documentation for scipy.special.expit
scipy.special.cython_special.expit

# See the documentation for scipy.special.expm1
scipy.special.cython_special.expm1

# See the documentation for scipy.special.expn
scipy.special.cython_special.expn

# See the documentation for scipy.special.exprel
scipy.special.cython_special.exprel

# See the documentation for scipy.special.fdtr
scipy.special.cython_special.fdtr

# See the documentation for scipy.special.fdtrc
scipy.special.cython_special.fdtrc

# See the documentation for scipy.special.fdtri
scipy.special.cython_special.fdtri

# See the documentation for scipy.special.fdtridfd
scipy.special.cython_special.fdtridfd

# See the documentation for scipy.special.gamma
scipy.special.cython_special.gamma

# See the documentation for scipy.special.gammainc
scipy.special.cython_special.gammainc

# See the documentation for scipy.special.gammaincc
scipy.special.cython_special.gammaincc

# See the documentation for scipy.special.gammainccinv
scipy.special.cython_special.gammainccinv

# See the documentation for scipy.special.gammaincinv
scipy.special.cython_special.gammaincinv

# See the documentation for scipy.special.gammaln
scipy.special.cython_special.gammaln

# See the documentation for scipy.special.gammasgn
scipy.special.cython_special.gammasgn

# See the documentation for scipy.special.gdtr
scipy.special.cython_special.gdtr

# See the documentation for scipy.special.gdtrc
scipy.special.cython_special.gdtrc

# See the documentation for scipy.special.gdtria
scipy.special.cython_special.gdtria

# See the documentation for scipy.special.gdtrib
scipy.special.cython_special.gdtrib

# See the documentation for scipy.special.gdtrix
scipy.special.cython_special.gdtrix

# See the documentation for scipy.special.hankel1
scipy.special.cython_special.hankel1

# See the documentation for scipy.special.hankel1e
scipy.special.cython_special.hankel1e

# See the documentation for scipy.special.hankel2
scipy.special.cython_special.hankel2

# See the documentation for scipy.special.hankel2e
scipy.special.cython_special.hankel2e

# See the documentation for scipy.special.huber
scipy.special.cython_special.huber

# See the documentation for scipy.special.hyp0f1
scipy.special.cython_special.hyp0f1

# See the documentation for scipy.special.hyp1f1
scipy.special.cython_special.hyp1f1

# See the documentation for scipy.special.hyp2f1
scipy.special.cython_special.hyp2f1

# See the documentation for scipy.special.hyperu
scipy.special.cython_special.hyperu

# See the documentation for scipy.special.i0
scipy.special.cython_special.i0

# See the documentation for scipy.special.i0e
scipy.special.cython_special.i0e

# See the documentation for scipy.special.i1
scipy.special.cython_special.i1

# See the documentation for scipy.special.i1e
scipy.special.cython_special.i1e

# See the documentation for scipy.special.inv_boxcox
scipy.special.cython_special.inv_boxcox

# See the documentation for scipy.special.inv_boxcox1p
scipy.special.cython_special.inv_boxcox1p

# See the documentation for scipy.special.it2struve0
scipy.special.cython_special.it2struve0

# See the documentation for scipy.special.itmodstruve0
scipy.special.cython_special.itmodstruve0

# See the documentation for scipy.special.itstruve0
scipy.special.cython_special.itstruve0

# See the documentation for scipy.special.iv
scipy.special.cython_special.iv

# See the documentation for scipy.special.ive
scipy.special.cython_special.ive

# See the documentation for scipy.special.j0
scipy.special.cython_special.j0

# See the documentation for scipy.special.j1
scipy.special.cython_special.j1

# See the documentation for scipy.special.jv
scipy.special.cython_special.jv

# See the documentation for scipy.special.jve
scipy.special.cython_special.jve

# See the documentation for scipy.special.k0
scipy.special.cython_special.k0

# See the documentation for scipy.special.k0e
scipy.special.cython_special.k0e

# See the documentation for scipy.special.k1
scipy.special.cython_special.k1

# See the documentation for scipy.special.k1e
scipy.special.cython_special.k1e

# See the documentation for scipy.special.kei
scipy.special.cython_special.kei

# See the documentation for scipy.special.keip
scipy.special.cython_special.keip

# See the documentation for scipy.special.ker
scipy.special.cython_special.ker

# See the documentation for scipy.special.kerp
scipy.special.cython_special.kerp

# See the documentation for scipy.special.kl_div
scipy.special.cython_special.kl_div

# See the documentation for scipy.special.kn
scipy.special.cython_special.kn

# See the documentation for scipy.special.kolmogi
scipy.special.cython_special.kolmogi

# See the documentation for scipy.special.kolmogorov
scipy.special.cython_special.kolmogorov

# See the documentation for scipy.special.kv
scipy.special.cython_special.kv

# See the documentation for scipy.special.kve
scipy.special.cython_special.kve

# See the documentation for scipy.special.log1p
scipy.special.cython_special.log1p

# See the documentation for scipy.special.log_expit
scipy.special.cython_special.log_expit

# See the documentation for scipy.special.log_ndtr
scipy.special.cython_special.log_ndtr

# See the documentation for scipy.special.log_wright_bessel
scipy.special.cython_special.log_wright_bessel

# See the documentation for scipy.special.loggamma
scipy.special.cython_special.loggamma

# See the documentation for scipy.special.logit
scipy.special.cython_special.logit

# See the documentation for scipy.special.lpmv
scipy.special.cython_special.lpmv

# See the documentation for scipy.special.mathieu_a
scipy.special.cython_special.mathieu_a

# See the documentation for scipy.special.mathieu_b
scipy.special.cython_special.mathieu_b

# See the documentation for scipy.special.modstruve
scipy.special.cython_special.modstruve

# See the documentation for scipy.special.nbdtr
scipy.special.cython_special.nbdtr

# See the documentation for scipy.special.nbdtrc
scipy.special.cython_special.nbdtrc

# See the documentation for scipy.special.nbdtri
scipy.special.cython_special.nbdtri

# See the documentation for scipy.special.nbdtrik
scipy.special.cython_special.nbdtrik

# See the documentation for scipy.special.nbdtrin
scipy.special.cython_special.nbdtrin

# See the documentation for scipy.special.ncfdtr
scipy.special.cython_special.ncfdtr

# See the documentation for scipy.special.ncfdtri
scipy.special.cython_special.ncfdtri

# See the documentation for scipy.special.ncfdtridfd
scipy.special.cython_special.ncfdtridfd

# See the documentation for scipy.special.ncfdtridfn
scipy.special.cython_special.ncfdtridfn

# See the documentation for scipy.special.ncfdtrinc
scipy.special.cython_special.ncfdtrinc

# See the documentation for scipy.special.nctdtr
scipy.special.cython_special.nctdtr

# See the documentation for scipy.special.nctdtridf
scipy.special.cython_special.nctdtridf

# See the documentation for scipy.special.nctdtrinc
scipy.special.cython_special.nctdtrinc

# See the documentation for scipy.special.nctdtrit
scipy.special.cython_special.nctdtrit

# See the documentation for scipy.special.ndtr
scipy.special.cython_special.ndtr

# See the documentation for scipy.special.ndtri
scipy.special.cython_special.ndtri

# See the documentation for scipy.special.ndtri_exp
scipy.special.cython_special.ndtri_exp

# See the documentation for scipy.special.nrdtrimn
scipy.special.cython_special.nrdtrimn

# See the documentation for scipy.special.nrdtrisd
scipy.special.cython_special.nrdtrisd

# See the documentation for scipy.special.obl_cv
scipy.special.cython_special.obl_cv

# See the documentation for scipy.special.owens_t
scipy.special.cython_special.owens_t

# See the documentation for scipy.special.pdtr
scipy.special.cython_special.pdtr

# See the documentation for scipy.special.pdtrc
scipy.special.cython_special.pdtrc

# See the documentation for scipy.special.pdtri
scipy.special.cython_special.pdtri

# See the documentation for scipy.special.pdtrik
scipy.special.cython_special.pdtrik

# See the documentation for scipy.special.poch
scipy.special.cython_special.poch

# See the documentation for scipy.special.powm1
scipy.special.cython_special.powm1

# See the documentation for scipy.special.pro_cv
scipy.special.cython_special.pro_cv

# See the documentation for scipy.special.pseudo_huber
scipy.special.cython_special.pseudo_huber

# See the documentation for scipy.special.psi
scipy.special.cython_special.psi

# See the documentation for scipy.special.radian
scipy.special.cython_special.radian

# See the documentation for scipy.special.rel_entr
scipy.special.cython_special.rel_entr

# See the documentation for scipy.special.rgamma
scipy.special.cython_special.rgamma

# See the documentation for scipy.special.round
scipy.special.cython_special.round

# See the documentation for scipy.special.sindg
scipy.special.cython_special.sindg

# See the documentation for scipy.special.smirnov
scipy.special.cython_special.smirnov

# See the documentation for scipy.special.smirnovi
scipy.special.cython_special.smirnovi

# See the documentation for scipy.special.spence
scipy.special.cython_special.spence

# See the documentation for scipy.special.sph_harm
scipy.special.cython_special.sph_harm

# See the documentation for scipy.special.spherical_in
scipy.special.cython_special.spherical_in

# See the documentation for scipy.special.spherical_jn
scipy.special.cython_special.spherical_jn

# See the documentation for scipy.special.spherical_kn
scipy.special.cython_special.spherical_kn

# See the documentation for scipy.special.spherical_yn
scipy.special.cython_special.spherical_yn

# See the documentation for scipy.special.stdtr
scipy.special.cython_special.stdtr

# See the documentation for scipy.special.stdtridf
scipy.special.cython_special.stdtridf

# See the documentation for scipy.special.stdtrit
scipy.special.cython_special.stdtrit

# See the documentation for scipy.special.struve
scipy.special.cython_special.struve

# See the documentation for scipy.special.tandg
scipy.special.cython_special.tandg

# See the documentation for scipy.special.tklmbda
scipy.special.cython_special.tklmbda

# See the documentation for scipy.special.voigt_profile
scipy.special.cython_special.voigt_profile

# See the documentation for scipy.special.wofz
scipy.special.cython_special.wofz

# See the documentation for scipy.special.wright_bessel
scipy.special.cython_special.wright_bessel

# See the documentation for scipy.special.wrightomega
scipy.special.cython_special.wrightomega

# See the documentation for scipy.special.xlog1py
scipy.special.cython_special.xlog1py

# See the documentation for scipy.special.xlogy
scipy.special.cython_special.xlogy

# See the documentation for scipy.special.y0
scipy.special.cython_special.y0

# See the documentation for scipy.special.y1
scipy.special.cython_special.y1

# See the documentation for scipy.special.yn
scipy.special.cython_special.yn

# See the documentation for scipy.special.yv
scipy.special.cython_special.yv

# See the documentation for scipy.special.yve
scipy.special.cython_special.yve

# See the documentation for scipy.special.zetac
scipy.special.cython_special.zetac

# airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.special.orthogonal.airy

# Gauss-Chebyshev (first kind) quadrature.
scipy.special.orthogonal.c_roots

# Gauss-Gegenbauer quadrature.
scipy.special.orthogonal.cg_roots

# Chebyshev polynomial of the first kind on :math:`[-2, 2]`.
scipy.special.orthogonal.chebyc

# Chebyshev polynomial of the second kind on :math:`[-2, 2]`.
scipy.special.orthogonal.chebys

# Chebyshev polynomial of the first kind.
scipy.special.orthogonal.chebyt

# Chebyshev polynomial of the second kind.
scipy.special.orthogonal.chebyu

# Gegenbauer (ultraspherical) polynomial.
scipy.special.orthogonal.gegenbauer

# Generalized (associated) Laguerre polynomial.
scipy.special.orthogonal.genlaguerre

# Gauss-Hermite (physicist's) quadrature.
scipy.special.orthogonal.h_roots

# Gauss-Hermite (statistician's) quadrature.
scipy.special.orthogonal.he_roots

# Physicist's Hermite polynomial.
scipy.special.orthogonal.hermite

# Normalized (probabilist's) Hermite polynomial.
scipy.special.orthogonal.hermitenorm

# Gauss-Jacobi quadrature.
scipy.special.orthogonal.j_roots

# Jacobi polynomial.
scipy.special.orthogonal.jacobi

# Gauss-Jacobi (shifted) quadrature.
scipy.special.orthogonal.js_roots

# Gauss-Laguerre quadrature.
scipy.special.orthogonal.l_roots

# Gauss-generalized Laguerre quadrature.
scipy.special.orthogonal.la_roots

# Laguerre polynomial.
scipy.special.orthogonal.laguerre

# Legendre polynomial.
scipy.special.orthogonal.legendre

# Gauss-Legendre quadrature.
scipy.special.orthogonal.p_roots

# Gauss-Legendre (shifted) quadrature.
scipy.special.orthogonal.ps_roots

# Gauss-Chebyshev (first kind) quadrature.
scipy.special.orthogonal.roots_chebyc

# Gauss-Chebyshev (second kind) quadrature.
scipy.special.orthogonal.roots_chebys

# Gauss-Chebyshev (first kind) quadrature.
scipy.special.orthogonal.roots_chebyt

# Gauss-Chebyshev (second kind) quadrature.
scipy.special.orthogonal.roots_chebyu

# Gauss-Gegenbauer quadrature.
scipy.special.orthogonal.roots_gegenbauer

# Gauss-generalized Laguerre quadrature.
scipy.special.orthogonal.roots_genlaguerre

# Gauss-Hermite (physicist's) quadrature.
scipy.special.orthogonal.roots_hermite

# Gauss-Hermite (statistician's) quadrature.
scipy.special.orthogonal.roots_hermitenorm

# Gauss-Jacobi quadrature.
scipy.special.orthogonal.roots_jacobi

# Gauss-Laguerre quadrature.
scipy.special.orthogonal.roots_laguerre

# Gauss-Legendre quadrature.
scipy.special.orthogonal.roots_legendre

# Gauss-Chebyshev (first kind, shifted) quadrature.
scipy.special.orthogonal.roots_sh_chebyt

# Gauss-Chebyshev (second kind, shifted) quadrature.
scipy.special.orthogonal.roots_sh_chebyu

# Gauss-Jacobi (shifted) quadrature.
scipy.special.orthogonal.roots_sh_jacobi

# Gauss-Legendre (shifted) quadrature.
scipy.special.orthogonal.roots_sh_legendre

# Gauss-Chebyshev (second kind) quadrature.
scipy.special.orthogonal.s_roots

# Shifted Chebyshev polynomial of the first kind.
scipy.special.orthogonal.sh_chebyt

# Shifted Chebyshev polynomial of the second kind.
scipy.special.orthogonal.sh_chebyu

# Shifted Jacobi polynomial.
scipy.special.orthogonal.sh_jacobi

# Shifted Legendre polynomial.
scipy.special.orthogonal.sh_legendre

# Gauss-Chebyshev (first kind) quadrature.
scipy.special.orthogonal.t_roots

# Gauss-Chebyshev (first kind, shifted) quadrature.
scipy.special.orthogonal.ts_roots

# Gauss-Chebyshev (second kind) quadrature.
scipy.special.orthogonal.u_roots

# Gauss-Chebyshev (second kind, shifted) quadrature.
scipy.special.orthogonal.us_roots

# Exception that can be raised by special functions.
scipy.special.sf_error.SpecialFunctionError

# Warning that can be emitted by special functions.
scipy.special.sf_error.SpecialFunctionWarning

# Associated Legendre function of the first kind for complex arguments.
scipy.special.specfun.clpmn

# Sequence of associated Legendre functions of the first kind.
scipy.special.specfun.lpmn

# Legendre function of the first kind.
scipy.special.specfun.lpn

# Sequence of associated Legendre functions of the second kind.
scipy.special.specfun.lqmn

scipy.special.specfun.pbdv

# Returns the log of multivariate gamma, also sometimes called the
scipy.special.spfun_stats.multigammaln

# Cython translation for the FORTRAN 77 code given in:
scipy.stats._ansari_swilk_statistics.gscale

# NumPy
scipy.stats._ansari_swilk_statistics.np

# Calculates the Shapiro-Wilk W test and its significance level
scipy.stats._ansari_swilk_statistics.swilk

# Axis supplied was invalid.
scipy.stats._axis_nan_policy.AxisError

scipy.stats._axis_nan_policy.FunctionDoc

# Parameter(name, type, desc)
scipy.stats._axis_nan_policy.Parameter

scipy.stats._axis_nan_policy.SmallSampleWarning

# Get the array API compatible namespace for the arrays xs.
scipy.stats._axis_nan_policy.array_namespace

# Get useful information from live Python objects.
scipy.stats._axis_nan_policy.inspect

# Returns True if `xp` is a NumPy namespace.
scipy.stats._axis_nan_policy.is_numpy

# NumPy
scipy.stats._axis_nan_policy.np

# str(object='') -> str
scipy.stats._axis_nan_policy.too_small_1d_not_omit

# str(object='') -> str
scipy.stats._axis_nan_policy.too_small_1d_omit

# str(object='') -> str
scipy.stats._axis_nan_policy.too_small_nd_not_omit

# str(object='') -> str
scipy.stats._axis_nan_policy.too_small_nd_omit

# Python part of the warnings subsystem.
scipy.stats._axis_nan_policy.warnings

# Decorator factory to apply update_wrapper() to a wrapper function
scipy.stats._axis_nan_policy.wraps

# NumPy
scipy.stats._biasedurn.np

# Compute a binned statistic for one or more sets of data.
scipy.stats._binned_statistic.binned_statistic

# Compute a bidimensional binned statistic for one or more sets of data.
scipy.stats._binned_statistic.binned_statistic_2d

# Compute a multidimensional binned statistic for a set of data.
scipy.stats._binned_statistic.binned_statistic_dd

# Result of `scipy.stats.binomtest`.
scipy.stats._binomtest.BinomTestResult

# Class for confidence intervals.
scipy.stats._binomtest.ConfidenceInterval

# A binomial discrete random variable.
scipy.stats._binomtest.binom

# Perform a test that the probability of success is p.
scipy.stats._binomtest.binomtest

# Find a root of a function in a bracketing interval using Brent's method.
scipy.stats._binomtest.brentq

# ndtri(y, out=None)
scipy.stats._binomtest.ndtri

# NumPy
scipy.stats._binomtest.np

# Return the square root of x.
scipy.stats._binomtest.sqrt

# Perform the Baumgartner-Weiss-Schindler test on two independent samples.
scipy.stats._bws_test.bws_test

# NumPy
scipy.stats._bws_test.np

# Create a new function with partial application of the given arguments
scipy.stats._bws_test.partial

# .. _statsrefmanual:
scipy.stats._bws_test.stats

# Instances of this class represent censored data.
scipy.stats._censored_data.CensoredData

# NumPy
scipy.stats._censored_data.np

# Class for confidence intervals.
scipy.stats._common.ConfidenceInterval

# Returns a new subclass of tuple with named fields.
scipy.stats._common.namedtuple

# NumPy
scipy.stats._constants.np

# Get the array API compatible namespace for the arrays xs.
scipy.stats._continued_fraction.array_namespace

scipy.stats._continued_fraction.eim

# NumPy
scipy.stats._continued_fraction.np

# ========================================
scipy.stats._continued_fraction.special

# Copies an array.
scipy.stats._continued_fraction.xp_copy

# Promotes elements of *args to result dtype, ignoring `None`s.
scipy.stats._continued_fraction.xp_promote

scipy.stats._continued_fraction.xp_ravel

# An alpha continuous random variable.
scipy.stats._continuous_distns.alpha

# An alpha continuous random variable.
scipy.stats._continuous_distns.alpha_gen

# An anglit continuous random variable.
scipy.stats._continuous_distns.anglit

# An anglit continuous random variable.
scipy.stats._continuous_distns.anglit_gen

# An arcsine continuous random variable.
scipy.stats._continuous_distns.arcsine

# An arcsine continuous random variable.
scipy.stats._continuous_distns.arcsine_gen

# Argus distribution
scipy.stats._continuous_distns.argus

# Argus distribution
scipy.stats._continuous_distns.argus_gen

# A beta continuous random variable.
scipy.stats._continuous_distns.beta

# A beta continuous random variable.
scipy.stats._continuous_distns.beta_gen

# A beta prime continuous random variable.
scipy.stats._continuous_distns.betaprime

# A beta prime continuous random variable.
scipy.stats._continuous_distns.betaprime_gen

# A Bradford continuous random variable.
scipy.stats._continuous_distns.bradford

# A Bradford continuous random variable.
scipy.stats._continuous_distns.bradford_gen

# A Burr (Type III) continuous random variable.
scipy.stats._continuous_distns.burr

# A Burr (Type XII) continuous random variable.
scipy.stats._continuous_distns.burr12

# A Burr (Type XII) continuous random variable.
scipy.stats._continuous_distns.burr12_gen

# A Burr (Type III) continuous random variable.
scipy.stats._continuous_distns.burr_gen

# A Cauchy continuous random variable.
scipy.stats._continuous_distns.cauchy

# A Cauchy continuous random variable.
scipy.stats._continuous_distns.cauchy_gen

# A chi continuous random variable.
scipy.stats._continuous_distns.chi

# A chi-squared continuous random variable.
scipy.stats._continuous_distns.chi2

# A chi-squared continuous random variable.
scipy.stats._continuous_distns.chi2_gen

# A chi continuous random variable.
scipy.stats._continuous_distns.chi_gen

# A cosine continuous random variable.
scipy.stats._continuous_distns.cosine

# A cosine continuous random variable.
scipy.stats._continuous_distns.cosine_gen

# Crystalball distribution
scipy.stats._continuous_distns.crystalball

# Crystalball distribution
scipy.stats._continuous_distns.crystalball_gen

# A double gamma continuous random variable.
scipy.stats._continuous_distns.dgamma

# A double gamma continuous random variable.
scipy.stats._continuous_distns.dgamma_gen

# A double Pareto lognormal continuous random variable.
scipy.stats._continuous_distns.dpareto_lognorm

# A double Pareto lognormal continuous random variable.
scipy.stats._continuous_distns.dpareto_lognorm_gen

# A double Weibull continuous random variable.
scipy.stats._continuous_distns.dweibull

# A double Weibull continuous random variable.
scipy.stats._continuous_distns.dweibull_gen

# An Erlang continuous random variable.
scipy.stats._continuous_distns.erlang

# An Erlang continuous random variable.
scipy.stats._continuous_distns.erlang_gen

# An exponential continuous random variable.
scipy.stats._continuous_distns.expon

# An exponential continuous random variable.
scipy.stats._continuous_distns.expon_gen

# An exponentially modified Normal continuous random variable.
scipy.stats._continuous_distns.exponnorm

# An exponentially modified Normal continuous random variable.
scipy.stats._continuous_distns.exponnorm_gen

# An exponential power continuous random variable.
scipy.stats._continuous_distns.exponpow

# An exponential power continuous random variable.
scipy.stats._continuous_distns.exponpow_gen

# An exponentiated Weibull continuous random variable.
scipy.stats._continuous_distns.exponweib

# An exponentiated Weibull continuous random variable.
scipy.stats._continuous_distns.exponweib_gen

# An F continuous random variable.
scipy.stats._continuous_distns.f

# An F continuous random variable.
scipy.stats._continuous_distns.f_gen

# A fatigue-life (Birnbaum-Saunders) continuous random variable.
scipy.stats._continuous_distns.fatiguelife

# A fatigue-life (Birnbaum-Saunders) continuous random variable.
scipy.stats._continuous_distns.fatiguelife_gen

# A Fisk continuous random variable.
scipy.stats._continuous_distns.fisk

# A Fisk continuous random variable.
scipy.stats._continuous_distns.fisk_gen

# A folded Cauchy continuous random variable.
scipy.stats._continuous_distns.foldcauchy

# A folded Cauchy continuous random variable.
scipy.stats._continuous_distns.foldcauchy_gen

# A folded normal continuous random variable.
scipy.stats._continuous_distns.foldnorm

# A folded normal continuous random variable.
scipy.stats._continuous_distns.foldnorm_gen

# A gamma continuous random variable.
scipy.stats._continuous_distns.gamma

# A gamma continuous random variable.
scipy.stats._continuous_distns.gamma_gen

# A Gauss hypergeometric continuous random variable.
scipy.stats._continuous_distns.gausshyper

# A Gauss hypergeometric continuous random variable.
scipy.stats._continuous_distns.gausshyper_gen

# A generalized exponential continuous random variable.
scipy.stats._continuous_distns.genexpon

# A generalized exponential continuous random variable.
scipy.stats._continuous_distns.genexpon_gen

# A generalized extreme value continuous random variable.
scipy.stats._continuous_distns.genextreme

# A generalized extreme value continuous random variable.
scipy.stats._continuous_distns.genextreme_gen

# A generalized gamma continuous random variable.
scipy.stats._continuous_distns.gengamma

# A generalized gamma continuous random variable.
scipy.stats._continuous_distns.gengamma_gen

# A generalized half-logistic continuous random variable.
scipy.stats._continuous_distns.genhalflogistic

# A generalized half-logistic continuous random variable.
scipy.stats._continuous_distns.genhalflogistic_gen

# A generalized hyperbolic continuous random variable.
scipy.stats._continuous_distns.genhyperbolic

# A generalized hyperbolic continuous random variable.
scipy.stats._continuous_distns.genhyperbolic_gen

# A Generalized Inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.geninvgauss

# A Generalized Inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.geninvgauss_gen

# A generalized logistic continuous random variable.
scipy.stats._continuous_distns.genlogistic

# A generalized logistic continuous random variable.
scipy.stats._continuous_distns.genlogistic_gen

# A generalized normal continuous random variable.
scipy.stats._continuous_distns.gennorm

# A generalized normal continuous random variable.
scipy.stats._continuous_distns.gennorm_gen

# A generalized Pareto continuous random variable.
scipy.stats._continuous_distns.genpareto

# A generalized Pareto continuous random variable.
scipy.stats._continuous_distns.genpareto_gen

# A Gibrat continuous random variable.
scipy.stats._continuous_distns.gibrat

# A Gibrat continuous random variable.
scipy.stats._continuous_distns.gibrat_gen

# A Gompertz (or truncated Gumbel) continuous random variable.
scipy.stats._continuous_distns.gompertz

# A Gompertz (or truncated Gumbel) continuous random variable.
scipy.stats._continuous_distns.gompertz_gen

# A left-skewed Gumbel continuous random variable.
scipy.stats._continuous_distns.gumbel_l

# A left-skewed Gumbel continuous random variable.
scipy.stats._continuous_distns.gumbel_l_gen

# A right-skewed Gumbel continuous random variable.
scipy.stats._continuous_distns.gumbel_r

# A right-skewed Gumbel continuous random variable.
scipy.stats._continuous_distns.gumbel_r_gen

# A Half-Cauchy continuous random variable.
scipy.stats._continuous_distns.halfcauchy

# A Half-Cauchy continuous random variable.
scipy.stats._continuous_distns.halfcauchy_gen

# The upper half of a generalized normal continuous random variable.
scipy.stats._continuous_distns.halfgennorm

# The upper half of a generalized normal continuous random variable.
scipy.stats._continuous_distns.halfgennorm_gen

# A half-logistic continuous random variable.
scipy.stats._continuous_distns.halflogistic

# A half-logistic continuous random variable.
scipy.stats._continuous_distns.halflogistic_gen

# A half-normal continuous random variable.
scipy.stats._continuous_distns.halfnorm

# A half-normal continuous random variable.
scipy.stats._continuous_distns.halfnorm_gen

# A hyperbolic secant continuous random variable.
scipy.stats._continuous_distns.hypsecant

# A hyperbolic secant continuous random variable.
scipy.stats._continuous_distns.hypsecant_gen

# An inverted gamma continuous random variable.
scipy.stats._continuous_distns.invgamma

# An inverted gamma continuous random variable.
scipy.stats._continuous_distns.invgamma_gen

# An inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.invgauss

# An inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.invgauss_gen

# An inverted Weibull continuous random variable.
scipy.stats._continuous_distns.invweibull

# An inverted Weibull continuous random variable.
scipy.stats._continuous_distns.invweibull_gen

# An Irwin-Hall (Uniform Sum) continuous random variable.
scipy.stats._continuous_distns.irwinhall

# An Irwin-Hall (Uniform Sum) continuous random variable.
scipy.stats._continuous_distns.irwinhall_gen

# Jones and Faddy skew-t distribution.
scipy.stats._continuous_distns.jf_skew_t

# Jones and Faddy skew-t distribution.
scipy.stats._continuous_distns.jf_skew_t_gen

# A Johnson SB continuous random variable.
scipy.stats._continuous_distns.johnsonsb

# A Johnson SB continuous random variable.
scipy.stats._continuous_distns.johnsonsb_gen

# A Johnson SU continuous random variable.
scipy.stats._continuous_distns.johnsonsu

# A Johnson SU continuous random variable.
scipy.stats._continuous_distns.johnsonsu_gen

# Kappa 3 parameter distribution.
scipy.stats._continuous_distns.kappa3

# Kappa 3 parameter distribution.
scipy.stats._continuous_distns.kappa3_gen

# Kappa 4 parameter distribution.
scipy.stats._continuous_distns.kappa4

# Kappa 4 parameter distribution.
scipy.stats._continuous_distns.kappa4_gen

# Kolmogorov-Smirnov one-sided test statistic distribution.
scipy.stats._continuous_distns.ksone

# Kolmogorov-Smirnov one-sided test statistic distribution.
scipy.stats._continuous_distns.ksone_gen

# Kolmogorov-Smirnov two-sided test statistic distribution.
scipy.stats._continuous_distns.kstwo

# Kolmogorov-Smirnov two-sided test statistic distribution.
scipy.stats._continuous_distns.kstwo_gen

# Limiting distribution of scaled Kolmogorov-Smirnov two-sided test statistic.
scipy.stats._continuous_distns.kstwobign

# Limiting distribution of scaled Kolmogorov-Smirnov two-sided test statistic.
scipy.stats._continuous_distns.kstwobign_gen

# A Landau continuous random variable.
scipy.stats._continuous_distns.landau

# A Landau continuous random variable.
scipy.stats._continuous_distns.landau_gen

# A Laplace continuous random variable.
scipy.stats._continuous_distns.laplace

# An asymmetric Laplace continuous random variable.
scipy.stats._continuous_distns.laplace_asymmetric

# An asymmetric Laplace continuous random variable.
scipy.stats._continuous_distns.laplace_asymmetric_gen

# A Laplace continuous random variable.
scipy.stats._continuous_distns.laplace_gen

# A Levy continuous random variable.
scipy.stats._continuous_distns.levy

# A Levy continuous random variable.
scipy.stats._continuous_distns.levy_gen

# A left-skewed Levy continuous random variable.
scipy.stats._continuous_distns.levy_l

# A left-skewed Levy continuous random variable.
scipy.stats._continuous_distns.levy_l_gen

# A log gamma continuous random variable.
scipy.stats._continuous_distns.loggamma

# A log gamma continuous random variable.
scipy.stats._continuous_distns.loggamma_gen

# A logistic (or Sech-squared) continuous random variable.
scipy.stats._continuous_distns.logistic

# A logistic (or Sech-squared) continuous random variable.
scipy.stats._continuous_distns.logistic_gen

# A log-Laplace continuous random variable.
scipy.stats._continuous_distns.loglaplace

# A log-Laplace continuous random variable.
scipy.stats._continuous_distns.loglaplace_gen

# A lognormal continuous random variable.
scipy.stats._continuous_distns.lognorm

# A lognormal continuous random variable.
scipy.stats._continuous_distns.lognorm_gen

# A loguniform or reciprocal continuous random variable.
scipy.stats._continuous_distns.loguniform

# A Lomax (Pareto of the second kind) continuous random variable.
scipy.stats._continuous_distns.lomax

# A Lomax (Pareto of the second kind) continuous random variable.
scipy.stats._continuous_distns.lomax_gen

# A Maxwell continuous random variable.
scipy.stats._continuous_distns.maxwell

# A Maxwell continuous random variable.
scipy.stats._continuous_distns.maxwell_gen

# A Mielke Beta-Kappa / Dagum continuous random variable.
scipy.stats._continuous_distns.mielke

# A Mielke Beta-Kappa / Dagum continuous random variable.
scipy.stats._continuous_distns.mielke_gen

# A Moyal continuous random variable.
scipy.stats._continuous_distns.moyal

# A Moyal continuous random variable.
scipy.stats._continuous_distns.moyal_gen

# A Nakagami continuous random variable.
scipy.stats._continuous_distns.nakagami

# A Nakagami continuous random variable.
scipy.stats._continuous_distns.nakagami_gen

# A non-central F distribution continuous random variable.
scipy.stats._continuous_distns.ncf

# A non-central F distribution continuous random variable.
scipy.stats._continuous_distns.ncf_gen

# A non-central Student's t continuous random variable.
scipy.stats._continuous_distns.nct

# A non-central Student's t continuous random variable.
scipy.stats._continuous_distns.nct_gen

# A non-central chi-squared continuous random variable.
scipy.stats._continuous_distns.ncx2

# A non-central chi-squared continuous random variable.
scipy.stats._continuous_distns.ncx2_gen

# A normal continuous random variable.
scipy.stats._continuous_distns.norm

# A normal continuous random variable.
scipy.stats._continuous_distns.norm_gen

# A Normal Inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.norminvgauss

# A Normal Inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.norminvgauss_gen

# A Pareto continuous random variable.
scipy.stats._continuous_distns.pareto

# A Pareto continuous random variable.
scipy.stats._continuous_distns.pareto_gen

# A pearson type III continuous random variable.
scipy.stats._continuous_distns.pearson3

# A pearson type III continuous random variable.
scipy.stats._continuous_distns.pearson3_gen

# A power-function continuous random variable.
scipy.stats._continuous_distns.powerlaw

# A power-function continuous random variable.
scipy.stats._continuous_distns.powerlaw_gen

# A power log-normal continuous random variable.
scipy.stats._continuous_distns.powerlognorm

# A power log-normal continuous random variable.
scipy.stats._continuous_distns.powerlognorm_gen

# A power normal continuous random variable.
scipy.stats._continuous_distns.powernorm

# A power normal continuous random variable.
scipy.stats._continuous_distns.powernorm_gen

# A Rayleigh continuous random variable.
scipy.stats._continuous_distns.rayleigh

# A Rayleigh continuous random variable.
scipy.stats._continuous_distns.rayleigh_gen

# An R-distributed (symmetric beta) continuous random variable.
scipy.stats._continuous_distns.rdist

# An R-distributed (symmetric beta) continuous random variable.
scipy.stats._continuous_distns.rdist_gen

# A reciprocal inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.recipinvgauss

# A reciprocal inverse Gaussian continuous random variable.
scipy.stats._continuous_distns.recipinvgauss_gen

# A loguniform or reciprocal continuous random variable.
scipy.stats._continuous_distns.reciprocal

# A loguniform or reciprocal continuous random variable.
scipy.stats._continuous_distns.reciprocal_gen

# A relativistic Breit-Wigner random variable.
scipy.stats._continuous_distns.rel_breitwigner

# A relativistic Breit-Wigner random variable.
scipy.stats._continuous_distns.rel_breitwigner_gen

# A Rice continuous random variable.
scipy.stats._continuous_distns.rice

# A Rice continuous random variable.
scipy.stats._continuous_distns.rice_gen

# Generates a distribution given by a histogram.
scipy.stats._continuous_distns.rv_histogram

# A semicircular continuous random variable.
scipy.stats._continuous_distns.semicircular

# A semicircular continuous random variable.
scipy.stats._continuous_distns.semicircular_gen

# A skewed Cauchy random variable.
scipy.stats._continuous_distns.skewcauchy

# A skewed Cauchy random variable.
scipy.stats._continuous_distns.skewcauchy_gen

# A skew-normal random variable.
scipy.stats._continuous_distns.skewnorm

# A skew-normal random variable.
scipy.stats._continuous_distns.skewnorm_gen

# A studentized range continuous random variable.
scipy.stats._continuous_distns.studentized_range

# A studentized range continuous random variable.
scipy.stats._continuous_distns.studentized_range_gen

# A Student's t continuous random variable.
scipy.stats._continuous_distns.t

# A Student's t continuous random variable.
scipy.stats._continuous_distns.t_gen

# A trapezoidal continuous random variable.
scipy.stats._continuous_distns.trapezoid

# A trapezoidal continuous random variable.
scipy.stats._continuous_distns.trapezoid_gen

# A triangular continuous random variable.
scipy.stats._continuous_distns.triang

# A triangular continuous random variable.
scipy.stats._continuous_distns.triang_gen

# A truncated exponential continuous random variable.
scipy.stats._continuous_distns.truncexpon

# A truncated exponential continuous random variable.
scipy.stats._continuous_distns.truncexpon_gen

# A truncated normal continuous random variable.
scipy.stats._continuous_distns.truncnorm

# A truncated normal continuous random variable.
scipy.stats._continuous_distns.truncnorm_gen

# An upper truncated Pareto continuous random variable.
scipy.stats._continuous_distns.truncpareto

# An upper truncated Pareto continuous random variable.
scipy.stats._continuous_distns.truncpareto_gen

# A doubly truncated Weibull minimum continuous random variable.
scipy.stats._continuous_distns.truncweibull_min

# A doubly truncated Weibull minimum continuous random variable.
scipy.stats._continuous_distns.truncweibull_min_gen

# A Tukey-Lamdba continuous random variable.
scipy.stats._continuous_distns.tukeylambda

# A Tukey-Lamdba continuous random variable.
scipy.stats._continuous_distns.tukeylambda_gen

# A uniform continuous random variable.
scipy.stats._continuous_distns.uniform

# A uniform continuous random variable.
scipy.stats._continuous_distns.uniform_gen

# A Von Mises continuous random variable.
scipy.stats._continuous_distns.vonmises

# A Von Mises continuous random variable.
scipy.stats._continuous_distns.vonmises_gen

# A Von Mises continuous random variable.
scipy.stats._continuous_distns.vonmises_line

# A Wald continuous random variable.
scipy.stats._continuous_distns.wald

# A Wald continuous random variable.
scipy.stats._continuous_distns.wald_gen

# Weibull maximum continuous random variable.
scipy.stats._continuous_distns.weibull_max

# Weibull maximum continuous random variable.
scipy.stats._continuous_distns.weibull_max_gen

# Weibull minimum continuous random variable.
scipy.stats._continuous_distns.weibull_min

# Weibull minimum continuous random variable.
scipy.stats._continuous_distns.weibull_min_gen

# A wrapped Cauchy continuous random variable.
scipy.stats._continuous_distns.wrapcauchy

# A wrapped Cauchy continuous random variable.
scipy.stats._continuous_distns.wrapcauchy_gen

# Compute the xi correlation and perform a test of independence
scipy.stats._correlation.chatterjeexi

# Representation of a covariance matrix
scipy.stats._covariance.Covariance

# CrosstabResult(elements, count)
scipy.stats._crosstab.CrosstabResult

# A sparse matrix in COOrdinate format.
scipy.stats._crosstab.coo_matrix

# Return table of counts for each possible unique combination in ``*args``.
scipy.stats._crosstab.crosstab

# NumPy
scipy.stats._crosstab.np

# A Bernoulli discrete random variable.
scipy.stats._discrete_distns.bernoulli

# A Bernoulli discrete random variable.
scipy.stats._discrete_distns.bernoulli_gen

# A beta-binomial discrete random variable.
scipy.stats._discrete_distns.betabinom

# A beta-binomial discrete random variable.
scipy.stats._discrete_distns.betabinom_gen

# A beta-negative-binomial discrete random variable.
scipy.stats._discrete_distns.betanbinom

# A beta-negative-binomial discrete random variable.
scipy.stats._discrete_distns.betanbinom_gen

# A binomial discrete random variable.
scipy.stats._discrete_distns.binom

# A binomial discrete random variable.
scipy.stats._discrete_distns.binom_gen

# A Boltzmann (Truncated Discrete Exponential) random variable.
scipy.stats._discrete_distns.boltzmann

# A Boltzmann (Truncated Discrete Exponential) random variable.
scipy.stats._discrete_distns.boltzmann_gen

# A  Laplacian discrete random variable.
scipy.stats._discrete_distns.dlaplace

# A  Laplacian discrete random variable.
scipy.stats._discrete_distns.dlaplace_gen

# A geometric discrete random variable.
scipy.stats._discrete_distns.geom

# A geometric discrete random variable.
scipy.stats._discrete_distns.geom_gen

# A hypergeometric discrete random variable.
scipy.stats._discrete_distns.hypergeom

# A hypergeometric discrete random variable.
scipy.stats._discrete_distns.hypergeom_gen

# A Logarithmic (Log-Series, Series) discrete random variable.
scipy.stats._discrete_distns.logser

# A Logarithmic (Log-Series, Series) discrete random variable.
scipy.stats._discrete_distns.logser_gen

# A negative binomial discrete random variable.
scipy.stats._discrete_distns.nbinom

# A negative binomial discrete random variable.
scipy.stats._discrete_distns.nbinom_gen

# A Fisher's noncentral hypergeometric discrete random variable.
scipy.stats._discrete_distns.nchypergeom_fisher

# A Fisher's noncentral hypergeometric discrete random variable.
scipy.stats._discrete_distns.nchypergeom_fisher_gen

# A Wallenius' noncentral hypergeometric discrete random variable.
scipy.stats._discrete_distns.nchypergeom_wallenius

# A Wallenius' noncentral hypergeometric discrete random variable.
scipy.stats._discrete_distns.nchypergeom_wallenius_gen

# A negative hypergeometric discrete random variable.
scipy.stats._discrete_distns.nhypergeom

# A negative hypergeometric discrete random variable.
scipy.stats._discrete_distns.nhypergeom_gen

# A Planck discrete exponential random variable.
scipy.stats._discrete_distns.planck

# A Planck discrete exponential random variable.
scipy.stats._discrete_distns.planck_gen

# A Poisson discrete random variable.
scipy.stats._discrete_distns.poisson

# A Poisson Binomial discrete random variable.
scipy.stats._discrete_distns.poisson_binom

# A Poisson Binomial discrete random variable.
scipy.stats._discrete_distns.poisson_binom_gen

# A Poisson discrete random variable.
scipy.stats._discrete_distns.poisson_gen

# A uniform discrete random variable.
scipy.stats._discrete_distns.randint

# A uniform discrete random variable.
scipy.stats._discrete_distns.randint_gen

# A  Skellam discrete random variable.
scipy.stats._discrete_distns.skellam

# A  Skellam discrete random variable.
scipy.stats._discrete_distns.skellam_gen

# A Yule-Simon discrete random variable.
scipy.stats._discrete_distns.yulesimon

# A Yule-Simon discrete random variable.
scipy.stats._discrete_distns.yulesimon_gen

# A Zipf (Zeta) discrete random variable.
scipy.stats._discrete_distns.zipf

# A Zipf (Zeta) discrete random variable.
scipy.stats._discrete_distns.zipf_gen

# A Zipfian discrete random variable.
scipy.stats._discrete_distns.zipfian

# A Zipfian discrete random variable.
scipy.stats._discrete_distns.zipfian_gen

# Instances of this class represent censored data.
scipy.stats._distn_infrastructure.CensoredData

# Represents an error condition when fitting a distribution to data.
scipy.stats._distn_infrastructure.FitError

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
scipy.stats._distn_infrastructure.arange

# Returns the indices of the maximum values along an axis.
scipy.stats._distn_infrastructure.argmax

# Clean arguments to:
scipy.stats._distn_infrastructure.argsreduce

# asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
scipy.stats._distn_infrastructure.asarray

# Turn `seed` into a `np.random.RandomState` instance.
scipy.stats._distn_infrastructure.check_random_state

# The number of combinations of N things taken k at a time.
scipy.stats._distn_infrastructure.comb

# Built-in mutable sequence.
scipy.stats._distn_infrastructure.distcont

# Built-in mutable sequence.
scipy.stats._distn_infrastructure.distdiscrete

# Utilities to allow inserting docstring fragments for common
scipy.stats._distn_infrastructure.doccer

# dict() -> new empty dictionary
scipy.stats._distn_infrastructure.docdict

# dict() -> new empty dictionary
scipy.stats._distn_infrastructure.docdict_discrete

# dict() -> new empty dictionary
scipy.stats._distn_infrastructure.docheaders

# empty(shape, dtype=float, order='C', *, device=None, like=None)
scipy.stats._distn_infrastructure.empty

# entr(x, out=None)
scipy.stats._distn_infrastructure.entr

# floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._distn_infrastructure.floor

# Collect names of statistical distributions and their generators.
scipy.stats._distn_infrastructure.get_distribution_names

# Convert a string or number to a floating-point number, if possible.
scipy.stats._distn_infrastructure.inf

# =============================================
scipy.stats._distn_infrastructure.integrate

# isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._distn_infrastructure.isinf

# Keywords (from "Grammar/python.gram")
scipy.stats._distn_infrastructure.keyword

# log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._distn_infrastructure.log

# logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._distn_infrastructure.logical_and

# Convert a string or number to a floating-point number, if possible.
scipy.stats._distn_infrastructure.nan

# ndarray(shape, dtype=float, buffer=None, offset=0,
scipy.stats._distn_infrastructure.ndarray

# NumPy
scipy.stats._distn_infrastructure.np

# Return a new array of given shape and type, filled with ones.
scipy.stats._distn_infrastructure.ones

# =====================================================
scipy.stats._distn_infrastructure.optimize

# str(object='') -> str
scipy.stats._distn_infrastructure.parse_arg_template

# Change elements of an array based on conditional and input values.
scipy.stats._distn_infrastructure.place

# putmask(a, mask, values)
scipy.stats._distn_infrastructure.putmask

# Support for regular expressions (RE).
scipy.stats._distn_infrastructure.re

# A generic continuous random variable class meant for subclassing.
scipy.stats._distn_infrastructure.rv_continuous

scipy.stats._distn_infrastructure.rv_continuous_frozen

# A generic discrete random variable class meant for subclassing.
scipy.stats._distn_infrastructure.rv_discrete

scipy.stats._distn_infrastructure.rv_discrete_frozen

scipy.stats._distn_infrastructure.rv_frozen

# Class which encapsulates common functionality between rv_discrete
scipy.stats._distn_infrastructure.rv_generic

# A 'sample' discrete distribution defined by the support and values.
scipy.stats._distn_infrastructure.rv_sample

# Return the shape of an array.
scipy.stats._distn_infrastructure.shape

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._distn_infrastructure.sqrt

# .. _statsrefmanual:
scipy.stats._distn_infrastructure.stats

# This module provides access to some objects used or maintained by the
scipy.stats._distn_infrastructure.sys

# Define names for built-in types that aren't directly accessible as a builtin.
scipy.stats._distn_infrastructure.types

# vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,
scipy.stats._distn_infrastructure.vectorize

# Python part of the warnings subsystem.
scipy.stats._distn_infrastructure.warnings

# Extra array functions built on top of the array API standard.
scipy.stats._distn_infrastructure.xpx

# zeros(shape, dtype=float, order='C', *, like=None)
scipy.stats._distn_infrastructure.zeros

# Return a zip_longest object whose .__next__() method returns a tuple where
scipy.stats._distn_infrastructure.zip_longest

# Built-in mutable sequence.
scipy.stats._distr_params.distcont

# Built-in mutable sequence.
scipy.stats._distr_params.distdiscrete

# Built-in mutable sequence.
scipy.stats._distr_params.invdistcont

# Built-in mutable sequence.
scipy.stats._distr_params.invdistdiscrete

# NumPy
scipy.stats._distr_params.np

# Representation of a mixture distribution.
scipy.stats._distribution_infrastructure.Mixture

# Absolute value of a random variable
scipy.stats._distribution_infrastructure.abs

# Natural exponential of a random variable
scipy.stats._distribution_infrastructure.exp

# Natural logarithm of a non-negative random variable
scipy.stats._distribution_infrastructure.log

# Generate a `UnivariateDistribution` class from a compatible object
scipy.stats._distribution_infrastructure.make_distribution

# Probability distribution of an order statistic
scipy.stats._distribution_infrastructure.order_statistic

# Truncate the support of a random variable.
scipy.stats._distribution_infrastructure.truncate

# Given a sample of a distribution, estimate the differential entropy.
scipy.stats._entropy.differential_entropy

# Calculate the Shannon entropy/relative entropy of given distribution(s).
scipy.stats._entropy.entropy

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
scipy.stats._finite_differences.arange

# array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
scipy.stats._finite_differences.array

# Stack arrays in sequence horizontally (column wise).
scipy.stats._finite_differences.hstack

# ====================================
scipy.stats._finite_differences.linalg

# The type of the None singleton.
scipy.stats._finite_differences.newaxis

# Return the product of array elements over a given axis.
scipy.stats._finite_differences.prod

# Result of fitting a discrete or continuous distribution to data
scipy.stats._fit.FitResult

# GoodnessOfFitResult(fit_result, statistic, pvalue, null_distribution)
scipy.stats._fit.GoodnessOfFitResult

# Turn `seed` into a `np.random.RandomState` instance.
scipy.stats._fit.check_random_state

# Fit a discrete or continuous distribution to data
scipy.stats._fit.fit

# Perform a goodness of fit test comparing data to a distribution family.
scipy.stats._fit.goodness_of_fit

# Returns a new subclass of tuple with named fields.
scipy.stats._fit.namedtuple

# NumPy
scipy.stats._fit.np

# =====================================================
scipy.stats._fit.optimize

# .. _statsrefmanual:
scipy.stats._fit.stats

# Python part of the warnings subsystem.
scipy.stats._fit.warnings

# Representation of a kernel-density estimate using Gaussian kernels.
scipy.stats._kde.gaussian_kde

# Computes the CDF for the two-sided Kolmogorov-Smirnov distribution.
scipy.stats._ksstats.kolmogn

# Computes the PPF(or ISF) for the two-sided Kolmogorov-Smirnov distribution.
scipy.stats._ksstats.kolmogni

# Computes the PDF for the two-sided Kolmogorov-Smirnov distribution.
scipy.stats._ksstats.kolmognp

# NumPy
scipy.stats._ksstats.np

# SciPy: A scientific computing package for Python
scipy.stats._ksstats.scipy

scipy.stats._ksstats.scu

scipy.stats._levy_stable.levyst.Nolan

# MannwhitneyuResult(statistic, pvalue)
scipy.stats._mannwhitneyu.MannwhitneyuResult

# Perform the Mann-Whitney U rank test on two independent samples.
scipy.stats._mannwhitneyu.mannwhitneyu

# Returns a new subclass of tuple with named fields.
scipy.stats._mannwhitneyu.namedtuple

# NumPy
scipy.stats._mannwhitneyu.np

# ========================================
scipy.stats._mannwhitneyu.special

# .. _statsrefmanual:
scipy.stats._mannwhitneyu.stats

# Thread module emulating a subset of Java's threading model.
scipy.stats._mannwhitneyu.threading

# Computes the Multiscale Graph Correlation (MGC) test statistic.
scipy.stats._mgc.multiscale_graphcorr

# Anderson-Darling test for data coming from a particular distribution.
scipy.stats._morestats.anderson

# The Anderson-Darling test for k-samples.
scipy.stats._morestats.anderson_ksamp

# Perform the Ansari-Bradley test for equal scale parameters.
scipy.stats._morestats.ansari

# Perform Bartlett's test for equal variances.
scipy.stats._morestats.bartlett

# Bayesian confidence intervals for the mean, var, and std.
scipy.stats._morestats.bayes_mvs

# Return a dataset transformed by a Box-Cox power transformation.
scipy.stats._morestats.boxcox

# The boxcox log-likelihood function.
scipy.stats._morestats.boxcox_llf

# Compute optimal Box-Cox transform parameter for input data.
scipy.stats._morestats.boxcox_normmax

# Compute parameters for a Box-Cox normality plot, optionally show it.
scipy.stats._morestats.boxcox_normplot

# Compute the circular mean of a sample of angle observations.
scipy.stats._morestats.circmean

# Compute the circular standard deviation of a sample of angle observations.
scipy.stats._morestats.circstd

# Compute the circular variance of a sample of angle observations.
scipy.stats._morestats.circvar

# Computes sample statistics for directional data.
scipy.stats._morestats.directional_stats

# Adjust p-values to control the false discovery rate.
scipy.stats._morestats.false_discovery_control

# Perform Fligner-Killeen test for equality of variance.
scipy.stats._morestats.fligner

# Return the `n` th k-statistic ( ``1<=n<=4`` so far).
scipy.stats._morestats.kstat

# Return an unbiased estimator of the variance of the k-statistic.
scipy.stats._morestats.kstatvar

# Perform Levene test for equal variances.
scipy.stats._morestats.levene

# Perform a Mood's median test.
scipy.stats._morestats.median_test

# Perform Mood's test for equal scale parameters.
scipy.stats._morestats.mood

# 'Frozen' distributions for mean, variance, and standard deviation of data.
scipy.stats._morestats.mvsdist

# Calculate the shape parameter that maximizes the PPCC.
scipy.stats._morestats.ppcc_max

# Calculate and optionally plot probability plot correlation coefficient.
scipy.stats._morestats.ppcc_plot

# Calculate quantiles for a probability plot, and optionally show the plot.
scipy.stats._morestats.probplot

# Perform the Shapiro-Wilk test for normality.
scipy.stats._morestats.shapiro

# Calculate the Wilcoxon signed-rank test.
scipy.stats._morestats.wilcoxon

# Return a dataset transformed by a Yeo-Johnson power transformation.
scipy.stats._morestats.yeojohnson

# The yeojohnson log-likelihood function.
scipy.stats._morestats.yeojohnson_llf

# Compute optimal Yeo-Johnson transform parameter.
scipy.stats._morestats.yeojohnson_normmax

# Compute parameters for a Yeo-Johnson normality plot, optionally show it.
scipy.stats._morestats.yeojohnson_normplot

# Constructs a 2D array from a group of sequences.
scipy.stats._mstats_basic.argstoarray

# Compute the Brunner-Munzel test on samples x and y.
scipy.stats._mstats_basic.brunnermunzel

# Counts the number of tied values.
scipy.stats._mstats_basic.count_tied_groups

# Computes several descriptive statistics of the passed array.
scipy.stats._mstats_basic.describe

# Performs a 1-way ANOVA, returning an F-value and probability given
scipy.stats._mstats_basic.f_oneway

# Find repeats in arr and return a tuple (repeats, repeat_count).
scipy.stats._mstats_basic.find_repeats

# Friedman Chi-Square is a non-parametric, one-way within-subjects ANOVA.
scipy.stats._mstats_basic.friedmanchisquare

# Computes Kendall's rank correlation tau on two variables *x* and *y*.
scipy.stats._mstats_basic.kendalltau

# Computes a multivariate Kendall's rank correlation tau, for seasonal data.
scipy.stats._mstats_basic.kendalltau_seasonal

# Compute the Kruskal-Wallis H-test for independent samples
scipy.stats._mstats_basic.kruskal

# Compute the Kruskal-Wallis H-test for independent samples
scipy.stats._mstats_basic.kruskalwallis

# Computes the Kolmogorov-Smirnov test on one sample of masked values.
scipy.stats._mstats_basic.ks_1samp

# Computes the Kolmogorov-Smirnov test on two samples.
scipy.stats._mstats_basic.ks_2samp

# Computes the Kolmogorov-Smirnov test on two samples.
scipy.stats._mstats_basic.ks_twosamp

# Parameters
scipy.stats._mstats_basic.kstest

# Computes the kurtosis (Fisher or Pearson) of a dataset.
scipy.stats._mstats_basic.kurtosis

# Tests whether a dataset has normal kurtosis
scipy.stats._mstats_basic.kurtosistest

# Calculate a linear least-squares regression for two sets of measurements.
scipy.stats._mstats_basic.linregress

# Computes the Mann-Whitney statistic
scipy.stats._mstats_basic.mannwhitneyu

# Returns plotting positions (or empirical percentile points) for the data.
scipy.stats._mstats_basic.meppf

# Returns an array of the modal (most common) value in the passed array.
scipy.stats._mstats_basic.mode

# Calculates the nth moment about the mean for a sample.
scipy.stats._mstats_basic.moment

# Computes empirical quantiles for a data array.
scipy.stats._mstats_basic.mquantiles

# Returns the sign of x, or 0 if x is masked.
scipy.stats._mstats_basic.msign

# Tests whether a sample differs from a normal distribution.
scipy.stats._mstats_basic.normaltest

# Computes a transform on input data (any number of columns).  Used to
scipy.stats._mstats_basic.obrientransform

# Pearson correlation coefficient and p-value for testing non-correlation.
scipy.stats._mstats_basic.pearsonr

# Returns plotting positions (or empirical percentile points) for the data.
scipy.stats._mstats_basic.plotting_positions

# Calculates a point biserial correlation coefficient and its p-value.
scipy.stats._mstats_basic.pointbiserialr

# Returns the rank (also known as order statistics) of each data point
scipy.stats._mstats_basic.rankdata

# Calculate the score at the given 'per' percentile of the
scipy.stats._mstats_basic.scoreatpercentile

# Calculates the standard error of the mean of the input array.
scipy.stats._mstats_basic.sem

# Computes seasonal Theil-Sen and Kendall slope estimators.
scipy.stats._mstats_basic.sen_seasonal_slopes

# Computes the Siegel estimator for a set of points (x, y).
scipy.stats._mstats_basic.siegelslopes

# Computes the skewness of a data set.
scipy.stats._mstats_basic.skew

# Tests whether the skew is different from the normal distribution.
scipy.stats._mstats_basic.skewtest

# Calculates a Spearman rank-order correlation coefficient and the p-value
scipy.stats._mstats_basic.spearmanr

# Computes the Theil-Sen estimator for a set of points (x, y).
scipy.stats._mstats_basic.theilslopes

# Compute the trimmed maximum
scipy.stats._mstats_basic.tmax

# Compute the trimmed mean.
scipy.stats._mstats_basic.tmean

# Compute the trimmed minimum
scipy.stats._mstats_basic.tmin

# Trims an array by masking the data outside some given limits.
scipy.stats._mstats_basic.trim

# Trims an array by masking the data outside some given limits.
scipy.stats._mstats_basic.trima

# Trims the smallest and largest data values.
scipy.stats._mstats_basic.trimboth

# Returns the trimmed mean of the data along the given axis.
scipy.stats._mstats_basic.trimmed_mean

# Returns the trimmed standard deviation of the data along the given axis.
scipy.stats._mstats_basic.trimmed_std

# Returns the standard error of the trimmed mean along the given axis.
scipy.stats._mstats_basic.trimmed_stde

# Returns the trimmed variance of the data along the given axis.
scipy.stats._mstats_basic.trimmed_var

# Trims an array by masking some proportion of the data on each end.
scipy.stats._mstats_basic.trimr

# Trims the data by masking values from one tail.
scipy.stats._mstats_basic.trimtail

# Compute the trimmed standard error of the mean.
scipy.stats._mstats_basic.tsem

# Calculates the T-test for the mean of ONE group of scores.
scipy.stats._mstats_basic.ttest_1samp

# Calculates the T-test for the means of TWO INDEPENDENT samples of scores.
scipy.stats._mstats_basic.ttest_ind

# Calculates the T-test for the mean of ONE group of scores.
scipy.stats._mstats_basic.ttest_onesamp

# Calculates the T-test on TWO RELATED samples of scores, a and b.
scipy.stats._mstats_basic.ttest_rel

# Compute the trimmed variance
scipy.stats._mstats_basic.tvar

# Compute the coefficient of variation.
scipy.stats._mstats_basic.variation

# Returns a Winsorized version of the input array.
scipy.stats._mstats_basic.winsorize

# Compares the medians from two independent groups along the given axis.
scipy.stats._mstats_extras.compare_medians_ms

# Returns the Harrell-Davis estimate of the median along the given axis.
scipy.stats._mstats_extras.hdmedian

# Computes quantile estimates with the Harrell-Davis method.
scipy.stats._mstats_extras.hdquantiles

# The standard error of the Harrell-Davis quantile estimates by jackknife.
scipy.stats._mstats_extras.hdquantiles_sd

# Returns an estimate of the lower and upper quartiles.
scipy.stats._mstats_extras.idealfourths

# Computes the alpha-level confidence interval for the median of the data.
scipy.stats._mstats_extras.median_cihs

# Returns the Maritz-Jarrett estimators of the standard error of selected
scipy.stats._mstats_extras.mjci

# Computes the alpha confidence interval for the selected quantiles of the
scipy.stats._mstats_extras.mquantiles_cimj

# Evaluates Rosenblatt's shifted histogram estimators for each data point.
scipy.stats._mstats_extras.rsh

# Selected confidence interval of the trimmed mean along the given axis.
scipy.stats._mstats_extras.trimmed_mean_ci

# Dunnett's test: multiple comparisons of means against a control group.
scipy.stats._multicomp.dunnett

# A Dirichlet random variable.
scipy.stats._multivariate.dirichlet

# A Dirichlet multinomial random variable.
scipy.stats._multivariate.dirichlet_multinomial

# An inverse Wishart random variable.
scipy.stats._multivariate.invwishart

# A matrix normal random variable.
scipy.stats._multivariate.matrix_normal

# A multinomial random variable.
scipy.stats._multivariate.multinomial

# A multivariate hypergeometric random variable.
scipy.stats._multivariate.multivariate_hypergeom

# A multivariate normal random variable.
scipy.stats._multivariate.multivariate_normal

# A multivariate t-distributed random variable.
scipy.stats._multivariate.multivariate_t

# Normal-inverse-gamma distribution.
scipy.stats._multivariate.normal_inverse_gamma

# An Orthogonal matrix (O(N)) random variable.
scipy.stats._multivariate.ortho_group

# A random correlation matrix.
scipy.stats._multivariate.random_correlation

# Contingency tables from independent samples with fixed marginal sums.
scipy.stats._multivariate.random_table

# A Special Orthogonal matrix (SO(N)) random variable.
scipy.stats._multivariate.special_ortho_group

# A vector-valued uniform direction.
scipy.stats._multivariate.uniform_direction

# A matrix-valued U(N) random variable.
scipy.stats._multivariate.unitary_group

# A von Mises-Fisher variable.
scipy.stats._multivariate.vonmises_fisher

# A Wishart random variable.
scipy.stats._multivariate.wishart

# Binomial distribution with prescribed success probability and number of trials
scipy.stats._new_distributions.Binomial

# Normal distribution with prescribed mean and standard deviation.
scipy.stats._new_distributions.Normal

# Uniform distribution.
scipy.stats._new_distributions.Uniform

# Class for confidence intervals.
scipy.stats._odds_ratio.ConfidenceInterval

# Result of `scipy.stats.contingency.odds_ratio`.  See the
scipy.stats._odds_ratio.OddsRatioResult

# Find a root of a function in a bracketing interval using Brent's method.
scipy.stats._odds_ratio.brentq

# A Fisher's noncentral hypergeometric discrete random variable.
scipy.stats._odds_ratio.nchypergeom_fisher

# ndtri(y, out=None)
scipy.stats._odds_ratio.ndtri

# NumPy
scipy.stats._odds_ratio.np

# Compute the odds ratio for a 2x2 contingency table.
scipy.stats._odds_ratio.odds_ratio

# PageTrendTestResult(statistic: float, pvalue: float, method: str)
scipy.stats._page_trend_test.PageTrendTestResult

# Add dunder methods based on the fields defined in the class.
scipy.stats._page_trend_test.dataclass

# This module provides access to the mathematical functions
scipy.stats._page_trend_test.math

# A normal continuous random variable.
scipy.stats._page_trend_test.norm

# NumPy
scipy.stats._page_trend_test.np

# Perform Page's Test, a measure of trend in observations between treatments.
scipy.stats._page_trend_test.page_trend_test

# Return successive r-length permutations of elements in the iterable.
scipy.stats._page_trend_test.permutations

# SciPy: A scientific computing package for Python
scipy.stats._page_trend_test.scipy

# Thread module emulating a subset of Java's threading model.
scipy.stats._page_trend_test.threading

# Helper class that provides a standard way to create an ABC using
scipy.stats._probability_distribution.ABC

# A decorator indicating abstract methods.
scipy.stats._probability_distribution.abstractmethod

# Halton sequence.
scipy.stats._qmc.Halton

# Latin hypercube sampling (LHS).
scipy.stats._qmc.LatinHypercube

# QMC sampling from a multinomial distribution.
scipy.stats._qmc.MultinomialQMC

# QMC sampling from a multivariate Normal :math:`N(\mu, \Sigma)`.
scipy.stats._qmc.MultivariateNormalQMC

# Poisson disk sampling.
scipy.stats._qmc.PoissonDisk

# A generic Quasi-Monte Carlo sampler class meant for subclassing.
scipy.stats._qmc.QMCEngine

# Engine for generating (scrambled) Sobol' sequences.
scipy.stats._qmc.Sobol

# Discrepancy of a given sample.
scipy.stats._qmc.discrepancy

# Discrepancy of a given sample based on its geometric properties.
scipy.stats._qmc.geometric_discrepancy

# Sample scaling from unit hypercube to different bounds.
scipy.stats._qmc.scale

# Update the centered discrepancy with a new sample.
scipy.stats._qmc.update_discrepancy

# NumPy
scipy.stats._qmc_cy.np

# Compute the 1-D discrete Fourier Transform.
scipy.stats._qmvnt.fft

# Compute the 1-D inverse discrete Fourier Transform.
scipy.stats._qmvnt.ifft

# NumPy
scipy.stats._qmvnt.np

# ndtr(x, out=None)
scipy.stats._qmvnt.phi

# ndtri(y, out=None)
scipy.stats._qmvnt.phinv

# Prime numbers from 2 to *n*.
scipy.stats._qmvnt.primes_from_2_to

# gammaincinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._qmvnt_cy.gammaincinv

# NumPy
scipy.stats._qmvnt_cy.np

# Get the array API compatible namespace for the arrays xs.
scipy.stats._quantile.array_namespace

# betainc(a, b, x, out=None)
scipy.stats._quantile.betainc

# NumPy
scipy.stats._quantile.np

# Compute the p-th quantile of the data along the specified axis.
scipy.stats._quantile.quantile

# Promotes elements of *args to result dtype, ignoring `None`s.
scipy.stats._quantile.xp_promote

scipy.stats._quantile.xp_ravel

# Extra array functions built on top of the array API standard.
scipy.stats._quantile.xpx

# NumPy
scipy.stats._rcont.rcont.np

scipy.stats._rcont.rcont.rvs_rcont1

scipy.stats._rcont.rcont.rvs_rcont2

# Class for confidence intervals.
scipy.stats._relative_risk.ConfidenceInterval

# Result of `scipy.stats.contingency.relative_risk`.
scipy.stats._relative_risk.RelativeRiskResult

# Add dunder methods based on the fields defined in the class.
scipy.stats._relative_risk.dataclass

# ndtri(y, out=None)
scipy.stats._relative_risk.ndtri

# NumPy
scipy.stats._relative_risk.np

# Operator interface.
scipy.stats._relative_risk.operator

# Compute the relative risk (also known as the risk ratio).
scipy.stats._relative_risk.relative_risk

# Compute a two-sided bootstrap confidence interval of a statistic.
scipy.stats._resampling.bootstrap

# Perform a Monte Carlo hypothesis test.
scipy.stats._resampling.monte_carlo_test

# Performs a permutation test of a given statistic on provided data.
scipy.stats._resampling.permutation_test

# Result of `scipy.stats.binomtest`.
scipy.stats._result_classes.BinomTestResult

# Result object returned by `scipy.stats.dunnett`.
scipy.stats._result_classes.DunnettResult

# Result object returned by `scipy.stats.ecdf`
scipy.stats._result_classes.ECDFResult

# An empirical distribution function produced by `scipy.stats.ecdf`
scipy.stats._result_classes.EmpiricalDistributionFunction

# Result of fitting a discrete or continuous distribution to data
scipy.stats._result_classes.FitResult

# Result of `scipy.stats.contingency.odds_ratio`.  See the
scipy.stats._result_classes.OddsRatioResult

# Result of `scipy.stats.pearsonr`
scipy.stats._result_classes.PearsonRResult

# Result of `scipy.stats.contingency.relative_risk`.
scipy.stats._result_classes.RelativeRiskResult

# Result of a t-test.
scipy.stats._result_classes.TtestResult

# Result of `scipy.stats.tukey_hsd`.
scipy.stats._result_classes.TukeyHSDResult

# Fast sampling by numerical inversion of the CDF for a large class of
scipy.stats._sampling.FastGeneratorInversion

# Generate random samples from a probability density function using the
scipy.stats._sampling.RatioUniforms

# Global sensitivity indices of Sobol'.
scipy.stats._sensitivity_analysis.sobol_indices

# Initialize and cache the direction numbers.
scipy.stats._sobol.get_poly_vinit

# A pure Python implementation of import.
scipy.stats._sobol.importlib

# NumPy
scipy.stats._sobol.np

# Evaluate a multivariate Gaussian kernel estimate.
scipy.stats._stats.gaussian_kernel_estimate

# def gaussian_kernel_estimate_log(points, real[:, :] values, xi, cho_cov)
scipy.stats._stats.gaussian_kernel_estimate_log

scipy.stats._stats.genhyperbolic_logpdf

scipy.stats._stats.genhyperbolic_pdf

scipy.stats._stats.geninvgauss_logpdf

# NumPy
scipy.stats._stats.np

# SciPy: A scientific computing package for Python
scipy.stats._stats.scipy

# Solve the equation ``a @ x = b`` for ``x``, where `a` is a triangular matrix.
scipy.stats._stats.solve_triangular

scipy.stats._stats.von_mises_cdf

# Python part of the warnings subsystem.
scipy.stats._stats.warnings

scipy.stats._stats_mstats_common._find_repeats

# Computes the Siegel estimator for a set of points (x, y).
scipy.stats._stats_mstats_common.siegelslopes

# Computes the Theil-Sen estimator for a set of points (x, y).
scipy.stats._stats_mstats_common.theilslopes

# Performs the Alexander Govern test.
scipy.stats._stats_py.alexandergovern

# Compute the Brunner-Munzel test on samples x and y.
scipy.stats._stats_py.brunnermunzel

# Perform Pearson's chi-squared test.
scipy.stats._stats_py.chisquare

# Combine p-values from independent tests that bear upon the same hypothesis.
scipy.stats._stats_py.combine_pvalues

# Return a cumulative frequency histogram, using the histogram function.
scipy.stats._stats_py.cumfreq

# Compute several descriptive statistics of the passed array.
scipy.stats._stats_py.describe

# Compute the energy distance between two 1D distributions.
scipy.stats._stats_py.energy_distance

# Compute the expectile at the specified level.
scipy.stats._stats_py.expectile

# Perform one-way ANOVA.
scipy.stats._stats_py.f_oneway

# Find repeats and repeat counts.
scipy.stats._stats_py.find_repeats

# Perform a Fisher exact test on a contingency table.
scipy.stats._stats_py.fisher_exact

# Compute the Friedman test for repeated samples.
scipy.stats._stats_py.friedmanchisquare

# Compute the weighted geometric mean along the specified axis.
scipy.stats._stats_py.gmean

# Calculate the geometric standard deviation of an array.
scipy.stats._stats_py.gstd

# Compute the geometric standard score.
scipy.stats._stats_py.gzscore

# Calculate the weighted harmonic mean along the specified axis.
scipy.stats._stats_py.hmean

# Compute the interquartile range of the data along the specified axis.
scipy.stats._stats_py.iqr

# Perform the Jarque-Bera goodness of fit test on sample data.
scipy.stats._stats_py.jarque_bera

# Calculate Kendall's tau, a correlation measure for ordinal data.
scipy.stats._stats_py.kendalltau

# Compute the Kruskal-Wallis H-test for independent samples.
scipy.stats._stats_py.kruskal

# Performs the one-sample Kolmogorov-Smirnov test for goodness of fit.
scipy.stats._stats_py.ks_1samp

# Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.
scipy.stats._stats_py.ks_2samp

# Performs the (one-sample or two-sample) Kolmogorov-Smirnov test for
scipy.stats._stats_py.kstest

# Compute the kurtosis (Fisher or Pearson) of a dataset.
scipy.stats._stats_py.kurtosis

# Test whether a dataset has normal kurtosis.
scipy.stats._stats_py.kurtosistest

# Calculate a linear least-squares regression for two sets of measurements.
scipy.stats._stats_py.linregress

# Compute L-moments of a sample from a continuous distribution
scipy.stats._stats_py.lmoment

# Compute the median absolute deviation of the data along the given axis.
scipy.stats._stats_py.median_abs_deviation

# Return an array of the modal (most common) value in the passed array.
scipy.stats._stats_py.mode

# Calculate the nth moment about the mean for a sample.
scipy.stats._stats_py.moment

# Test whether a sample differs from a normal distribution.
scipy.stats._stats_py.normaltest

# Compute the O'Brien transform on input data (any number of arrays).
scipy.stats._stats_py.obrientransform

# Pearson correlation coefficient and p-value for testing non-correlation.
scipy.stats._stats_py.pearsonr

# Compute the percentile rank of a score relative to a list of scores.
scipy.stats._stats_py.percentileofscore

# Calculate the weighted power mean along the specified axis.
scipy.stats._stats_py.pmean

# Calculate a point biserial correlation coefficient and its p-value.
scipy.stats._stats_py.pointbiserialr

# Cressie-Read power divergence statistic and goodness of fit test.
scipy.stats._stats_py.power_divergence

# Perform a quantile test and compute a confidence interval of the quantile.
scipy.stats._stats_py.quantile_test

# Assign ranks to data, dealing with ties appropriately.
scipy.stats._stats_py.rankdata

# Compute the Wilcoxon rank-sum statistic for two samples.
scipy.stats._stats_py.ranksums

# Return a relative frequency histogram, using the histogram function.
scipy.stats._stats_py.relfreq

# Calculate the score at a given percentile of the input sequence.
scipy.stats._stats_py.scoreatpercentile

# Compute standard error of the mean.
scipy.stats._stats_py.sem

# Computes the Siegel estimator for a set of points (x, y).
scipy.stats._stats_py.siegelslopes

# Perform iterative sigma-clipping of array elements.
scipy.stats._stats_py.sigmaclip

# Compute the sample skewness of a data set.
scipy.stats._stats_py.skew

# Test whether the skew is different from the normal distribution.
scipy.stats._stats_py.skewtest

# Calculate a Spearman correlation coefficient with associated p-value.
scipy.stats._stats_py.spearmanr

# Computes the Theil-Sen estimator for a set of points (x, y).
scipy.stats._stats_py.theilslopes

# Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests.
scipy.stats._stats_py.tiecorrect

# Compute the trimmed maximum.
scipy.stats._stats_py.tmax

# Compute the trimmed mean.
scipy.stats._stats_py.tmean

# Compute the trimmed minimum.
scipy.stats._stats_py.tmin

# Slice off a proportion from ONE end of the passed array distribution.
scipy.stats._stats_py.trim1

# Return mean of array after trimming a specified fraction of extreme values
scipy.stats._stats_py.trim_mean

# Slice off a proportion of items from both ends of an array.
scipy.stats._stats_py.trimboth

# Compute the trimmed standard error of the mean.
scipy.stats._stats_py.tsem

# Compute the trimmed sample standard deviation.
scipy.stats._stats_py.tstd

# Calculate the T-test for the mean of ONE group of scores.
scipy.stats._stats_py.ttest_1samp

# Calculate the T-test for the means of *two independent* samples of scores.
scipy.stats._stats_py.ttest_ind

# T-test for means of two independent samples from descriptive statistics.
scipy.stats._stats_py.ttest_ind_from_stats

# Calculate the t-test on TWO RELATED samples of scores, a and b.
scipy.stats._stats_py.ttest_rel

# Compute the trimmed variance.
scipy.stats._stats_py.tvar

# Compute the Wasserstein-1 distance between two 1D discrete distributions.
scipy.stats._stats_py.wasserstein_distance

# Compute the Wasserstein-1 distance between two N-D discrete distributions.
scipy.stats._stats_py.wasserstein_distance_nd

# Compute a weighted version of Kendall's :math:`\tau`.
scipy.stats._stats_py.weightedtau

# Calculate the relative z-scores.
scipy.stats._stats_py.zmap

# Compute the z score.
scipy.stats._stats_py.zscore

# Supported prototypes:
scipy.stats._stats_pythran.siegelslopes

# Empirical cumulative distribution function of a sample.
scipy.stats._survival.ecdf

# Compare the survival distributions of two samples via the logrank test.
scipy.stats._survival.logrank

# beta(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
scipy.stats._tukeylambda_stats.beta

# NumPy
scipy.stats._tukeylambda_stats.np

# A one-dimensional polynomial class.
scipy.stats._tukeylambda_stats.poly1d

# Kurtosis of the Tukey Lambda distribution.
scipy.stats._tukeylambda_stats.tukeylambda_kurtosis

# Variance of the Tukey Lambda distribution.
scipy.stats._tukeylambda_stats.tukeylambda_variance

# DiscreteAliasUrn(dist, *, domain=None, urn_factor=1, random_state=None)
scipy.stats._unuran.unuran_wrapper.DiscreteAliasUrn

# NumericalInversePolynomial(dist, *, mode=None, center=None, domain=None, order=5, u_resolution=1e-10, random_state=None)
scipy.stats._unuran.unuran_wrapper.NumericalInversePolynomial

# TransformedDensityRejection(dist, *, mode=None, center=None, domain=None, c=-0.5, construction_points=30, use_dars=True, max_squeeze_hat_ratio=0.99, random_state=None)
scipy.stats._unuran.unuran_wrapper.TransformedDensityRejection

# Raised when an error occurs in the UNU.RAN library.
scipy.stats._unuran.unuran_wrapper.UNURANError

# Get the array API compatible namespace for the arrays xs.
scipy.stats._variation.array_namespace

# NumPy
scipy.stats._variation.np

# Compute the coefficient of variation.
scipy.stats._variation.variation

# Warns when all values in data are exactly equal.
scipy.stats._warnings_errors.ConstantInputWarning

# Warns when data is degenerate and results may not be reliable.
scipy.stats._warnings_errors.DegenerateDataWarning

# Represents an error condition when fitting a distribution to data.
scipy.stats._warnings_errors.FitError

# Warns when all values in data are nearly equal.
scipy.stats._warnings_errors.NearConstantInputWarning

scipy.stats._wilcoxon.WilcoxonDistribution

# NumPy
scipy.stats._wilcoxon.np

# .. _statsrefmanual:
scipy.stats._wilcoxon.stats

# Extra array functions built on top of the array API standard.
scipy.stats._wilcoxon.xpx

# Calculates degree of association between two nominal variables.
scipy.stats.contingency.association

# Chi-square test of independence of variables in a contingency table.
scipy.stats.contingency.chi2_contingency

# Return table of counts for each possible unique combination in ``*args``.
scipy.stats.contingency.crosstab

# Compute the expected frequencies from a contingency table.
scipy.stats.contingency.expected_freq

# Return a list of the marginal sums of the array `a`.
scipy.stats.contingency.margins

# Compute the odds ratio for a 2x2 contingency table.
scipy.stats.contingency.odds_ratio

# Compute the relative risk (also known as the risk ratio).
scipy.stats.contingency.relative_risk

# An alpha continuous random variable.
scipy.stats.distributions.alpha

# An anglit continuous random variable.
scipy.stats.distributions.anglit

# An arcsine continuous random variable.
scipy.stats.distributions.arcsine

# Argus distribution
scipy.stats.distributions.argus

# A Bernoulli discrete random variable.
scipy.stats.distributions.bernoulli

# A beta continuous random variable.
scipy.stats.distributions.beta

# A beta-binomial discrete random variable.
scipy.stats.distributions.betabinom

# A beta-negative-binomial discrete random variable.
scipy.stats.distributions.betanbinom

# A beta prime continuous random variable.
scipy.stats.distributions.betaprime

# A binomial discrete random variable.
scipy.stats.distributions.binom

# A Boltzmann (Truncated Discrete Exponential) random variable.
scipy.stats.distributions.boltzmann

# A Bradford continuous random variable.
scipy.stats.distributions.bradford

# A Burr (Type III) continuous random variable.
scipy.stats.distributions.burr

# A Burr (Type XII) continuous random variable.
scipy.stats.distributions.burr12

# A Cauchy continuous random variable.
scipy.stats.distributions.cauchy

# A chi continuous random variable.
scipy.stats.distributions.chi

# A chi-squared continuous random variable.
scipy.stats.distributions.chi2

# A cosine continuous random variable.
scipy.stats.distributions.cosine

# Crystalball distribution
scipy.stats.distributions.crystalball

# A double gamma continuous random variable.
scipy.stats.distributions.dgamma

# A  Laplacian discrete random variable.
scipy.stats.distributions.dlaplace

# A double Pareto lognormal continuous random variable.
scipy.stats.distributions.dpareto_lognorm

# A double Weibull continuous random variable.
scipy.stats.distributions.dweibull

# Calculate the Shannon entropy/relative entropy of given distribution(s).
scipy.stats.distributions.entropy

# An Erlang continuous random variable.
scipy.stats.distributions.erlang

# An exponential continuous random variable.
scipy.stats.distributions.expon

# An exponentially modified Normal continuous random variable.
scipy.stats.distributions.exponnorm

# An exponential power continuous random variable.
scipy.stats.distributions.exponpow

# An exponentiated Weibull continuous random variable.
scipy.stats.distributions.exponweib

# An F continuous random variable.
scipy.stats.distributions.f

# A fatigue-life (Birnbaum-Saunders) continuous random variable.
scipy.stats.distributions.fatiguelife

# A Fisk continuous random variable.
scipy.stats.distributions.fisk

# A folded Cauchy continuous random variable.
scipy.stats.distributions.foldcauchy

# A folded normal continuous random variable.
scipy.stats.distributions.foldnorm

# A gamma continuous random variable.
scipy.stats.distributions.gamma

# A Gauss hypergeometric continuous random variable.
scipy.stats.distributions.gausshyper

# A generalized exponential continuous random variable.
scipy.stats.distributions.genexpon

# A generalized extreme value continuous random variable.
scipy.stats.distributions.genextreme

# A generalized gamma continuous random variable.
scipy.stats.distributions.gengamma

# A generalized half-logistic continuous random variable.
scipy.stats.distributions.genhalflogistic

# A generalized hyperbolic continuous random variable.
scipy.stats.distributions.genhyperbolic

# A Generalized Inverse Gaussian continuous random variable.
scipy.stats.distributions.geninvgauss

# A generalized logistic continuous random variable.
scipy.stats.distributions.genlogistic

# A generalized normal continuous random variable.
scipy.stats.distributions.gennorm

# A generalized Pareto continuous random variable.
scipy.stats.distributions.genpareto

# A geometric discrete random variable.
scipy.stats.distributions.geom

# A Gibrat continuous random variable.
scipy.stats.distributions.gibrat

# A Gompertz (or truncated Gumbel) continuous random variable.
scipy.stats.distributions.gompertz

# A left-skewed Gumbel continuous random variable.
scipy.stats.distributions.gumbel_l

# A right-skewed Gumbel continuous random variable.
scipy.stats.distributions.gumbel_r

# A Half-Cauchy continuous random variable.
scipy.stats.distributions.halfcauchy

# The upper half of a generalized normal continuous random variable.
scipy.stats.distributions.halfgennorm

# A half-logistic continuous random variable.
scipy.stats.distributions.halflogistic

# A half-normal continuous random variable.
scipy.stats.distributions.halfnorm

# A hypergeometric discrete random variable.
scipy.stats.distributions.hypergeom

# A hyperbolic secant continuous random variable.
scipy.stats.distributions.hypsecant

# An inverted gamma continuous random variable.
scipy.stats.distributions.invgamma

# An inverse Gaussian continuous random variable.
scipy.stats.distributions.invgauss

# An inverted Weibull continuous random variable.
scipy.stats.distributions.invweibull

# An Irwin-Hall (Uniform Sum) continuous random variable.
scipy.stats.distributions.irwinhall

# Jones and Faddy skew-t distribution.
scipy.stats.distributions.jf_skew_t

# A Johnson SB continuous random variable.
scipy.stats.distributions.johnsonsb

# A Johnson SU continuous random variable.
scipy.stats.distributions.johnsonsu

# Kappa 3 parameter distribution.
scipy.stats.distributions.kappa3

# Kappa 4 parameter distribution.
scipy.stats.distributions.kappa4

# Kolmogorov-Smirnov one-sided test statistic distribution.
scipy.stats.distributions.ksone

# Kolmogorov-Smirnov two-sided test statistic distribution.
scipy.stats.distributions.kstwo

# Limiting distribution of scaled Kolmogorov-Smirnov two-sided test statistic.
scipy.stats.distributions.kstwobign

# A Landau continuous random variable.
scipy.stats.distributions.landau

# A Laplace continuous random variable.
scipy.stats.distributions.laplace

# An asymmetric Laplace continuous random variable.
scipy.stats.distributions.laplace_asymmetric

# A Levy continuous random variable.
scipy.stats.distributions.levy

# A left-skewed Levy continuous random variable.
scipy.stats.distributions.levy_l

# A Levy-stable continuous random variable.
scipy.stats.distributions.levy_stable

# A log gamma continuous random variable.
scipy.stats.distributions.loggamma

# A logistic (or Sech-squared) continuous random variable.
scipy.stats.distributions.logistic

# A log-Laplace continuous random variable.
scipy.stats.distributions.loglaplace

# A lognormal continuous random variable.
scipy.stats.distributions.lognorm

# A Logarithmic (Log-Series, Series) discrete random variable.
scipy.stats.distributions.logser

# A loguniform or reciprocal continuous random variable.
scipy.stats.distributions.loguniform

# A Lomax (Pareto of the second kind) continuous random variable.
scipy.stats.distributions.lomax

# A Maxwell continuous random variable.
scipy.stats.distributions.maxwell

# A Mielke Beta-Kappa / Dagum continuous random variable.
scipy.stats.distributions.mielke

# A Moyal continuous random variable.
scipy.stats.distributions.moyal

# A Nakagami continuous random variable.
scipy.stats.distributions.nakagami

# A negative binomial discrete random variable.
scipy.stats.distributions.nbinom

# A non-central F distribution continuous random variable.
scipy.stats.distributions.ncf

# A Fisher's noncentral hypergeometric discrete random variable.
scipy.stats.distributions.nchypergeom_fisher

# A Wallenius' noncentral hypergeometric discrete random variable.
scipy.stats.distributions.nchypergeom_wallenius

# A non-central Student's t continuous random variable.
scipy.stats.distributions.nct

# A non-central chi-squared continuous random variable.
scipy.stats.distributions.ncx2

# A negative hypergeometric discrete random variable.
scipy.stats.distributions.nhypergeom

# A normal continuous random variable.
scipy.stats.distributions.norm

# A Normal Inverse Gaussian continuous random variable.
scipy.stats.distributions.norminvgauss

# A Pareto continuous random variable.
scipy.stats.distributions.pareto

# A pearson type III continuous random variable.
scipy.stats.distributions.pearson3

# A Planck discrete exponential random variable.
scipy.stats.distributions.planck

# A Poisson discrete random variable.
scipy.stats.distributions.poisson

# A Poisson Binomial discrete random variable.
scipy.stats.distributions.poisson_binom

# A power-function continuous random variable.
scipy.stats.distributions.powerlaw

# A power log-normal continuous random variable.
scipy.stats.distributions.powerlognorm

# A power normal continuous random variable.
scipy.stats.distributions.powernorm

# A uniform discrete random variable.
scipy.stats.distributions.randint

# A Rayleigh continuous random variable.
scipy.stats.distributions.rayleigh

# An R-distributed (symmetric beta) continuous random variable.
scipy.stats.distributions.rdist

# A reciprocal inverse Gaussian continuous random variable.
scipy.stats.distributions.recipinvgauss

# A loguniform or reciprocal continuous random variable.
scipy.stats.distributions.reciprocal

# A relativistic Breit-Wigner random variable.
scipy.stats.distributions.rel_breitwigner

# A Rice continuous random variable.
scipy.stats.distributions.rice

# A generic continuous random variable class meant for subclassing.
scipy.stats.distributions.rv_continuous

# A generic discrete random variable class meant for subclassing.
scipy.stats.distributions.rv_discrete

# Generates a distribution given by a histogram.
scipy.stats.distributions.rv_histogram

# A semicircular continuous random variable.
scipy.stats.distributions.semicircular

# A  Skellam discrete random variable.
scipy.stats.distributions.skellam

# A skewed Cauchy random variable.
scipy.stats.distributions.skewcauchy

# A skew-normal random variable.
scipy.stats.distributions.skewnorm

# A studentized range continuous random variable.
scipy.stats.distributions.studentized_range

# A Student's t continuous random variable.
scipy.stats.distributions.t

# A trapezoidal continuous random variable.
scipy.stats.distributions.trapezoid

# A triangular continuous random variable.
scipy.stats.distributions.triang

# A truncated exponential continuous random variable.
scipy.stats.distributions.truncexpon

# A truncated normal continuous random variable.
scipy.stats.distributions.truncnorm

# An upper truncated Pareto continuous random variable.
scipy.stats.distributions.truncpareto

# A doubly truncated Weibull minimum continuous random variable.
scipy.stats.distributions.truncweibull_min

# A Tukey-Lamdba continuous random variable.
scipy.stats.distributions.tukeylambda

# A uniform continuous random variable.
scipy.stats.distributions.uniform

# A Von Mises continuous random variable.
scipy.stats.distributions.vonmises

# A Von Mises continuous random variable.
scipy.stats.distributions.vonmises_line

# A Wald continuous random variable.
scipy.stats.distributions.wald

# Weibull maximum continuous random variable.
scipy.stats.distributions.weibull_max

# Weibull minimum continuous random variable.
scipy.stats.distributions.weibull_min

# A wrapped Cauchy continuous random variable.
scipy.stats.distributions.wrapcauchy

# A Yule-Simon discrete random variable.
scipy.stats.distributions.yulesimon

# A Zipf (Zeta) discrete random variable.
scipy.stats.distributions.zipf

# A Zipfian discrete random variable.
scipy.stats.distributions.zipfian

# Representation of a kernel-density estimate using Gaussian kernels.
scipy.stats.kde.gaussian_kde

# Anderson-Darling test for data coming from a particular distribution.
scipy.stats.morestats.anderson

# The Anderson-Darling test for k-samples.
scipy.stats.morestats.anderson_ksamp

# Perform the Ansari-Bradley test for equal scale parameters.
scipy.stats.morestats.ansari

# Perform Bartlett's test for equal variances.
scipy.stats.morestats.bartlett

# Bayesian confidence intervals for the mean, var, and std.
scipy.stats.morestats.bayes_mvs

# Return a dataset transformed by a Box-Cox power transformation.
scipy.stats.morestats.boxcox

# The boxcox log-likelihood function.
scipy.stats.morestats.boxcox_llf

# Compute optimal Box-Cox transform parameter for input data.
scipy.stats.morestats.boxcox_normmax

# Compute parameters for a Box-Cox normality plot, optionally show it.
scipy.stats.morestats.boxcox_normplot

# Chi-square test of independence of variables in a contingency table.
scipy.stats.morestats.chi2_contingency

# Compute the circular mean of a sample of angle observations.
scipy.stats.morestats.circmean

# Compute the circular standard deviation of a sample of angle observations.
scipy.stats.morestats.circstd

# Compute the circular variance of a sample of angle observations.
scipy.stats.morestats.circvar

scipy.stats.morestats.distributions

# Find repeats and repeat counts.
scipy.stats.morestats.find_repeats

# Perform Fligner-Killeen test for equality of variance.
scipy.stats.morestats.fligner

# Return the `n` th k-statistic ( ``1<=n<=4`` so far).
scipy.stats.morestats.kstat

# Return an unbiased estimator of the variance of the k-statistic.
scipy.stats.morestats.kstatvar

# Perform Levene test for equal variances.
scipy.stats.morestats.levene

# Perform a Mood's median test.
scipy.stats.morestats.median_test

# Perform Mood's test for equal scale parameters.
scipy.stats.morestats.mood

# 'Frozen' distributions for mean, variance, and standard deviation of data.
scipy.stats.morestats.mvsdist

# Calculate the shape parameter that maximizes the PPCC.
scipy.stats.morestats.ppcc_max

# Calculate and optionally plot probability plot correlation coefficient.
scipy.stats.morestats.ppcc_plot

# Calculate quantiles for a probability plot, and optionally show the plot.
scipy.stats.morestats.probplot

# Perform the Shapiro-Wilk test for normality.
scipy.stats.morestats.shapiro

# Calculate the Wilcoxon signed-rank test.
scipy.stats.morestats.wilcoxon

# Return a dataset transformed by a Yeo-Johnson power transformation.
scipy.stats.morestats.yeojohnson

# The yeojohnson log-likelihood function.
scipy.stats.morestats.yeojohnson_llf

# Compute optimal Yeo-Johnson transform parameter.
scipy.stats.morestats.yeojohnson_normmax

# Compute parameters for a Yeo-Johnson normality plot, optionally show it.
scipy.stats.morestats.yeojohnson_normplot

# Constructs a 2D array from a group of sequences.
scipy.stats.mstats.argstoarray

# Compute the Brunner-Munzel test on samples x and y.
scipy.stats.mstats.brunnermunzel

# Perform Pearson's chi-squared test.
scipy.stats.mstats.chisquare

# Compares the medians from two independent groups along the given axis.
scipy.stats.mstats.compare_medians_ms

# Counts the number of tied values.
scipy.stats.mstats.count_tied_groups

# Computes several descriptive statistics of the passed array.
scipy.stats.mstats.describe

# Performs a 1-way ANOVA, returning an F-value and probability given
scipy.stats.mstats.f_oneway

# Find repeats in arr and return a tuple (repeats, repeat_count).
scipy.stats.mstats.find_repeats

# Friedman Chi-Square is a non-parametric, one-way within-subjects ANOVA.
scipy.stats.mstats.friedmanchisquare

# Compute the weighted geometric mean along the specified axis.
scipy.stats.mstats.gmean

# Returns the Harrell-Davis estimate of the median along the given axis.
scipy.stats.mstats.hdmedian

# Computes quantile estimates with the Harrell-Davis method.
scipy.stats.mstats.hdquantiles

# The standard error of the Harrell-Davis quantile estimates by jackknife.
scipy.stats.mstats.hdquantiles_sd

# Calculate the weighted harmonic mean along the specified axis.
scipy.stats.mstats.hmean

# Returns an estimate of the lower and upper quartiles.
scipy.stats.mstats.idealfourths

# Computes Kendall's rank correlation tau on two variables *x* and *y*.
scipy.stats.mstats.kendalltau

# Computes a multivariate Kendall's rank correlation tau, for seasonal data.
scipy.stats.mstats.kendalltau_seasonal

# Compute the Kruskal-Wallis H-test for independent samples
scipy.stats.mstats.kruskal

# Compute the Kruskal-Wallis H-test for independent samples
scipy.stats.mstats.kruskalwallis

# Computes the Kolmogorov-Smirnov test on one sample of masked values.
scipy.stats.mstats.ks_1samp

# Computes the Kolmogorov-Smirnov test on two samples.
scipy.stats.mstats.ks_2samp

# Computes the Kolmogorov-Smirnov test on two samples.
scipy.stats.mstats.ks_twosamp

# Parameters
scipy.stats.mstats.kstest

# Computes the kurtosis (Fisher or Pearson) of a dataset.
scipy.stats.mstats.kurtosis

# Tests whether a dataset has normal kurtosis
scipy.stats.mstats.kurtosistest

# Calculate a linear least-squares regression for two sets of measurements.
scipy.stats.mstats.linregress

# Computes the Mann-Whitney statistic
scipy.stats.mstats.mannwhitneyu

# Computes the alpha-level confidence interval for the median of the data.
scipy.stats.mstats.median_cihs

# Returns plotting positions (or empirical percentile points) for the data.
scipy.stats.mstats.meppf

# Returns the Maritz-Jarrett estimators of the standard error of selected
scipy.stats.mstats.mjci

# Returns an array of the modal (most common) value in the passed array.
scipy.stats.mstats.mode

# Calculates the nth moment about the mean for a sample.
scipy.stats.mstats.moment

# Computes empirical quantiles for a data array.
scipy.stats.mstats.mquantiles

# Computes the alpha confidence interval for the selected quantiles of the
scipy.stats.mstats.mquantiles_cimj

# Returns the sign of x, or 0 if x is masked.
scipy.stats.mstats.msign

# Tests whether a sample differs from a normal distribution.
scipy.stats.mstats.normaltest

# Computes a transform on input data (any number of columns).  Used to
scipy.stats.mstats.obrientransform

# Pearson correlation coefficient and p-value for testing non-correlation.
scipy.stats.mstats.pearsonr

# Returns plotting positions (or empirical percentile points) for the data.
scipy.stats.mstats.plotting_positions

# Calculates a point biserial correlation coefficient and its p-value.
scipy.stats.mstats.pointbiserialr

# Returns the rank (also known as order statistics) of each data point
scipy.stats.mstats.rankdata

# Evaluates Rosenblatt's shifted histogram estimators for each data point.
scipy.stats.mstats.rsh

# Calculate the score at the given 'per' percentile of the
scipy.stats.mstats.scoreatpercentile

# Calculates the standard error of the mean of the input array.
scipy.stats.mstats.sem

# Computes seasonal Theil-Sen and Kendall slope estimators.
scipy.stats.mstats.sen_seasonal_slopes

# Computes the Siegel estimator for a set of points (x, y).
scipy.stats.mstats.siegelslopes

# Computes the skewness of a data set.
scipy.stats.mstats.skew

# Tests whether the skew is different from the normal distribution.
scipy.stats.mstats.skewtest

# Calculates a Spearman rank-order correlation coefficient and the p-value
scipy.stats.mstats.spearmanr

# Computes the Theil-Sen estimator for a set of points (x, y).
scipy.stats.mstats.theilslopes

# Compute the trimmed maximum
scipy.stats.mstats.tmax

# Compute the trimmed mean.
scipy.stats.mstats.tmean

# Compute the trimmed minimum
scipy.stats.mstats.tmin

# Trims an array by masking the data outside some given limits.
scipy.stats.mstats.trim

# Trims an array by masking the data outside some given limits.
scipy.stats.mstats.trima

# Trims the smallest and largest data values.
scipy.stats.mstats.trimboth

# Returns the trimmed mean of the data along the given axis.
scipy.stats.mstats.trimmed_mean

# Selected confidence interval of the trimmed mean along the given axis.
scipy.stats.mstats.trimmed_mean_ci

# Returns the trimmed standard deviation of the data along the given axis.
scipy.stats.mstats.trimmed_std

# Returns the standard error of the trimmed mean along the given axis.
scipy.stats.mstats.trimmed_stde

# Returns the trimmed variance of the data along the given axis.
scipy.stats.mstats.trimmed_var

# Trims an array by masking some proportion of the data on each end.
scipy.stats.mstats.trimr

# Trims the data by masking values from one tail.
scipy.stats.mstats.trimtail

# Compute the trimmed standard error of the mean.
scipy.stats.mstats.tsem

# Calculates the T-test for the mean of ONE group of scores.
scipy.stats.mstats.ttest_1samp

# Calculates the T-test for the means of TWO INDEPENDENT samples of scores.
scipy.stats.mstats.ttest_ind

# Calculates the T-test for the mean of ONE group of scores.
scipy.stats.mstats.ttest_onesamp

# Calculates the T-test on TWO RELATED samples of scores, a and b.
scipy.stats.mstats.ttest_rel

# Compute the trimmed variance
scipy.stats.mstats.tvar

# Compute the coefficient of variation.
scipy.stats.mstats.variation

# Returns a Winsorized version of the input array.
scipy.stats.mstats.winsorize

# Calculate the relative z-scores.
scipy.stats.mstats.zmap

# Compute the z score.
scipy.stats.mstats.zscore

# Constructs a 2D array from a group of sequences.
scipy.stats.mstats_basic.argstoarray

# Compute the Brunner-Munzel test on samples x and y.
scipy.stats.mstats_basic.brunnermunzel

# Counts the number of tied values.
scipy.stats.mstats_basic.count_tied_groups

# Computes several descriptive statistics of the passed array.
scipy.stats.mstats_basic.describe

# Performs a 1-way ANOVA, returning an F-value and probability given
scipy.stats.mstats_basic.f_oneway

# Find repeats in arr and return a tuple (repeats, repeat_count).
scipy.stats.mstats_basic.find_repeats

# Friedman Chi-Square is a non-parametric, one-way within-subjects ANOVA.
scipy.stats.mstats_basic.friedmanchisquare

# Computes Kendall's rank correlation tau on two variables *x* and *y*.
scipy.stats.mstats_basic.kendalltau

# Computes a multivariate Kendall's rank correlation tau, for seasonal data.
scipy.stats.mstats_basic.kendalltau_seasonal

# Compute the Kruskal-Wallis H-test for independent samples
scipy.stats.mstats_basic.kruskal

# Compute the Kruskal-Wallis H-test for independent samples
scipy.stats.mstats_basic.kruskalwallis

# Computes the Kolmogorov-Smirnov test on one sample of masked values.
scipy.stats.mstats_basic.ks_1samp

# Computes the Kolmogorov-Smirnov test on two samples.
scipy.stats.mstats_basic.ks_2samp

# Computes the Kolmogorov-Smirnov test on two samples.
scipy.stats.mstats_basic.ks_twosamp

# Parameters
scipy.stats.mstats_basic.kstest

# Computes the kurtosis (Fisher or Pearson) of a dataset.
scipy.stats.mstats_basic.kurtosis

# Tests whether a dataset has normal kurtosis
scipy.stats.mstats_basic.kurtosistest

# Calculate a linear least-squares regression for two sets of measurements.
scipy.stats.mstats_basic.linregress

# Computes the Mann-Whitney statistic
scipy.stats.mstats_basic.mannwhitneyu

# Returns plotting positions (or empirical percentile points) for the data.
scipy.stats.mstats_basic.meppf

# Returns an array of the modal (most common) value in the passed array.
scipy.stats.mstats_basic.mode

# Calculates the nth moment about the mean for a sample.
scipy.stats.mstats_basic.moment

# Computes empirical quantiles for a data array.
scipy.stats.mstats_basic.mquantiles

# Returns the sign of x, or 0 if x is masked.
scipy.stats.mstats_basic.msign

# Tests whether a sample differs from a normal distribution.
scipy.stats.mstats_basic.normaltest

# Computes a transform on input data (any number of columns).  Used to
scipy.stats.mstats_basic.obrientransform

# Pearson correlation coefficient and p-value for testing non-correlation.
scipy.stats.mstats_basic.pearsonr

# Returns plotting positions (or empirical percentile points) for the data.
scipy.stats.mstats_basic.plotting_positions

# Calculates a point biserial correlation coefficient and its p-value.
scipy.stats.mstats_basic.pointbiserialr

# Returns the rank (also known as order statistics) of each data point
scipy.stats.mstats_basic.rankdata

# Calculate the score at the given 'per' percentile of the
scipy.stats.mstats_basic.scoreatpercentile

# Calculates the standard error of the mean of the input array.
scipy.stats.mstats_basic.sem

# Computes seasonal Theil-Sen and Kendall slope estimators.
scipy.stats.mstats_basic.sen_seasonal_slopes

# Computes the Siegel estimator for a set of points (x, y).
scipy.stats.mstats_basic.siegelslopes

# Computes the skewness of a data set.
scipy.stats.mstats_basic.skew

# Tests whether the skew is different from the normal distribution.
scipy.stats.mstats_basic.skewtest

# Calculates a Spearman rank-order correlation coefficient and the p-value
scipy.stats.mstats_basic.spearmanr

# Computes the Theil-Sen estimator for a set of points (x, y).
scipy.stats.mstats_basic.theilslopes

# Compute the trimmed maximum
scipy.stats.mstats_basic.tmax

# Compute the trimmed mean.
scipy.stats.mstats_basic.tmean

# Compute the trimmed minimum
scipy.stats.mstats_basic.tmin

# Trims an array by masking the data outside some given limits.
scipy.stats.mstats_basic.trim

# Trims an array by masking the data outside some given limits.
scipy.stats.mstats_basic.trima

# Trims the smallest and largest data values.
scipy.stats.mstats_basic.trimboth

# Returns the trimmed mean of the data along the given axis.
scipy.stats.mstats_basic.trimmed_mean

# Returns the trimmed standard deviation of the data along the given axis.
scipy.stats.mstats_basic.trimmed_std

# Returns the standard error of the trimmed mean along the given axis.
scipy.stats.mstats_basic.trimmed_stde

# Returns the trimmed variance of the data along the given axis.
scipy.stats.mstats_basic.trimmed_var

# Trims an array by masking some proportion of the data on each end.
scipy.stats.mstats_basic.trimr

# Trims the data by masking values from one tail.
scipy.stats.mstats_basic.trimtail

# Compute the trimmed standard error of the mean.
scipy.stats.mstats_basic.tsem

# Calculates the T-test for the mean of ONE group of scores.
scipy.stats.mstats_basic.ttest_1samp

# Calculates the T-test for the means of TWO INDEPENDENT samples of scores.
scipy.stats.mstats_basic.ttest_ind

# Calculates the T-test for the mean of ONE group of scores.
scipy.stats.mstats_basic.ttest_onesamp

# Calculates the T-test on TWO RELATED samples of scores, a and b.
scipy.stats.mstats_basic.ttest_rel

# Compute the trimmed variance
scipy.stats.mstats_basic.tvar

# Compute the coefficient of variation.
scipy.stats.mstats_basic.variation

# Returns a Winsorized version of the input array.
scipy.stats.mstats_basic.winsorize

# Compares the medians from two independent groups along the given axis.
scipy.stats.mstats_extras.compare_medians_ms

# Returns the Harrell-Davis estimate of the median along the given axis.
scipy.stats.mstats_extras.hdmedian

# Computes quantile estimates with the Harrell-Davis method.
scipy.stats.mstats_extras.hdquantiles

# The standard error of the Harrell-Davis quantile estimates by jackknife.
scipy.stats.mstats_extras.hdquantiles_sd

# Returns an estimate of the lower and upper quartiles.
scipy.stats.mstats_extras.idealfourths

# Computes the alpha-level confidence interval for the median of the data.
scipy.stats.mstats_extras.median_cihs

# Returns the Maritz-Jarrett estimators of the standard error of selected
scipy.stats.mstats_extras.mjci

# Computes the alpha confidence interval for the selected quantiles of the
scipy.stats.mstats_extras.mquantiles_cimj

# Evaluates Rosenblatt's shifted histogram estimators for each data point.
scipy.stats.mstats_extras.rsh

# Selected confidence interval of the trimmed mean along the given axis.
scipy.stats.mstats_extras.trimmed_mean_ci

# Halton sequence.
scipy.stats.qmc.Halton

# Latin hypercube sampling (LHS).
scipy.stats.qmc.LatinHypercube

# QMC sampling from a multinomial distribution.
scipy.stats.qmc.MultinomialQMC

# QMC sampling from a multivariate Normal :math:`N(\mu, \Sigma)`.
scipy.stats.qmc.MultivariateNormalQMC

# Poisson disk sampling.
scipy.stats.qmc.PoissonDisk

# A generic Quasi-Monte Carlo sampler class meant for subclassing.
scipy.stats.qmc.QMCEngine

# Engine for generating (scrambled) Sobol' sequences.
scipy.stats.qmc.Sobol

# Discrepancy of a given sample.
scipy.stats.qmc.discrepancy

# Discrepancy of a given sample based on its geometric properties.
scipy.stats.qmc.geometric_discrepancy

# Sample scaling from unit hypercube to different bounds.
scipy.stats.qmc.scale

# Update the centered discrepancy with a new sample.
scipy.stats.qmc.update_discrepancy

# DiscreteAliasUrn(dist, *, domain=None, urn_factor=1, random_state=None)
scipy.stats.sampling.DiscreteAliasUrn

# DiscreteGuideTable(dist, *, domain=None, guide_factor=1, random_state=None)
scipy.stats.sampling.DiscreteGuideTable

# Fast sampling by numerical inversion of the CDF for a large class of
scipy.stats.sampling.FastGeneratorInversion

# NumericalInverseHermite(dist, *, domain=None, order=3, u_resolution=1e-12, construction_points=None, random_state=None)
scipy.stats.sampling.NumericalInverseHermite

# NumericalInversePolynomial(dist, *, mode=None, center=None, domain=None, order=5, u_resolution=1e-10, random_state=None)
scipy.stats.sampling.NumericalInversePolynomial

# Generate random samples from a probability density function using the
scipy.stats.sampling.RatioUniforms

# SimpleRatioUniforms(dist, *, mode=None, pdf_area=1, domain=None, cdf_at_mode=None, random_state=None)
scipy.stats.sampling.SimpleRatioUniforms

# TransformedDensityRejection(dist, *, mode=None, center=None, domain=None, c=-0.5, construction_points=30, use_dars=True, max_squeeze_hat_ratio=0.99, random_state=None)
scipy.stats.sampling.TransformedDensityRejection

# Raised when an error occurs in the UNU.RAN library.
scipy.stats.sampling.UNURANError

# Performs the Alexander Govern test.
scipy.stats.stats.alexandergovern

# Compute the Brunner-Munzel test on samples x and y.
scipy.stats.stats.brunnermunzel

# Perform Pearson's chi-squared test.
scipy.stats.stats.chisquare

# Combine p-values from independent tests that bear upon the same hypothesis.
scipy.stats.stats.combine_pvalues

# Return a cumulative frequency histogram, using the histogram function.
scipy.stats.stats.cumfreq

# Compute several descriptive statistics of the passed array.
scipy.stats.stats.describe

scipy.stats.stats.distributions

# Compute the energy distance between two 1D distributions.
scipy.stats.stats.energy_distance

# Perform one-way ANOVA.
scipy.stats.stats.f_oneway

# Find repeats and repeat counts.
scipy.stats.stats.find_repeats

# Perform a Fisher exact test on a contingency table.
scipy.stats.stats.fisher_exact

# Compute the Friedman test for repeated samples.
scipy.stats.stats.friedmanchisquare

# Compute the weighted geometric mean along the specified axis.
scipy.stats.stats.gmean

# Calculate the geometric standard deviation of an array.
scipy.stats.stats.gstd

# Compute the geometric standard score.
scipy.stats.stats.gzscore

# Calculate the weighted harmonic mean along the specified axis.
scipy.stats.stats.hmean

# Compute the interquartile range of the data along the specified axis.
scipy.stats.stats.iqr

# Perform the Jarque-Bera goodness of fit test on sample data.
scipy.stats.stats.jarque_bera

# Calculate Kendall's tau, a correlation measure for ordinal data.
scipy.stats.stats.kendalltau

# Compute the Kruskal-Wallis H-test for independent samples.
scipy.stats.stats.kruskal

# Performs the one-sample Kolmogorov-Smirnov test for goodness of fit.
scipy.stats.stats.ks_1samp

# Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.
scipy.stats.stats.ks_2samp

# Performs the (one-sample or two-sample) Kolmogorov-Smirnov test for
scipy.stats.stats.kstest

# Compute the kurtosis (Fisher or Pearson) of a dataset.
scipy.stats.stats.kurtosis

# Test whether a dataset has normal kurtosis.
scipy.stats.stats.kurtosistest

# Calculate a linear least-squares regression for two sets of measurements.
scipy.stats.stats.linregress

# Compute the median absolute deviation of the data along the given axis.
scipy.stats.stats.median_abs_deviation

# Return an array of the modal (most common) value in the passed array.
scipy.stats.stats.mode

# Calculate the nth moment about the mean for a sample.
scipy.stats.stats.moment

# An extension of scipy.stats._stats_py to support masked arrays
scipy.stats.stats.mstats_basic

# Computes the Multiscale Graph Correlation (MGC) test statistic.
scipy.stats.stats.multiscale_graphcorr

# Test whether a sample differs from a normal distribution.
scipy.stats.stats.normaltest

# Compute the O'Brien transform on input data (any number of arrays).
scipy.stats.stats.obrientransform

# Pearson correlation coefficient and p-value for testing non-correlation.
scipy.stats.stats.pearsonr

# Compute the percentile rank of a score relative to a list of scores.
scipy.stats.stats.percentileofscore

# Calculate the weighted power mean along the specified axis.
scipy.stats.stats.pmean

# Calculate a point biserial correlation coefficient and its p-value.
scipy.stats.stats.pointbiserialr

# Cressie-Read power divergence statistic and goodness of fit test.
scipy.stats.stats.power_divergence

# Assign ranks to data, dealing with ties appropriately.
scipy.stats.stats.rankdata

# Compute the Wilcoxon rank-sum statistic for two samples.
scipy.stats.stats.ranksums

# Return a relative frequency histogram, using the histogram function.
scipy.stats.stats.relfreq

# Calculate the score at a given percentile of the input sequence.
scipy.stats.stats.scoreatpercentile

# Compute standard error of the mean.
scipy.stats.stats.sem

# Computes the Siegel estimator for a set of points (x, y).
scipy.stats.stats.siegelslopes

# Perform iterative sigma-clipping of array elements.
scipy.stats.stats.sigmaclip

# Compute the sample skewness of a data set.
scipy.stats.stats.skew

# Test whether the skew is different from the normal distribution.
scipy.stats.stats.skewtest

# Calculate a Spearman correlation coefficient with associated p-value.
scipy.stats.stats.spearmanr

# Computes the Theil-Sen estimator for a set of points (x, y).
scipy.stats.stats.theilslopes

# Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests.
scipy.stats.stats.tiecorrect

# Compute the trimmed maximum.
scipy.stats.stats.tmax

# Compute the trimmed mean.
scipy.stats.stats.tmean

# Compute the trimmed minimum.
scipy.stats.stats.tmin

# Slice off a proportion from ONE end of the passed array distribution.
scipy.stats.stats.trim1

# Return mean of array after trimming a specified fraction of extreme values
scipy.stats.stats.trim_mean

# Slice off a proportion of items from both ends of an array.
scipy.stats.stats.trimboth

# Compute the trimmed standard error of the mean.
scipy.stats.stats.tsem

# Compute the trimmed sample standard deviation.
scipy.stats.stats.tstd

# Calculate the T-test for the mean of ONE group of scores.
scipy.stats.stats.ttest_1samp

# Calculate the T-test for the means of *two independent* samples of scores.
scipy.stats.stats.ttest_ind

# T-test for means of two independent samples from descriptive statistics.
scipy.stats.stats.ttest_ind_from_stats

# Calculate the t-test on TWO RELATED samples of scores, a and b.
scipy.stats.stats.ttest_rel

# Compute the trimmed variance.
scipy.stats.stats.tvar

# Compute the Wasserstein-1 distance between two 1D discrete distributions.
scipy.stats.stats.wasserstein_distance

# Compute a weighted version of Kendall's :math:`\tau`.
scipy.stats.stats.weightedtau

# Calculate the relative z-scores.
scipy.stats.stats.zmap

# Compute the z score.
scipy.stats.stats.zscore

# str(object='') -> str
scipy.version.full_version

# str(object='') -> str
scipy.version.git_revision

# Returns True when the argument is true, False otherwise.
scipy.version.release

# str(object='') -> str
scipy.version.short_version

# str(object='') -> str
scipy.version.version

