Warning: Could not import numpy._pyinstaller.hook-numpy: No module named 'PyInstaller'
Warning: Could not import numpy.conftest: No module named 'hypothesis'
# Show libraries and system information on which NumPy was built
numpy.__config__.show_config

# Boolean type (True or False), stored as a byte.
numpy._array_api_info.bool

# Complex number type composed of two double-precision floating-point
numpy._array_api_info.complex128

# Complex number type composed of two single-precision floating-point
numpy._array_api_info.complex64

# dtype(dtype, align=False, copy=False, [metadata])
numpy._array_api_info.dtype

# Single-precision floating-point number type, compatible with C ``float``.
numpy._array_api_info.float32

# Double-precision floating-point number type, compatible with Python
numpy._array_api_info.float64

# Signed integer type, compatible with C ``short``.
numpy._array_api_info.int16

# Signed integer type, compatible with C ``int``.
numpy._array_api_info.int32

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy._array_api_info.int64

# Signed integer type, compatible with C ``char``.
numpy._array_api_info.int8

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy._array_api_info.intp

# Unsigned integer type, compatible with C ``unsigned short``.
numpy._array_api_info.uint16

# Unsigned integer type, compatible with C ``unsigned int``.
numpy._array_api_info.uint32

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy._array_api_info.uint64

# Unsigned integer type, compatible with C ``unsigned char``.
numpy._array_api_info.uint8

# PurePath subclass that can make system calls.
numpy._configtool.Path

# Command-line parsing library
numpy._configtool.argparse

# Return the directory that contains the NumPy \*.h header files.
numpy._configtool.get_include

numpy._configtool.main

# This module provides access to some objects used or maintained by the
numpy._configtool.sys

# An enumeration for the copy modes supported
numpy._globals._CopyMode

# Special keyword value.
numpy._globals._NoValue

# Pytest test runner.
numpy._pytesttester.PytestTester

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy._typing._add_docstring.NDArray

# Append ``_docstrings_list`` with a docstring for `name`.
numpy._typing._add_docstring.add_newdoc

# Support for regular expressions (RE).
numpy._typing._add_docstring.re

# Text wrapping and filling.
numpy._typing._add_docstring.textwrap

# Special type indicating an unconstrained type.
numpy._typing._array_like.Any

numpy._typing._array_like.ArrayLike

numpy._typing._array_like.Callable

numpy._typing._array_like.Collection

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy._typing._array_like.NDArray

# Base class for protocol classes.
numpy._typing._array_like.Protocol

# All the operations on a read-only sequence.
numpy._typing._array_like.Sequence

# StringDType(*, na_object=np._NoValue, coerce=True)
numpy._typing._array_like.StringDType

# Returns True when the argument is true, False otherwise.
numpy._typing._array_like.TYPE_CHECKING

# Special form for marking type aliases.
numpy._typing._array_like.TypeAlias

# Type variable.
numpy._typing._array_like.TypeVar

# dtype(dtype, align=False, copy=False, [metadata])
numpy._typing._array_like.dtype

# NumPy
numpy._typing._array_like.np

# Mark a protocol class as a runtime protocol.
numpy._typing._array_like.runtime_checkable

# This module provides access to some objects used or maintained by the
numpy._typing._array_like.sys

# Special typing form to define literal types (a.k.a. value types).
numpy._typing._char_codes.Literal

# Special type indicating an unconstrained type.
numpy._typing._dtype_like.Any

numpy._typing._dtype_like.DTypeLike

# Base class for protocol classes.
numpy._typing._dtype_like.Protocol

# All the operations on a read-only sequence.
numpy._typing._dtype_like.Sequence

# Special form for marking type aliases.
numpy._typing._dtype_like.TypeAlias

# Type variable.
numpy._typing._dtype_like.TypeVar

# A simple typed namespace. At runtime it is equivalent to a plain dict.
numpy._typing._dtype_like.TypedDict

# NumPy
numpy._typing._dtype_like.np

# Mark a protocol class as a runtime protocol.
numpy._typing._dtype_like.runtime_checkable

# Abstract base class of all complex number scalar types that are made up of
numpy._typing._extended_precision.complex192

# Abstract base class of all complex number scalar types that are made up of
numpy._typing._extended_precision.complex256

# Abstract base class of all floating-point scalar types.
numpy._typing._extended_precision.float128

# Abstract base class of all floating-point scalar types.
numpy._typing._extended_precision.float96

# NumPy
numpy._typing._extended_precision.np

# Special form for marking type aliases.
numpy._typing._nbit.TypeAlias

# A type representing `numpy.number` precision during static type checking.
numpy._typing._nbit_base.NBitBase

# Decorator to indicate final methods and final classes.
numpy._typing._nbit_base.final

# Private decorator for overriding __module__ on a function or class.
numpy._typing._nbit_base.set_module

# A protocol for representing nested sequences.
numpy._typing._nested_sequence._NestedSequence

# Special type indicating an unconstrained type.
numpy._typing._scalars.Any

# Special form for marking type aliases.
numpy._typing._scalars.TypeAlias

# NumPy
numpy._typing._scalars.np

# Special type indicating an unconstrained type.
numpy._typing._shape.Any

# All the operations on a read-only sequence.
numpy._typing._shape.Sequence

# An ABC with one abstract method __index__.
numpy._typing._shape.SupportsIndex

# Special form for marking type aliases.
numpy._typing._shape.TypeAlias

# Functions that operate element by element on whole arrays.
numpy._typing._ufunc.ufunc

numpy._utils._convertions.asbytes

numpy._utils._convertions.asunicode

# Format an argument spec from the 4 values returned by getargspec.
numpy._utils._inspect.formatargspec

# Get the names and default values of a function's arguments.
numpy._utils._inspect.getargspec

# An invalid version was found, users should refer to PEP 440.
numpy._utils._pep440.InvalidVersion

numpy._utils._pep440.LegacyVersion

# str(object='') -> str
numpy._utils._pep440.VERSION_PATTERN

numpy._utils._pep440.Version

# Parse the given version string and return either a :class:`Version` object
numpy._utils._pep440.parse

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.absolute

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.add

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arccos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arccosh

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arcsin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arcsinh

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arctan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arctan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.arctanh

# str(object='') -> str
numpy.core._multiarray_umath.attr

# bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.bitwise_and

# bitwise_count(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.bitwise_count

# bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.bitwise_or

# bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.bitwise_xor

# cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.cbrt

# ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.ceil

# clip(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.clip

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.conj

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.conjugate

# copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.copysign

# cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.cos

# cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.cosh

# count(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.count

# deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.deg2rad

# degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.degrees

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.divide

# divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.divmod

# endswith(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.endswith

# equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.equal

# exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.exp

# exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.exp2

# expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.expm1

# fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.fabs

# find(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.find

# float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.float_power

# floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.floor

# floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.floor_divide

# fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.fmax

# fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.fmin

# fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.fmod

# frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.frexp

# gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.gcd

# greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.greater

# greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.greater_equal

# heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.heaviside

# hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.hypot

# index(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.index

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.invert

# isalnum(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isalnum

# isalpha(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isalpha

# isdecimal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isdecimal

# isdigit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isdigit

# isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isfinite

# isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isinf

# islower(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.islower

# isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isnan

# isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isnat

# isnumeric(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isnumeric

# isspace(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isspace

# istitle(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.istitle

# isupper(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.isupper

# str(object='') -> str
numpy.core._multiarray_umath.item

# lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.lcm

# ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.ldexp

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.left_shift

# less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.less

# less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.less_equal

# log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.log

# log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.log10

# log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.log1p

# log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.log2

# logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.logaddexp

# logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.logaddexp2

# logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.logical_and

# logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.logical_not

# logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.logical_or

# logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.logical_xor

# matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core._multiarray_umath.matmul

# matvec(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core._multiarray_umath.matvec

# maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.maximum

# minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.minimum

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.mod

# modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.modf

# multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.multiply

# negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.negative

# nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.nextafter

# not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.not_equal

# positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.positive

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.power

# rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.rad2deg

# radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.radians

# reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.reciprocal

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.remainder

# rfind(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.rfind

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.right_shift

# rindex(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.rindex

# rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.rint

# sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.sign

# signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.signbit

# sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.sin

# sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.sinh

# spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.spacing

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.sqrt

# square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.square

# startswith(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.startswith

# str_len(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.str_len

# subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.subtract

# tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.tan

# tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.tanh

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.true_divide

# trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core._multiarray_umath.trunc

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core._multiarray_umath.vecdot

# vecmat(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core._multiarray_umath.vecmat

# Python part of the warnings subsystem.
numpy.core._utils.warnings

# Return a string representation of an array.
numpy.core.arrayprint.array2string

# Return the string representation of an array.
numpy.core.arrayprint.array_repr

# Return a string representation of the data in an array.
numpy.core.arrayprint.array_str

# Format a floating-point scalar as a decimal string in positional notation.
numpy.core.arrayprint.format_float_positional

# Format a floating-point scalar as a decimal string in scientific notation.
numpy.core.arrayprint.format_float_scientific

# Return the current print options.
numpy.core.arrayprint.get_printoptions

# Context manager for setting print options.
numpy.core.arrayprint.printoptions

# Set printing options.
numpy.core.arrayprint.set_printoptions

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.add

# Create a `~numpy.char.chararray`.
numpy.core.defchararray.array

# Convert the input to a `~numpy.char.chararray`, copying the data only if
numpy.core.defchararray.asarray

# Return a copy of ``a`` with only the first character of each element
numpy.core.defchararray.capitalize

# Return a copy of `a` with its elements centered in a string of
numpy.core.defchararray.center

# chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,
numpy.core.defchararray.chararray

# compare_chararrays(a1, a2, cmp, rstrip)
numpy.core.defchararray.compare_chararrays

# Returns an array with the number of non-overlapping occurrences of
numpy.core.defchararray.count

# Calls :meth:`bytes.decode` element-wise.
numpy.core.defchararray.decode

# Calls :meth:`str.encode` element-wise.
numpy.core.defchararray.encode

# Returns a boolean array which is `True` where the string element
numpy.core.defchararray.endswith

# Return (x1 == x2) element-wise.
numpy.core.defchararray.equal

# Return a copy of each string element where all tab characters are
numpy.core.defchararray.expandtabs

# For each element, return the lowest index in the string where
numpy.core.defchararray.find

# Return (x1 > x2) element-wise.
numpy.core.defchararray.greater

# Return (x1 >= x2) element-wise.
numpy.core.defchararray.greater_equal

# Like `find`, but raises :exc:`ValueError` when the substring is not found.
numpy.core.defchararray.index

# isalnum(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isalnum

# isalpha(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isalpha

# isdecimal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isdecimal

# isdigit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isdigit

# islower(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.islower

# isnumeric(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isnumeric

# isspace(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isspace

# istitle(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.istitle

# isupper(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.isupper

# Return a string which is the concatenation of the strings in the
numpy.core.defchararray.join

# Return (x1 < x2) element-wise.
numpy.core.defchararray.less

# Return (x1 <= x2) element-wise.
numpy.core.defchararray.less_equal

# Return an array with the elements of `a` left-justified in a
numpy.core.defchararray.ljust

# Return an array with the elements converted to lowercase.
numpy.core.defchararray.lower

# For each element in `a`, return a copy with the leading characters
numpy.core.defchararray.lstrip

# Return (a % i), that is pre-Python 2.6 string formatting
numpy.core.defchararray.mod

# Return (a * i), that is string multiple concatenation,
numpy.core.defchararray.multiply

# Return (x1 != x2) element-wise.
numpy.core.defchararray.not_equal

# Partition each element in `a` around `sep`.
numpy.core.defchararray.partition

# For each element in ``a``, return a copy of the string with
numpy.core.defchararray.replace

# For each element, return the highest index in the string where
numpy.core.defchararray.rfind

# Like `rfind`, but raises :exc:`ValueError` when the substring `sub` is
numpy.core.defchararray.rindex

# Return an array with the elements of `a` right-justified in a
numpy.core.defchararray.rjust

# Partition (split) each element around the right-most separator.
numpy.core.defchararray.rpartition

# For each element in `a`, return a list of the words in the
numpy.core.defchararray.rsplit

# For each element in `a`, return a copy with the trailing characters
numpy.core.defchararray.rstrip

# For each element in `a`, return a list of the words in the
numpy.core.defchararray.split

# For each element in `a`, return a list of the lines in the
numpy.core.defchararray.splitlines

# Returns a boolean array which is `True` where the string element
numpy.core.defchararray.startswith

# str_len(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.defchararray.str_len

# For each element in `a`, return a copy with the leading and
numpy.core.defchararray.strip

# Return element-wise a copy of the string with
numpy.core.defchararray.swapcase

# Return element-wise title cased version of string or unicode.
numpy.core.defchararray.title

# For each element in `a`, return a copy of the string where all
numpy.core.defchararray.translate

# Return an array with the elements converted to uppercase.
numpy.core.defchararray.upper

# Return the numeric string left-filled with zeros. A leading
numpy.core.defchararray.zfill

# einsum(subscripts, *operands, out=None, dtype=None, order='K',
numpy.core.einsumfunc.einsum

# einsum_path(subscripts, *operands, optimize='greedy')
numpy.core.einsumfunc.einsum_path

# Test whether all array elements along a given axis evaluate to True.
numpy.core.fromnumeric.all

# Return the maximum of an array or maximum along an axis.
numpy.core.fromnumeric.amax

# Return the minimum of an array or minimum along an axis.
numpy.core.fromnumeric.amin

# Test whether any array element along a given axis evaluates to True.
numpy.core.fromnumeric.any

# Returns the indices of the maximum values along an axis.
numpy.core.fromnumeric.argmax

# Returns the indices of the minimum values along an axis.
numpy.core.fromnumeric.argmin

# Perform an indirect partition along the given axis using the
numpy.core.fromnumeric.argpartition

# Returns the indices that would sort an array.
numpy.core.fromnumeric.argsort

# Round an array to the given number of decimals.
numpy.core.fromnumeric.around

# Construct an array from an index array and a list of arrays to choose from.
numpy.core.fromnumeric.choose

# Clip (limit) the values in an array.
numpy.core.fromnumeric.clip

# Return selected slices of an array along given axis.
numpy.core.fromnumeric.compress

# Return the cumulative product of elements along a given axis.
numpy.core.fromnumeric.cumprod

# Return the cumulative sum of the elements along a given axis.
numpy.core.fromnumeric.cumsum

# Return the cumulative product of elements along a given axis.
numpy.core.fromnumeric.cumulative_prod

# Return the cumulative sum of the elements along a given axis.
numpy.core.fromnumeric.cumulative_sum

# Return specified diagonals.
numpy.core.fromnumeric.diagonal

# Transposes a matrix (or a stack of matrices) ``x``.
numpy.core.fromnumeric.matrix_transpose

# Return the maximum of an array or maximum along an axis.
numpy.core.fromnumeric.max

# Compute the arithmetic mean along the specified axis.
numpy.core.fromnumeric.mean

# Return the minimum of an array or minimum along an axis.
numpy.core.fromnumeric.min

# Return the number of dimensions of an array.
numpy.core.fromnumeric.ndim

# Return the indices of the elements that are non-zero.
numpy.core.fromnumeric.nonzero

# Return a partitioned copy of an array.
numpy.core.fromnumeric.partition

# Return the product of array elements over a given axis.
numpy.core.fromnumeric.prod

# Range of values (maximum - minimum) along an axis.
numpy.core.fromnumeric.ptp

# Replaces specified elements of an array with given values.
numpy.core.fromnumeric.put

# Return a contiguous flattened array.
numpy.core.fromnumeric.ravel

# Repeat each element of an array after themselves
numpy.core.fromnumeric.repeat

# Gives a new shape to an array without changing its data.
numpy.core.fromnumeric.reshape

# Return a new array with the specified shape.
numpy.core.fromnumeric.resize

# Evenly round to the given number of decimals.
numpy.core.fromnumeric.round

# Find indices where elements should be inserted to maintain order.
numpy.core.fromnumeric.searchsorted

# Return the shape of an array.
numpy.core.fromnumeric.shape

# Return the number of elements along a given axis.
numpy.core.fromnumeric.size

# Return a sorted copy of an array.
numpy.core.fromnumeric.sort

# Remove axes of length one from `a`.
numpy.core.fromnumeric.squeeze

# Compute the standard deviation along the specified axis.
numpy.core.fromnumeric.std

# Sum of array elements over a given axis.
numpy.core.fromnumeric.sum

# Interchange two axes of an array.
numpy.core.fromnumeric.swapaxes

# Take elements from an array along an axis.
numpy.core.fromnumeric.take

# Return the sum along diagonals of the array.
numpy.core.fromnumeric.trace

# Returns an array with axes transposed.
numpy.core.fromnumeric.transpose

# Compute the variance along the specified axis.
numpy.core.fromnumeric.var

# Return numbers spaced evenly on a log scale (a geometric progression).
numpy.core.function_base.geomspace

# Return evenly spaced numbers over a specified interval.
numpy.core.function_base.linspace

# Return numbers spaced evenly on a log scale.
numpy.core.function_base.logspace

# finfo(dtype)
numpy.core.getlimits.finfo

# iinfo(type)
numpy.core.getlimits.iinfo

# int([x]) -> integer
numpy.core.multiarray.ALLOW_THREADS

# int([x]) -> integer
numpy.core.multiarray.BUFSIZE

# int([x]) -> integer
numpy.core.multiarray.CLIP

# Capsule objects let you wrap a C "void *" pointer in a Python
numpy.core.multiarray.DATETIMEUNITS

# int([x]) -> integer
numpy.core.multiarray.ITEM_HASOBJECT

# int([x]) -> integer
numpy.core.multiarray.ITEM_IS_POINTER

# int([x]) -> integer
numpy.core.multiarray.LIST_PICKLE

# int([x]) -> integer
numpy.core.multiarray.MAXDIMS

# int([x]) -> integer
numpy.core.multiarray.MAY_SHARE_BOUNDS

# int([x]) -> integer
numpy.core.multiarray.MAY_SHARE_EXACT

# int([x]) -> integer
numpy.core.multiarray.NEEDS_INIT

# int([x]) -> integer
numpy.core.multiarray.NEEDS_PYAPI

# int([x]) -> integer
numpy.core.multiarray.RAISE

# int([x]) -> integer
numpy.core.multiarray.USE_GETITEM

# int([x]) -> integer
numpy.core.multiarray.USE_SETITEM

# int([x]) -> integer
numpy.core.multiarray.WRAP

# Capsule objects let you wrap a C "void *" pointer in a Python
numpy.core.multiarray._ARRAY_API

# dict() -> new empty dictionary
numpy.core.multiarray._flagdict

numpy.core.multiarray._monotonicity

# Insert vals sequentially into equivalent 1-d positions indicated by mask.
numpy.core.multiarray._place

# _reconstruct(subtype, shape, dtype)
numpy.core.multiarray._reconstruct

numpy.core.multiarray._vec_string

# add_docstring(obj, docstring)
numpy.core.multiarray.add_docstring

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
numpy.core.multiarray.arange

# array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
numpy.core.multiarray.array

# asanyarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.core.multiarray.asanyarray

# asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.core.multiarray.asarray

# ascontiguousarray(a, dtype=None, *, like=None)
numpy.core.multiarray.ascontiguousarray

# asfortranarray(a, dtype=None, *, like=None)
numpy.core.multiarray.asfortranarray

# bincount(x, /, weights=None, minlength=0)
numpy.core.multiarray.bincount

# Produce an object that mimics broadcasting.
numpy.core.multiarray.broadcast

# busday_count(
numpy.core.multiarray.busday_count

# busday_offset(
numpy.core.multiarray.busday_offset

# busdaycalendar(weekmask='1111100', holidays=None)
numpy.core.multiarray.busdaycalendar

# c_einsum(subscripts, *operands, out=None, dtype=None, order='K',
numpy.core.multiarray.c_einsum

# can_cast(from_, to, casting='safe')
numpy.core.multiarray.can_cast

# compare_chararrays(a1, a2, cmp, rstrip)
numpy.core.multiarray.compare_chararrays

# concatenate(
numpy.core.multiarray.concatenate

# copyto(dst, src, casting='same_kind', where=True)
numpy.core.multiarray.copyto

# cross_correlate(a,v, mode=0)
numpy.core.multiarray.correlate

numpy.core.multiarray.correlate2

numpy.core.multiarray.count_nonzero

# datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
numpy.core.multiarray.datetime_as_string

# datetime_data(dtype, /)
numpy.core.multiarray.datetime_data

# dot(a, b, out=None)
numpy.core.multiarray.dot

numpy.core.multiarray.dragon4_positional

numpy.core.multiarray.dragon4_scientific

# dtype(dtype, align=False, copy=False, [metadata])
numpy.core.multiarray.dtype

# empty(shape, dtype=float, order='C', *, device=None, like=None)
numpy.core.multiarray.empty

# empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *,
numpy.core.multiarray.empty_like

# Common base class for all non-exit exceptions.
numpy.core.multiarray.error

numpy.core.multiarray.flagsobj

# Flat iterator object to iterate over arrays.
numpy.core.multiarray.flatiter

numpy.core.multiarray.format_longfloat

# from_dlpack(x, /, *, device=None, copy=None)
numpy.core.multiarray.from_dlpack

# frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)
numpy.core.multiarray.frombuffer

# fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None)
numpy.core.multiarray.fromfile

# fromiter(iter, dtype, count=-1, *, like=None)
numpy.core.multiarray.fromiter

# fromstring(string, dtype=float, count=-1, *, sep, like=None)
numpy.core.multiarray.fromstring

# get_handler_name(a: ndarray) -> str,None
numpy.core.multiarray.get_handler_name

# get_handler_version(a: ndarray) -> int,None
numpy.core.multiarray.get_handler_version

# inner(a, b, /)
numpy.core.multiarray.inner

numpy.core.multiarray.interp

numpy.core.multiarray.interp_complex

# is_busday(
numpy.core.multiarray.is_busday

# lexsort(keys, axis=-1)
numpy.core.multiarray.lexsort

# matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.multiarray.matmul

# may_share_memory(a, b, /, max_work=None)
numpy.core.multiarray.may_share_memory

# min_scalar_type(a, /)
numpy.core.multiarray.min_scalar_type

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.core.multiarray.ndarray

# nditer(op, flags=None, op_flags=None, op_dtypes=None, order='K',
numpy.core.multiarray.nditer

# nested_iters(op, axes, flags=None, op_flags=None, op_dtypes=None,     order="K", casting="safe", buffersize=0)
numpy.core.multiarray.nested_iters

# normalize_axis_index(axis, ndim, msg_prefix=None)
numpy.core.multiarray.normalize_axis_index

# packbits(a, /, axis=None, bitorder='big')
numpy.core.multiarray.packbits

# promote_types(type1, type2)
numpy.core.multiarray.promote_types

# putmask(a, mask, values)
numpy.core.multiarray.putmask

# ravel_multi_index(multi_index, dims, mode='raise', order='C')
numpy.core.multiarray.ravel_multi_index

# result_type(*arrays_and_dtypes)
numpy.core.multiarray.result_type

# scalar(dtype, obj)
numpy.core.multiarray.scalar

numpy.core.multiarray.set_datetimeparse_function

# set_typeDict(dict)
numpy.core.multiarray.set_typeDict

# shares_memory(a, b, /, max_work=None)
numpy.core.multiarray.shares_memory

# dict() -> new empty dictionary
numpy.core.multiarray.typeinfo

# unpackbits(a, /, axis=None, count=None, bitorder='big')
numpy.core.multiarray.unpackbits

# unravel_index(indices, shape, order='C')
numpy.core.multiarray.unravel_index

# vdot(a, b, /)
numpy.core.multiarray.vdot

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.multiarray.vecdot

# where(condition, [x, y], /)
numpy.core.multiarray.where

# zeros(shape, dtype=float, order='C', *, like=None)
numpy.core.multiarray.zeros

# Boolean type (True or False), stored as a byte.
numpy.core.numeric.False_

# Built-in immutable sequence.
numpy.core.numeric.ScalarType

# Boolean type (True or False), stored as a byte.
numpy.core.numeric.True_

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.absolute

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.add

# Test whether all array elements along a given axis evaluate to True.
numpy.core.numeric.all

# Returns True if two arrays are element-wise equal within a tolerance.
numpy.core.numeric.allclose

# Return the maximum of an array or maximum along an axis.
numpy.core.numeric.amax

# Return the minimum of an array or minimum along an axis.
numpy.core.numeric.amin

# Test whether any array element along a given axis evaluates to True.
numpy.core.numeric.any

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
numpy.core.numeric.arange

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arccos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arccosh

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arcsin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arcsinh

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arctan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arctan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.arctanh

# Returns the indices of the maximum values along an axis.
numpy.core.numeric.argmax

# Returns the indices of the minimum values along an axis.
numpy.core.numeric.argmin

# Perform an indirect partition along the given axis using the
numpy.core.numeric.argpartition

# Returns the indices that would sort an array.
numpy.core.numeric.argsort

# Find the indices of array elements that are non-zero, grouped by element.
numpy.core.numeric.argwhere

# Round an array to the given number of decimals.
numpy.core.numeric.around

# array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
numpy.core.numeric.array

# Return a string representation of an array.
numpy.core.numeric.array2string

# True if two arrays have the same shape and elements, False otherwise.
numpy.core.numeric.array_equal

# Returns True if input arrays are shape consistent and all elements equal.
numpy.core.numeric.array_equiv

# Return the string representation of an array.
numpy.core.numeric.array_repr

# Return a string representation of the data in an array.
numpy.core.numeric.array_str

# asanyarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.core.numeric.asanyarray

# asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.core.numeric.asarray

# ascontiguousarray(a, dtype=None, *, like=None)
numpy.core.numeric.ascontiguousarray

# asfortranarray(a, dtype=None, *, like=None)
numpy.core.numeric.asfortranarray

# Copies an array to a specified data type.
numpy.core.numeric.astype

# Return a string representation of a number in the given base system.
numpy.core.numeric.base_repr

# Return the binary representation of the input number as a string.
numpy.core.numeric.binary_repr

# bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.bitwise_and

# bitwise_count(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.bitwise_count

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.bitwise_not

# bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.bitwise_or

# bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.bitwise_xor

# Boolean type (True or False), stored as a byte.
numpy.core.numeric.bool

# Boolean type (True or False), stored as a byte.
numpy.core.numeric.bool_

# Produce an object that mimics broadcasting.
numpy.core.numeric.broadcast

# busday_count(
numpy.core.numeric.busday_count

# busday_offset(
numpy.core.numeric.busday_offset

# busdaycalendar(weekmask='1111100', holidays=None)
numpy.core.numeric.busdaycalendar

# Signed integer type, compatible with C ``char``.
numpy.core.numeric.byte

# A byte string.
numpy.core.numeric.bytes_

# can_cast(from_, to, casting='safe')
numpy.core.numeric.can_cast

# cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.cbrt

# Complex number type composed of two double-precision floating-point
numpy.core.numeric.cdouble

# ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.ceil

# Abstract base class of all character string scalar types.
numpy.core.numeric.character

# Construct an array from an index array and a list of arrays to choose from.
numpy.core.numeric.choose

# Clip (limit) the values in an array.
numpy.core.numeric.clip

# Complex number type composed of two extended-precision floating-point
numpy.core.numeric.clongdouble

# Complex number type composed of two double-precision floating-point
numpy.core.numeric.complex128

# Complex number type composed of two extended-precision floating-point
numpy.core.numeric.complex256

# Complex number type composed of two single-precision floating-point
numpy.core.numeric.complex64

# Abstract base class of all complex number scalar types that are made up of
numpy.core.numeric.complexfloating

# Return selected slices of an array along given axis.
numpy.core.numeric.compress

# concatenate(
numpy.core.numeric.concatenate

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.conj

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.conjugate

# Returns the discrete, linear convolution of two one-dimensional sequences.
numpy.core.numeric.convolve

# copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.copysign

# copyto(dst, src, casting='same_kind', where=True)
numpy.core.numeric.copyto

# Cross-correlation of two 1-dimensional sequences.
numpy.core.numeric.correlate

# cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.cos

# cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.cosh

# Counts the number of non-zero values in the array ``a``.
numpy.core.numeric.count_nonzero

# Return the cross product of two (arrays of) vectors.
numpy.core.numeric.cross

# Complex number type composed of two single-precision floating-point
numpy.core.numeric.csingle

# Return the cumulative product of elements along a given axis.
numpy.core.numeric.cumprod

# Return the cumulative sum of the elements along a given axis.
numpy.core.numeric.cumsum

# Return the cumulative product of elements along a given axis.
numpy.core.numeric.cumulative_prod

# Return the cumulative sum of the elements along a given axis.
numpy.core.numeric.cumulative_sum

# If created from a 64-bit integer, it represents an offset from
numpy.core.numeric.datetime64

# datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
numpy.core.numeric.datetime_as_string

# datetime_data(dtype, /)
numpy.core.numeric.datetime_data

# deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.deg2rad

# degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.degrees

# Return specified diagonals.
numpy.core.numeric.diagonal

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.divide

# divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.divmod

# dot(a, b, out=None)
numpy.core.numeric.dot

# Double-precision floating-point number type, compatible with Python
numpy.core.numeric.double

# dtype(dtype, align=False, copy=False, [metadata])
numpy.core.numeric.dtype

# Convert a string or number to a floating-point number, if possible.
numpy.core.numeric.e

# empty(shape, dtype=float, order='C', *, device=None, like=None)
numpy.core.numeric.empty

# empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *,
numpy.core.numeric.empty_like

# equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.equal

# errstate(**kwargs)
numpy.core.numeric.errstate

# Convert a string or number to a floating-point number, if possible.
numpy.core.numeric.euler_gamma

# exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.exp

# exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.exp2

# expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.expm1

# fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.fabs

# Flat iterator object to iterate over arrays.
numpy.core.numeric.flatiter

# Return indices that are non-zero in the flattened version of a.
numpy.core.numeric.flatnonzero

# Abstract base class of all scalar types without predefined length.
numpy.core.numeric.flexible

# Extended-precision floating-point number type, compatible with C
numpy.core.numeric.float128

# Half-precision floating-point number type.
numpy.core.numeric.float16

# Single-precision floating-point number type, compatible with C ``float``.
numpy.core.numeric.float32

# Double-precision floating-point number type, compatible with Python
numpy.core.numeric.float64

# float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.float_power

# Abstract base class of all floating-point scalar types.
numpy.core.numeric.floating

# floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.floor

# floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.floor_divide

# fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.fmax

# fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.fmin

# fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.fmod

# Format a floating-point scalar as a decimal string in positional notation.
numpy.core.numeric.format_float_positional

# Format a floating-point scalar as a decimal string in scientific notation.
numpy.core.numeric.format_float_scientific

# frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.frexp

# from_dlpack(x, /, *, device=None, copy=None)
numpy.core.numeric.from_dlpack

# frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)
numpy.core.numeric.frombuffer

# fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None)
numpy.core.numeric.fromfile

# Construct an array by executing a function over each coordinate.
numpy.core.numeric.fromfunction

# fromiter(iter, dtype, count=-1, *, like=None)
numpy.core.numeric.fromiter

# frompyfunc(func, /, nin, nout, *[, identity])
numpy.core.numeric.frompyfunc

# fromstring(string, dtype=float, count=-1, *, sep, like=None)
numpy.core.numeric.fromstring

# Return a new array of given shape and type, filled with `fill_value`.
numpy.core.numeric.full

# Return a full array with the same shape and type as a given array.
numpy.core.numeric.full_like

# gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.gcd

# Base class for numpy scalar types.
numpy.core.numeric.generic

# Return the current print options.
numpy.core.numeric.get_printoptions

# Return the size of the buffer used in ufuncs.
numpy.core.numeric.getbufsize

# Get the current way of handling floating-point errors.
numpy.core.numeric.geterr

# Return the current callback function used on floating-point errors.
numpy.core.numeric.geterrcall

# greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.greater

# greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.greater_equal

# Half-precision floating-point number type.
numpy.core.numeric.half

# heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.heaviside

# hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.hypot

# Return the identity array.
numpy.core.numeric.identity

# Return an array representing the indices of a grid.
numpy.core.numeric.indices

# Abstract base class of all numeric scalar types with a (potentially)
numpy.core.numeric.inexact

# Convert a string or number to a floating-point number, if possible.
numpy.core.numeric.inf

# inner(a, b, /)
numpy.core.numeric.inner

# Signed integer type, compatible with C ``short``.
numpy.core.numeric.int16

# Signed integer type, compatible with C ``int``.
numpy.core.numeric.int32

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.int64

# Signed integer type, compatible with C ``char``.
numpy.core.numeric.int8

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.int_

# Signed integer type, compatible with C ``int``.
numpy.core.numeric.intc

# Abstract base class of all integer scalar types.
numpy.core.numeric.integer

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.intp

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.invert

# is_busday(
numpy.core.numeric.is_busday

# Returns a boolean array where two arrays are element-wise equal within a
numpy.core.numeric.isclose

# Determine if a provided dtype is of a specified data type ``kind``.
numpy.core.numeric.isdtype

# isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.isfinite

# Check if the array is Fortran contiguous but *not* C contiguous.
numpy.core.numeric.isfortran

# isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.isinf

# isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.isnan

# isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.isnat

# Returns True if the type of `element` is a scalar type.
numpy.core.numeric.isscalar

# Returns True if first argument is a typecode lower/equal in type hierarchy.
numpy.core.numeric.issubdtype

# lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.lcm

# ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.ldexp

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.left_shift

# less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.less

# less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.less_equal

# lexsort(keys, axis=-1)
numpy.core.numeric.lexsort

# Returns True when the argument is true, False otherwise.
numpy.core.numeric.little_endian

# log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.log

# log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.log10

# log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.log1p

# log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.log2

# logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.logaddexp

# logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.logaddexp2

# logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.logical_and

# logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.logical_not

# logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.logical_or

# logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.logical_xor

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.long

# Extended-precision floating-point number type, compatible with C
numpy.core.numeric.longdouble

# Signed integer type, compatible with C ``long long``.
numpy.core.numeric.longlong

# matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.numeric.matmul

# Transposes a matrix (or a stack of matrices) ``x``.
numpy.core.numeric.matrix_transpose

# matvec(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.numeric.matvec

# Return the maximum of an array or maximum along an axis.
numpy.core.numeric.max

# maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.maximum

# may_share_memory(a, b, /, max_work=None)
numpy.core.numeric.may_share_memory

# Compute the arithmetic mean along the specified axis.
numpy.core.numeric.mean

# Return the minimum of an array or minimum along an axis.
numpy.core.numeric.min

# min_scalar_type(a, /)
numpy.core.numeric.min_scalar_type

# minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.minimum

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.mod

# modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.modf

# Move axes of an array to new positions.
numpy.core.numeric.moveaxis

# multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.multiply

# Convert a string or number to a floating-point number, if possible.
numpy.core.numeric.nan

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.core.numeric.ndarray

# Return the number of dimensions of an array.
numpy.core.numeric.ndim

# nditer(op, flags=None, op_flags=None, op_dtypes=None, order='K',
numpy.core.numeric.nditer

# negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.negative

# nested_iters(op, axes, flags=None, op_flags=None, op_dtypes=None,     order="K", casting="safe", buffersize=0)
numpy.core.numeric.nested_iters

# The type of the None singleton.
numpy.core.numeric.newaxis

# nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.nextafter

# Return the indices of the elements that are non-zero.
numpy.core.numeric.nonzero

# not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.not_equal

# Abstract base class of all numeric scalar types.
numpy.core.numeric.number

# Any Python object.
numpy.core.numeric.object_

# Return a new array of given shape and type, filled with ones.
numpy.core.numeric.ones

# Return an array of ones with the same shape and type as a given array.
numpy.core.numeric.ones_like

# Compute the outer product of two vectors.
numpy.core.numeric.outer

# Return a partitioned copy of an array.
numpy.core.numeric.partition

# Convert a string or number to a floating-point number, if possible.
numpy.core.numeric.pi

# positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.positive

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.power

# Context manager for setting print options.
numpy.core.numeric.printoptions

# Return the product of array elements over a given axis.
numpy.core.numeric.prod

# promote_types(type1, type2)
numpy.core.numeric.promote_types

# Range of values (maximum - minimum) along an axis.
numpy.core.numeric.ptp

# Replaces specified elements of an array with given values.
numpy.core.numeric.put

# putmask(a, mask, values)
numpy.core.numeric.putmask

# rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.rad2deg

# radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.radians

# Return a contiguous flattened array.
numpy.core.numeric.ravel

# reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.reciprocal

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.remainder

# Repeat each element of an array after themselves
numpy.core.numeric.repeat

# Return an ndarray of the provided type that satisfies requirements.
numpy.core.numeric.require

# Gives a new shape to an array without changing its data.
numpy.core.numeric.reshape

# Return a new array with the specified shape.
numpy.core.numeric.resize

# result_type(*arrays_and_dtypes)
numpy.core.numeric.result_type

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.right_shift

# rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.rint

# Roll array elements along a given axis.
numpy.core.numeric.roll

# Roll the specified axis backwards, until it lies in a given position.
numpy.core.numeric.rollaxis

# Evenly round to the given number of decimals.
numpy.core.numeric.round

# Find indices where elements should be inserted to maintain order.
numpy.core.numeric.searchsorted

# Set printing options.
numpy.core.numeric.set_printoptions

# Set the size of the buffer used in ufuncs.
numpy.core.numeric.setbufsize

# Set how floating-point errors are handled.
numpy.core.numeric.seterr

# Set the floating-point error callback function or log object.
numpy.core.numeric.seterrcall

# Return the shape of an array.
numpy.core.numeric.shape

# shares_memory(a, b, /, max_work=None)
numpy.core.numeric.shares_memory

# Signed integer type, compatible with C ``short``.
numpy.core.numeric.short

# sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.sign

# signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.signbit

# Abstract base class of all signed integer scalar types.
numpy.core.numeric.signedinteger

# sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.sin

# Single-precision floating-point number type, compatible with C ``float``.
numpy.core.numeric.single

# sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.sinh

# Return the number of elements along a given axis.
numpy.core.numeric.size

# Return a sorted copy of an array.
numpy.core.numeric.sort

# spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.spacing

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.sqrt

# square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.square

# Remove axes of length one from `a`.
numpy.core.numeric.squeeze

# Compute the standard deviation along the specified axis.
numpy.core.numeric.std

# A unicode string.
numpy.core.numeric.str_

# subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.subtract

# Sum of array elements over a given axis.
numpy.core.numeric.sum

# Interchange two axes of an array.
numpy.core.numeric.swapaxes

# Take elements from an array along an axis.
numpy.core.numeric.take

# tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.tan

# tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.tanh

# Compute tensor dot product along specified axes.
numpy.core.numeric.tensordot

# A timedelta stored as a 64-bit integer.
numpy.core.numeric.timedelta64

# Return the sum along diagonals of the array.
numpy.core.numeric.trace

# Returns an array with axes transposed.
numpy.core.numeric.transpose

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.true_divide

# trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.numeric.trunc

# dict() -> new empty dictionary
numpy.core.numeric.typecodes

# Unsigned integer type, compatible with C ``unsigned char``.
numpy.core.numeric.ubyte

# Functions that operate element by element on whole arrays.
numpy.core.numeric.ufunc

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.uint

# Unsigned integer type, compatible with C ``unsigned short``.
numpy.core.numeric.uint16

# Unsigned integer type, compatible with C ``unsigned int``.
numpy.core.numeric.uint32

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.uint64

# Unsigned integer type, compatible with C ``unsigned char``.
numpy.core.numeric.uint8

# Unsigned integer type, compatible with C ``unsigned int``.
numpy.core.numeric.uintc

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.uintp

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numeric.ulong

# Signed integer type, compatible with C ``unsigned long long``.
numpy.core.numeric.ulonglong

# Abstract base class of all unsigned integer scalar types.
numpy.core.numeric.unsignedinteger

# Unsigned integer type, compatible with C ``unsigned short``.
numpy.core.numeric.ushort

# Compute the variance along the specified axis.
numpy.core.numeric.var

# vdot(a, b, /)
numpy.core.numeric.vdot

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.numeric.vecdot

# vecmat(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.numeric.vecmat

# np.void(length_or_data, /, dtype=None)
numpy.core.numeric.void

# where(condition, [x, y], /)
numpy.core.numeric.where

# zeros(shape, dtype=float, order='C', *, like=None)
numpy.core.numeric.zeros

# Return an array of zeros with the same shape and type as a given array.
numpy.core.numeric.zeros_like

# Built-in immutable sequence.
numpy.core.numerictypes.ScalarType

# Boolean type (True or False), stored as a byte.
numpy.core.numerictypes.bool

# Boolean type (True or False), stored as a byte.
numpy.core.numerictypes.bool_

# busday_count(
numpy.core.numerictypes.busday_count

# busday_offset(
numpy.core.numerictypes.busday_offset

# busdaycalendar(weekmask='1111100', holidays=None)
numpy.core.numerictypes.busdaycalendar

# Signed integer type, compatible with C ``char``.
numpy.core.numerictypes.byte

# A byte string.
numpy.core.numerictypes.bytes_

# Complex number type composed of two double-precision floating-point
numpy.core.numerictypes.cdouble

# Abstract base class of all character string scalar types.
numpy.core.numerictypes.character

# Complex number type composed of two extended-precision floating-point
numpy.core.numerictypes.clongdouble

# Complex number type composed of two double-precision floating-point
numpy.core.numerictypes.complex128

# Complex number type composed of two extended-precision floating-point
numpy.core.numerictypes.complex256

# Complex number type composed of two single-precision floating-point
numpy.core.numerictypes.complex64

# Abstract base class of all complex number scalar types that are made up of
numpy.core.numerictypes.complexfloating

# Complex number type composed of two single-precision floating-point
numpy.core.numerictypes.csingle

# If created from a 64-bit integer, it represents an offset from
numpy.core.numerictypes.datetime64

# datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
numpy.core.numerictypes.datetime_as_string

# datetime_data(dtype, /)
numpy.core.numerictypes.datetime_data

# Double-precision floating-point number type, compatible with Python
numpy.core.numerictypes.double

# Abstract base class of all scalar types without predefined length.
numpy.core.numerictypes.flexible

# Extended-precision floating-point number type, compatible with C
numpy.core.numerictypes.float128

# Half-precision floating-point number type.
numpy.core.numerictypes.float16

# Single-precision floating-point number type, compatible with C ``float``.
numpy.core.numerictypes.float32

# Double-precision floating-point number type, compatible with Python
numpy.core.numerictypes.float64

# Abstract base class of all floating-point scalar types.
numpy.core.numerictypes.floating

# Base class for numpy scalar types.
numpy.core.numerictypes.generic

# Half-precision floating-point number type.
numpy.core.numerictypes.half

# Abstract base class of all numeric scalar types with a (potentially)
numpy.core.numerictypes.inexact

# Signed integer type, compatible with C ``short``.
numpy.core.numerictypes.int16

# Signed integer type, compatible with C ``int``.
numpy.core.numerictypes.int32

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.int64

# Signed integer type, compatible with C ``char``.
numpy.core.numerictypes.int8

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.int_

# Signed integer type, compatible with C ``int``.
numpy.core.numerictypes.intc

# Abstract base class of all integer scalar types.
numpy.core.numerictypes.integer

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.intp

# is_busday(
numpy.core.numerictypes.is_busday

# Determine if a provided dtype is of a specified data type ``kind``.
numpy.core.numerictypes.isdtype

# Returns True if first argument is a typecode lower/equal in type hierarchy.
numpy.core.numerictypes.issubdtype

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.long

# Extended-precision floating-point number type, compatible with C
numpy.core.numerictypes.longdouble

# Signed integer type, compatible with C ``long long``.
numpy.core.numerictypes.longlong

# Abstract base class of all numeric scalar types.
numpy.core.numerictypes.number

# Any Python object.
numpy.core.numerictypes.object_

# Signed integer type, compatible with C ``short``.
numpy.core.numerictypes.short

# Abstract base class of all signed integer scalar types.
numpy.core.numerictypes.signedinteger

# Single-precision floating-point number type, compatible with C ``float``.
numpy.core.numerictypes.single

# A unicode string.
numpy.core.numerictypes.str_

# A timedelta stored as a 64-bit integer.
numpy.core.numerictypes.timedelta64

# dict() -> new empty dictionary
numpy.core.numerictypes.typecodes

# Unsigned integer type, compatible with C ``unsigned char``.
numpy.core.numerictypes.ubyte

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.uint

# Unsigned integer type, compatible with C ``unsigned short``.
numpy.core.numerictypes.uint16

# Unsigned integer type, compatible with C ``unsigned int``.
numpy.core.numerictypes.uint32

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.uint64

# Unsigned integer type, compatible with C ``unsigned char``.
numpy.core.numerictypes.uint8

# Unsigned integer type, compatible with C ``unsigned int``.
numpy.core.numerictypes.uintc

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.uintp

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.core.numerictypes.ulong

# Signed integer type, compatible with C ``unsigned long long``.
numpy.core.numerictypes.ulonglong

# Abstract base class of all unsigned integer scalar types.
numpy.core.numerictypes.unsignedinteger

# Unsigned integer type, compatible with C ``unsigned short``.
numpy.core.numerictypes.ushort

# np.void(length_or_data, /, dtype=None)
numpy.core.numerictypes.void

# Construct a record array from a wide-variety of objects.
numpy.core.records.array

# Find duplication in a list, return a list of duplicated elements
numpy.core.records.find_duplicate

# Class to convert formats, names, titles description to a dtype.
numpy.core.records.format_parser

# Create a record array from a (flat) list of arrays
numpy.core.records.fromarrays

# Create an array from binary file data
numpy.core.records.fromfile

# Create a recarray from a list of records in text form.
numpy.core.records.fromrecords

# Create a record array from binary data
numpy.core.records.fromstring

# Construct an ndarray that allows field access using attributes.
numpy.core.records.recarray

# A data-type scalar that allows field access as attribute lookup.
numpy.core.records.record

# Convert inputs to arrays with at least one dimension.
numpy.core.shape_base.atleast_1d

# View inputs as arrays with at least two dimensions.
numpy.core.shape_base.atleast_2d

# View inputs as arrays with at least three dimensions.
numpy.core.shape_base.atleast_3d

# Assemble an nd-array from nested lists of blocks.
numpy.core.shape_base.block

# Stack arrays in sequence horizontally (column wise).
numpy.core.shape_base.hstack

# Join a sequence of arrays along a new axis.
numpy.core.shape_base.stack

# Split an array into a sequence of arrays along the given axis.
numpy.core.shape_base.unstack

# Stack arrays in sequence vertically (row wise).
numpy.core.shape_base.vstack

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.absolute

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.add

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arccos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arccosh

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arcsin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arcsinh

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arctan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arctan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.arctanh

# bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.bitwise_and

# bitwise_count(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.bitwise_count

# bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.bitwise_or

# bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.bitwise_xor

# cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.cbrt

# ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.ceil

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.conj

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.conjugate

# copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.copysign

# cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.cos

# cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.cosh

# deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.deg2rad

# degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.degrees

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.divide

# divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.divmod

# Convert a string or number to a floating-point number, if possible.
numpy.core.umath.e

# equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.equal

# Convert a string or number to a floating-point number, if possible.
numpy.core.umath.euler_gamma

# exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.exp

# exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.exp2

# expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.expm1

# fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.fabs

# float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.float_power

# floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.floor

# floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.floor_divide

# fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.fmax

# fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.fmin

# fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.fmod

# frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.frexp

# frompyfunc(func, /, nin, nout, *[, identity])
numpy.core.umath.frompyfunc

# gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.gcd

# greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.greater

# greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.greater_equal

# heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.heaviside

# hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.hypot

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.invert

# isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.isfinite

# isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.isinf

# isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.isnan

# isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.isnat

# lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.lcm

# ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.ldexp

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.left_shift

# less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.less

# less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.less_equal

# log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.log

# log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.log10

# log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.log1p

# log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.log2

# logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.logaddexp

# logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.logaddexp2

# logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.logical_and

# logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.logical_not

# logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.logical_or

# logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.logical_xor

# matvec(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.umath.matvec

# maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.maximum

# minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.minimum

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.mod

# modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.modf

# multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.multiply

# negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.negative

# nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.nextafter

# not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.not_equal

# Convert a string or number to a floating-point number, if possible.
numpy.core.umath.pi

# positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.positive

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.power

# rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.rad2deg

# radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.radians

# reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.reciprocal

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.remainder

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.right_shift

# rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.rint

# sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.sign

# signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.signbit

# sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.sin

# sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.sinh

# spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.spacing

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.sqrt

# square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.square

# subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.subtract

# tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.tan

# tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.tanh

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.true_divide

# trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.core.umath.trunc

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.umath.vecdot

# vecmat(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.core.umath.vecmat

# Create a numpy array from a ctypes array or POINTER.
numpy.ctypeslib._ctypeslib.as_array

# Create and return a ctypes object from a numpy array.  Actually
numpy.ctypeslib._ctypeslib.as_ctypes

# Convert a dtype into a ctypes type.
numpy.ctypeslib._ctypeslib.as_ctypes_type

numpy.ctypeslib._ctypeslib.c_intp

# It is possible to load a library using
numpy.ctypeslib._ctypeslib.load_library

# Array-checking restype/argtypes.
numpy.ctypeslib._ctypeslib.ndpointer

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.BoolDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.ByteDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.BytesDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.CLongDoubleDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Complex128DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Complex64DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.DateTime64DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Float16DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Float32DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Float64DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Int16DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Int32DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Int64DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.Int8DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.IntDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.LongDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.LongDoubleDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.LongLongDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.ObjectDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.ShortDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.StrDType

# StringDType(*, na_object=np._NoValue, coerce=True)
numpy.dtypes.StringDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.TimeDelta64DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UByteDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UInt16DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UInt32DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UInt64DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UInt8DType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UIntDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.ULongDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.ULongLongDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.UShortDType

# DType class corresponding to the scalar type and dtype of the same name.
numpy.dtypes.VoidDType

# Axis supplied was invalid.
numpy.exceptions.AxisError

# The warning raised when casting a complex dtype to a real dtype.
numpy.exceptions.ComplexWarning

# Multiple DTypes could not be converted to a common one.
numpy.exceptions.DTypePromotionError

# Module deprecation warning.
numpy.exceptions.ModuleDeprecationWarning

# ``max_work`` was exceeded.
numpy.exceptions.TooHardError

# Visible deprecation warning.
numpy.exceptions.VisibleDeprecationWarning

# Return the Discrete Fourier Transform sample frequencies.
numpy.fft._helper.fftfreq

# Shift the zero-frequency component to the center of the spectrum.
numpy.fft._helper.fftshift

# The inverse of `fftshift`. Although identical for even-length `x`, the
numpy.fft._helper.ifftshift

# Return the Discrete Fourier Transform sample frequencies
numpy.fft._helper.rfftfreq

# Compute the one-dimensional discrete Fourier Transform.
numpy.fft._pocketfft.fft

# Compute the 2-dimensional discrete Fourier Transform.
numpy.fft._pocketfft.fft2

# Compute the N-dimensional discrete Fourier Transform.
numpy.fft._pocketfft.fftn

# Compute the FFT of a signal that has Hermitian symmetry, i.e., a real
numpy.fft._pocketfft.hfft

# Compute the one-dimensional inverse discrete Fourier Transform.
numpy.fft._pocketfft.ifft

# Compute the 2-dimensional inverse discrete Fourier Transform.
numpy.fft._pocketfft.ifft2

# Compute the N-dimensional inverse discrete Fourier Transform.
numpy.fft._pocketfft.ifftn

# Compute the inverse FFT of a signal that has Hermitian symmetry.
numpy.fft._pocketfft.ihfft

# Computes the inverse of `rfft`.
numpy.fft._pocketfft.irfft

# Computes the inverse of `rfft2`.
numpy.fft._pocketfft.irfft2

# Computes the inverse of `rfftn`.
numpy.fft._pocketfft.irfftn

# Compute the one-dimensional discrete Fourier Transform for real input.
numpy.fft._pocketfft.rfft

# Compute the 2-dimensional FFT of a real array.
numpy.fft._pocketfft.rfft2

# Compute the N-dimensional discrete Fourier Transform for real input.
numpy.fft._pocketfft.rfftn

# fft(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.fft._pocketfft_umath.fft

# ifft(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.fft._pocketfft_umath.ifft

# irfft(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.fft._pocketfft_umath.irfft

# rfft_n_even(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.fft._pocketfft_umath.rfft_n_even

# rfft_n_odd(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.fft._pocketfft_umath.rfft_n_odd

# Return the Discrete Fourier Transform sample frequencies.
numpy.fft.helper.fftfreq

# Shift the zero-frequency component to the center of the spectrum.
numpy.fft.helper.fftshift

# The inverse of `fftshift`. Although identical for even-length `x`, the
numpy.fft.helper.ifftshift

# Return the Discrete Fourier Transform sample frequencies
numpy.fft.helper.rfftfreq

# Returns pointers to the end-points of an array.
numpy.lib._array_utils_impl.byte_bounds

# normalize_axis_index(axis, ndim, msg_prefix=None)
numpy.lib._array_utils_impl.normalize_axis_index

# Normalizes an axis argument into a tuple of non-negative integer axes.
numpy.lib._array_utils_impl.normalize_axis_tuple

# Pad an array.
numpy.lib._arraypad_impl.pad

# The differences between consecutive elements of an array.
numpy.lib._arraysetops_impl.ediff1d

# Test whether each element of a 1-D array is also present in a second array.
numpy.lib._arraysetops_impl.in1d

# Find the intersection of two arrays.
numpy.lib._arraysetops_impl.intersect1d

# Calculates ``element in test_elements``, broadcasting over `element` only.
numpy.lib._arraysetops_impl.isin

# Find the set difference of two arrays.
numpy.lib._arraysetops_impl.setdiff1d

# Find the set exclusive-or of two arrays.
numpy.lib._arraysetops_impl.setxor1d

# Find the union of two arrays.
numpy.lib._arraysetops_impl.union1d

# Find the unique elements of an array.
numpy.lib._arraysetops_impl.unique

# Find the unique elements of an array, and counts, inverse, and indices.
numpy.lib._arraysetops_impl.unique_all

# Find the unique elements and counts of an input array `x`.
numpy.lib._arraysetops_impl.unique_counts

# Find the unique elements of `x` and indices to reconstruct `x`.
numpy.lib._arraysetops_impl.unique_inverse

# Returns the unique elements of an input array `x`.
numpy.lib._arraysetops_impl.unique_values

# Buffered iterator for big arrays.
numpy.lib._arrayterator_impl.Arrayterator

# DataSource(destpath='.')
numpy.lib._datasource.DataSource

# Repository(baseurl, destpath='.')
numpy.lib._datasource.Repository

# Open `path` with `mode` and return the file object.
numpy.lib._datasource.open

# OS routines for NT or Posix depending on what system we're on.
numpy.lib._datasource.os

# Private decorator for overriding __module__ on a function or class.
numpy.lib._datasource.set_module

# Return the angle of the complex argument.
numpy.lib._function_base_impl.angle

# Append values to the end of an array.
numpy.lib._function_base_impl.append

# Convert the input to an array, checking for NaNs or Infs.
numpy.lib._function_base_impl.asarray_chkfinite

# Compute the weighted average along the specified axis.
numpy.lib._function_base_impl.average

# Return the Bartlett window.
numpy.lib._function_base_impl.bartlett

# bincount(x, /, weights=None, minlength=0)
numpy.lib._function_base_impl.bincount

# Return the Blackman window.
numpy.lib._function_base_impl.blackman

# Return an array copy of the given object.
numpy.lib._function_base_impl.copy

# Return Pearson product-moment correlation coefficients.
numpy.lib._function_base_impl.corrcoef

# Estimate a covariance matrix, given data and weights.
numpy.lib._function_base_impl.cov

# Return a new array with sub-arrays along an axis deleted. For a one
numpy.lib._function_base_impl.delete

# Calculate the n-th discrete difference along the given axis.
numpy.lib._function_base_impl.diff

# Return the indices of the bins to which each value in input array belongs.
numpy.lib._function_base_impl.digitize

# Return the elements of an array that satisfy some condition.
numpy.lib._function_base_impl.extract

# Reverse the order of elements in an array along the given axis.
numpy.lib._function_base_impl.flip

# Return the gradient of an N-dimensional array.
numpy.lib._function_base_impl.gradient

# Return the Hamming window.
numpy.lib._function_base_impl.hamming

# Return the Hanning window.
numpy.lib._function_base_impl.hanning

# Modified Bessel function of the first kind, order 0.
numpy.lib._function_base_impl.i0

# Insert values along the given axis before the given indices.
numpy.lib._function_base_impl.insert

# One-dimensional linear interpolation for monotonically increasing sample points.
numpy.lib._function_base_impl.interp

# Check whether or not an object can be iterated over.
numpy.lib._function_base_impl.iterable

# Return the Kaiser window.
numpy.lib._function_base_impl.kaiser

# Compute the median along the specified axis.
numpy.lib._function_base_impl.median

# Return a tuple of coordinate matrices from coordinate vectors.
numpy.lib._function_base_impl.meshgrid

# Compute the q-th percentile of the data along the specified axis.
numpy.lib._function_base_impl.percentile

# Evaluate a piecewise-defined function.
numpy.lib._function_base_impl.piecewise

# Change elements of an array based on conditional and input values.
numpy.lib._function_base_impl.place

# Compute the q-th quantile of the data along the specified axis.
numpy.lib._function_base_impl.quantile

# Rotate an array by 90 degrees in the plane specified by axes.
numpy.lib._function_base_impl.rot90

# Return an array drawn from elements in choicelist, depending on conditions.
numpy.lib._function_base_impl.select

# Return the normalized sinc function.
numpy.lib._function_base_impl.sinc

# Sort a complex array using the real part first, then the imaginary part.
numpy.lib._function_base_impl.sort_complex

# Integrate along the given axis using the composite trapezoidal rule.
numpy.lib._function_base_impl.trapezoid

# `trapz` is deprecated in NumPy 2.0.
numpy.lib._function_base_impl.trapz

# Remove values along a dimension which are zero along all other.
numpy.lib._function_base_impl.trim_zeros

# Unwrap by taking the complement of large deltas with respect to the period.
numpy.lib._function_base_impl.unwrap

# vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,
numpy.lib._function_base_impl.vectorize

# Compute the histogram of a dataset.
numpy.lib._histograms_impl.histogram

# Function to calculate only the edges of the bins used by the `histogram`
numpy.lib._histograms_impl.histogram_bin_edges

# Compute the multidimensional histogram of some data.
numpy.lib._histograms_impl.histogramdd

# Translates slice objects to concatenation along the second axis.
numpy.lib._index_tricks_impl.c_

# Return the indices to access the main diagonal of an array.
numpy.lib._index_tricks_impl.diag_indices

# Return the indices to access the main diagonal of an n-dimensional array.
numpy.lib._index_tricks_impl.diag_indices_from

# Fill the main diagonal of the given array of any dimensionality.
numpy.lib._index_tricks_impl.fill_diagonal

# A nicer way to build up index tuples for arrays.
numpy.lib._index_tricks_impl.index_exp

# Construct an open mesh from multiple sequences.
numpy.lib._index_tricks_impl.ix_

# An instance which returns a dense multi-dimensional "meshgrid".
numpy.lib._index_tricks_impl.mgrid

# Multidimensional index iterator.
numpy.lib._index_tricks_impl.ndenumerate

# An N-dimensional iterator object to index arrays.
numpy.lib._index_tricks_impl.ndindex

# An instance which returns an open multi-dimensional "meshgrid".
numpy.lib._index_tricks_impl.ogrid

# Translates slice objects to concatenation along the first axis.
numpy.lib._index_tricks_impl.r_

# ravel_multi_index(multi_index, dims, mode='raise', order='C')
numpy.lib._index_tricks_impl.ravel_multi_index

# A nicer way to build up index tuples for arrays.
numpy.lib._index_tricks_impl.s_

# unravel_index(indices, shape, order='C')
numpy.lib._index_tricks_impl.unravel_index

# Warning issued when a string converter has a problem.
numpy.lib._iotools.ConversionWarning

# Exception raised when an error occurs in a converter for string values.
numpy.lib._iotools.ConverterError

# Exception raised when an attempt is made to upgrade a locked converter.
numpy.lib._iotools.ConverterLockError

# Object to split a string at a given delimiter or at given places.
numpy.lib._iotools.LineSplitter

# Object to validate a list of strings to use as field names.
numpy.lib._iotools.NameValidator

# Factory class for function transforming a string into another object
numpy.lib._iotools.StringConverter

numpy.lib._iotools.asbytes

numpy.lib._iotools.asunicode

# Convenience function to create a `np.dtype` object.
numpy.lib._iotools.easy_dtype

# Unpack a structured data-type by collapsing nested fields and/or fields
numpy.lib._iotools.flatten_dtype

# Returns whether one or several fields of a dtype are nested.
numpy.lib._iotools.has_nested_fields

# Functional tools for creating and using iterators.
numpy.lib._iotools.itertools

# NumPy
numpy.lib._iotools.np

numpy.lib._iotools.nx

# Tries to transform a string supposed to represent a boolean to a boolean.
numpy.lib._iotools.str2bool

# Return the indices of the maximum values in the specified axis ignoring
numpy.lib._nanfunctions_impl.nanargmax

# Return the indices of the minimum values in the specified axis ignoring
numpy.lib._nanfunctions_impl.nanargmin

# Return the cumulative product of array elements over a given axis treating Not a
numpy.lib._nanfunctions_impl.nancumprod

# Return the cumulative sum of array elements over a given axis treating Not a
numpy.lib._nanfunctions_impl.nancumsum

# Return the maximum of an array or maximum along an axis, ignoring any
numpy.lib._nanfunctions_impl.nanmax

# Compute the arithmetic mean along the specified axis, ignoring NaNs.
numpy.lib._nanfunctions_impl.nanmean

# Compute the median along the specified axis, while ignoring NaNs.
numpy.lib._nanfunctions_impl.nanmedian

# Return minimum of an array or minimum along an axis, ignoring any NaNs.
numpy.lib._nanfunctions_impl.nanmin

# Compute the qth percentile of the data along the specified axis,
numpy.lib._nanfunctions_impl.nanpercentile

# Return the product of array elements over a given axis treating Not a
numpy.lib._nanfunctions_impl.nanprod

# Compute the qth quantile of the data along the specified axis,
numpy.lib._nanfunctions_impl.nanquantile

# Compute the standard deviation along the specified axis, while
numpy.lib._nanfunctions_impl.nanstd

# Return the sum of array elements over a given axis treating Not a
numpy.lib._nanfunctions_impl.nansum

# Compute the variance along the specified axis, while ignoring NaNs.
numpy.lib._nanfunctions_impl.nanvar

# Construct an array from a text file, using regular expression parsing.
numpy.lib._npyio_impl.fromregex

# Load data from a text file, with missing values handled as specified.
numpy.lib._npyio_impl.genfromtxt

# Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.
numpy.lib._npyio_impl.load

# Load data from a text file.
numpy.lib._npyio_impl.loadtxt

# packbits(a, /, axis=None, bitorder='big')
numpy.lib._npyio_impl.packbits

# Save an array to a binary file in NumPy ``.npy`` format.
numpy.lib._npyio_impl.save

# Save an array to a text file.
numpy.lib._npyio_impl.savetxt

# Save several arrays into a single file in uncompressed ``.npz`` format.
numpy.lib._npyio_impl.savez

# Save several arrays into a single file in compressed ``.npz`` format.
numpy.lib._npyio_impl.savez_compressed

# unpackbits(a, /, axis=None, count=None, bitorder='big')
numpy.lib._npyio_impl.unpackbits

# Find the coefficients of a polynomial with the given sequence of roots.
numpy.lib._polynomial_impl.poly

# A one-dimensional polynomial class.
numpy.lib._polynomial_impl.poly1d

# Find the sum of two polynomials.
numpy.lib._polynomial_impl.polyadd

# Return the derivative of the specified order of a polynomial.
numpy.lib._polynomial_impl.polyder

# Returns the quotient and remainder of polynomial division.
numpy.lib._polynomial_impl.polydiv

# Least squares polynomial fit.
numpy.lib._polynomial_impl.polyfit

# Return an antiderivative (indefinite integral) of a polynomial.
numpy.lib._polynomial_impl.polyint

# Find the product of two polynomials.
numpy.lib._polynomial_impl.polymul

# Difference (subtraction) of two polynomials.
numpy.lib._polynomial_impl.polysub

# Evaluate a polynomial at specific values.
numpy.lib._polynomial_impl.polyval

# Return the roots of a polynomial with coefficients given in p.
numpy.lib._polynomial_impl.roots

# Compute the inverse cosine of x.
numpy.lib._scimath_impl.arccos

# Compute the inverse sine of x.
numpy.lib._scimath_impl.arcsin

# Compute the inverse hyperbolic tangent of `x`.
numpy.lib._scimath_impl.arctanh

# Compute the natural logarithm of `x`.
numpy.lib._scimath_impl.log

# Compute the logarithm base 10 of `x`.
numpy.lib._scimath_impl.log10

# Compute the logarithm base 2 of `x`.
numpy.lib._scimath_impl.log2

# Take log base n of x.
numpy.lib._scimath_impl.logn

# Return x to the power p, (x**p).
numpy.lib._scimath_impl.power

# Compute the square root of x.
numpy.lib._scimath_impl.sqrt

# Apply a function to 1-D slices along the given axis.
numpy.lib._shape_base_impl.apply_along_axis

# Apply a function repeatedly over multiple axes.
numpy.lib._shape_base_impl.apply_over_axes

# Split an array into multiple sub-arrays.
numpy.lib._shape_base_impl.array_split

# Stack 1-D arrays as columns into a 2-D array.
numpy.lib._shape_base_impl.column_stack

# Split array into multiple sub-arrays along the 3rd axis (depth).
numpy.lib._shape_base_impl.dsplit

# Stack arrays in sequence depth wise (along third axis).
numpy.lib._shape_base_impl.dstack

# Expand the shape of an array.
numpy.lib._shape_base_impl.expand_dims

# Split an array into multiple sub-arrays horizontally (column-wise).
numpy.lib._shape_base_impl.hsplit

# Kronecker product of two arrays.
numpy.lib._shape_base_impl.kron

# Put values into the destination array by matching 1d index and data slices.
numpy.lib._shape_base_impl.put_along_axis

# Stack arrays in sequence vertically (row wise).
numpy.lib._shape_base_impl.row_stack

# Split an array into multiple sub-arrays as views into `ary`.
numpy.lib._shape_base_impl.split

# Take values from the input array by matching 1d index and data slices.
numpy.lib._shape_base_impl.take_along_axis

# Construct an array by repeating A the number of times given by reps.
numpy.lib._shape_base_impl.tile

# Split an array into multiple sub-arrays vertically (row-wise).
numpy.lib._shape_base_impl.vsplit

# Broadcast any number of arrays against each other.
numpy.lib._stride_tricks_impl.broadcast_arrays

# Broadcast the input shapes into a single shape.
numpy.lib._stride_tricks_impl.broadcast_shapes

# Broadcast an array to a new shape.
numpy.lib._stride_tricks_impl.broadcast_to

# Extract a diagonal or construct a diagonal array.
numpy.lib._twodim_base_impl.diag

# Create a two-dimensional array with the flattened input as a diagonal.
numpy.lib._twodim_base_impl.diagflat

# Return a 2-D array with ones on the diagonal and zeros elsewhere.
numpy.lib._twodim_base_impl.eye

# Reverse the order of elements along axis 1 (left/right).
numpy.lib._twodim_base_impl.fliplr

# Reverse the order of elements along axis 0 (up/down).
numpy.lib._twodim_base_impl.flipud

# Compute the bi-dimensional histogram of two data samples.
numpy.lib._twodim_base_impl.histogram2d

# Return the indices to access (n, n) arrays, given a masking function.
numpy.lib._twodim_base_impl.mask_indices

# An array with ones at and below the given diagonal and zeros elsewhere.
numpy.lib._twodim_base_impl.tri

# Lower triangle of an array.
numpy.lib._twodim_base_impl.tril

# Return the indices for the lower-triangle of an (n, m) array.
numpy.lib._twodim_base_impl.tril_indices

# Return the indices for the lower-triangle of arr.
numpy.lib._twodim_base_impl.tril_indices_from

# Upper triangle of an array.
numpy.lib._twodim_base_impl.triu

# Return the indices for the upper-triangle of an (n, m) array.
numpy.lib._twodim_base_impl.triu_indices

# Return the indices for the upper-triangle of arr.
numpy.lib._twodim_base_impl.triu_indices_from

# Generate a Vandermonde matrix.
numpy.lib._twodim_base_impl.vander

# Return a scalar type which is common to the input arrays.
numpy.lib._type_check_impl.common_type

# Return the imaginary part of the complex argument.
numpy.lib._type_check_impl.imag

# Returns a bool array, where True if input element is complex.
numpy.lib._type_check_impl.iscomplex

# Check for a complex type or an array of complex numbers.
numpy.lib._type_check_impl.iscomplexobj

# Returns a bool array, where True if input element is real.
numpy.lib._type_check_impl.isreal

# Return True if x is a not complex type or an array of complex numbers.
numpy.lib._type_check_impl.isrealobj

# Return the character for the minimum-size type to which given types can
numpy.lib._type_check_impl.mintypecode

# Replace NaN with zero and infinity with large finite numbers (default
numpy.lib._type_check_impl.nan_to_num

# Return the real part of the complex argument.
numpy.lib._type_check_impl.real

# If input is complex with all imaginary parts close to zero, return
numpy.lib._type_check_impl.real_if_close

# Return a description for the given data type code.
numpy.lib._type_check_impl.typename

# Round to nearest integer towards zero.
numpy.lib._ufunclike_impl.fix

# Test element-wise for negative infinity, return result as bool array.
numpy.lib._ufunclike_impl.isneginf

# Test element-wise for positive infinity, return result as bool array.
numpy.lib._ufunclike_impl.isposinf

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.absolute

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.add

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
numpy.lib._user_array_impl.arange

# array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
numpy.lib._user_array_impl.array

# asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.lib._user_array_impl.asarray

# bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.bitwise_and

# bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.bitwise_or

# bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.bitwise_xor

# container(data, dtype=None, copy=True)
numpy.lib._user_array_impl.container

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.divide

# equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.equal

# greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.greater

# greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.greater_equal

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.invert

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.left_shift

# less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.less

# less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.less_equal

# multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.multiply

# not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.not_equal

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.power

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.remainder

# Gives a new shape to an array without changing its data.
numpy.lib._user_array_impl.reshape

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.right_shift

# Private decorator for overriding __module__ on a function or class.
numpy.lib._user_array_impl.set_module

# Return the shape of an array.
numpy.lib._user_array_impl.shape

# sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.sin

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.sqrt

# subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.lib._user_array_impl.subtract

# Returns an array with axes transposed.
numpy.lib._user_array_impl.transpose

# Return the directory that contains the NumPy \*.h header files.
numpy.lib._utils_impl.get_include

# Get help information for an array, function, class, or module.
numpy.lib._utils_impl.info

# Print information about various resources in the system
numpy.lib._utils_impl.show_runtime

# Parse and compare numpy version strings.
numpy.lib._version.NumpyVersion

# Returns pointers to the end-points of an array.
numpy.lib.array_utils.byte_bounds

# normalize_axis_index(axis, ndim, msg_prefix=None)
numpy.lib.array_utils.normalize_axis_index

# Normalizes an axis argument into a tuple of non-negative integer axes.
numpy.lib.array_utils.normalize_axis_tuple

# Returns a dictionary containing the currently supported CPU dispatched
numpy.lib.introspect.opt_func_info

# Mixin defining all operator special methods using __array_ufunc__.
numpy.lib.mixins.NDArrayOperatorsMixin

# DataSource(destpath='.')
numpy.lib.npyio.DataSource

# NpzFile(fid)
numpy.lib.npyio.NpzFile

# Add new fields to an existing array.
numpy.lib.recfunctions.append_fields

# Apply function 'func' as a reduction across fields of a structured array.
numpy.lib.recfunctions.apply_along_fields

# Assigns values from one structured array to another by field name.
numpy.lib.recfunctions.assign_fields_by_name

# Return a new array with fields in `drop_names` dropped.
numpy.lib.recfunctions.drop_fields

# Find the duplicates in a structured array along a given key
numpy.lib.recfunctions.find_duplicates

# Flatten a structured data-type description.
numpy.lib.recfunctions.flatten_descr

# Returns a dictionary with fields indexing lists of their parent fields.
numpy.lib.recfunctions.get_fieldstructure

# Returns the field names of the input datatype as a tuple. Input datatype
numpy.lib.recfunctions.get_names

# Returns the field names of the input datatype as a tuple. Input datatype
numpy.lib.recfunctions.get_names_flat

# Join arrays `r1` and `r2` on key `key`.
numpy.lib.recfunctions.join_by

# Merge arrays field by field.
numpy.lib.recfunctions.merge_arrays

# Add new fields to an existing array.
numpy.lib.recfunctions.rec_append_fields

# Returns a new numpy.recarray with fields in `drop_names` dropped.
numpy.lib.recfunctions.rec_drop_fields

# Join arrays `r1` and `r2` on keys.
numpy.lib.recfunctions.rec_join

# Fills fields from output with fields from input,
numpy.lib.recfunctions.recursive_fill_fields

# Rename the fields from a flexible-datatype ndarray or recarray.
numpy.lib.recfunctions.rename_fields

# Re-pack the fields of a structured array or dtype in memory.
numpy.lib.recfunctions.repack_fields

# Casts a structured array to a new dtype using assignment by field-name.
numpy.lib.recfunctions.require_fields

# Superposes arrays fields by fields
numpy.lib.recfunctions.stack_arrays

# Converts an n-D structured array into an (n+1)-D unstructured array.
numpy.lib.recfunctions.structured_to_unstructured

# Converts an n-D unstructured array into an (n-1)-D structured array.
numpy.lib.recfunctions.unstructured_to_structured

# Compute the inverse cosine of x.
numpy.lib.scimath.arccos

# Compute the inverse sine of x.
numpy.lib.scimath.arcsin

# Compute the inverse hyperbolic tangent of `x`.
numpy.lib.scimath.arctanh

# Compute the natural logarithm of `x`.
numpy.lib.scimath.log

# Compute the logarithm base 10 of `x`.
numpy.lib.scimath.log10

# Compute the logarithm base 2 of `x`.
numpy.lib.scimath.log2

# Take log base n of x.
numpy.lib.scimath.logn

# Return x to the power p, (x**p).
numpy.lib.scimath.power

# Compute the square root of x.
numpy.lib.scimath.sqrt

# Create a view into the array with the given shape and strides.
numpy.lib.stride_tricks.as_strided

# Create a sliding window view into the array with the given window shape.
numpy.lib.stride_tricks.sliding_window_view

# container(data, dtype=None, copy=True)
numpy.lib.user_array.container

# Generic Python-exception-derived object raised by linalg functions.
numpy.linalg._linalg.LinAlgError

# Cholesky decomposition.
numpy.linalg._linalg.cholesky

# Compute the condition number of a matrix.
numpy.linalg._linalg.cond

# Returns the cross product of 3-element vectors.
numpy.linalg._linalg.cross

# Compute the determinant of an array.
numpy.linalg._linalg.det

# Returns specified diagonals of a matrix (or a stack of matrices) ``x``.
numpy.linalg._linalg.diagonal

# Compute the eigenvalues and right eigenvectors of a square array.
numpy.linalg._linalg.eig

# Return the eigenvalues and eigenvectors of a complex Hermitian
numpy.linalg._linalg.eigh

# Compute the eigenvalues of a general matrix.
numpy.linalg._linalg.eigvals

# Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
numpy.linalg._linalg.eigvalsh

# Compute the inverse of a matrix.
numpy.linalg._linalg.inv

# Return the least-squares solution to a linear matrix equation.
numpy.linalg._linalg.lstsq

# Computes the matrix product.
numpy.linalg._linalg.matmul

# Computes the matrix norm of a matrix (or a stack of matrices) ``x``.
numpy.linalg._linalg.matrix_norm

# Raise a square matrix to the (integer) power `n`.
numpy.linalg._linalg.matrix_power

# Return matrix rank of array using SVD method
numpy.linalg._linalg.matrix_rank

# Transposes a matrix (or a stack of matrices) ``x``.
numpy.linalg._linalg.matrix_transpose

# Compute the dot product of two or more arrays in a single function call,
numpy.linalg._linalg.multi_dot

# Matrix or vector norm.
numpy.linalg._linalg.norm

# Compute the outer product of two vectors.
numpy.linalg._linalg.outer

# Compute the (Moore-Penrose) pseudo-inverse of a matrix.
numpy.linalg._linalg.pinv

# Compute the qr factorization of a matrix.
numpy.linalg._linalg.qr

# Compute the sign and (natural) logarithm of the determinant of an array.
numpy.linalg._linalg.slogdet

# Solve a linear matrix equation, or system of linear scalar equations.
numpy.linalg._linalg.solve

# Singular Value Decomposition.
numpy.linalg._linalg.svd

# Returns the singular values of a matrix (or a stack of matrices) ``x``.
numpy.linalg._linalg.svdvals

# Compute tensor dot product along specified axes.
numpy.linalg._linalg.tensordot

# Compute the 'inverse' of an N-dimensional array.
numpy.linalg._linalg.tensorinv

# Solve the tensor equation ``a x = b`` for x.
numpy.linalg._linalg.tensorsolve

# Returns the sum along the specified diagonals of a matrix
numpy.linalg._linalg.trace

# Computes the vector dot product.
numpy.linalg._linalg.vecdot

# Computes the vector norm of a vector (or batch of vectors) ``x``.
numpy.linalg._linalg.vector_norm

# cholesky_lo(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.cholesky_lo

# cholesky_up(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.cholesky_up

# det(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.det

# eig(x[, out1, out2], / [, out=(None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.eig

# eigh_lo(x[, out1, out2], / [, out=(None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.eigh_lo

# eigh_up(x[, out1, out2], / [, out=(None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.eigh_up

# eigvals(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.eigvals

# eigvalsh_lo(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.eigvalsh_lo

# eigvalsh_up(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.eigvalsh_up

# inv(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.inv

# lstsq(x1, x2, x3[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.lstsq

# qr_complete(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.qr_complete

# qr_r_raw(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.qr_r_raw

# qr_reduced(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.qr_reduced

# slogdet(x[, out1, out2], / [, out=(None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.slogdet

# solve(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.solve

# solve1(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.solve1

# svd(x, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.svd

# svd_f(x[, out1, out2, out3], / [, out=(None, None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.svd_f

# svd_s(x[, out1, out2, out3], / [, out=(None, None, None)], *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.linalg._umath_linalg.svd_s

numpy.linalg.lapack_lite.LapackError

numpy.linalg.lapack_lite.dgelsd

numpy.linalg.lapack_lite.dgeqrf

numpy.linalg.lapack_lite.dorgqr

numpy.linalg.lapack_lite.xerbla

numpy.linalg.lapack_lite.zgelsd

numpy.linalg.lapack_lite.zgeqrf

numpy.linalg.lapack_lite.zungqr

# Generic Python-exception-derived object raised by linalg functions.
numpy.linalg.linalg.LinAlgError

# Cholesky decomposition.
numpy.linalg.linalg.cholesky

# Compute the condition number of a matrix.
numpy.linalg.linalg.cond

# Returns the cross product of 3-element vectors.
numpy.linalg.linalg.cross

# Compute the determinant of an array.
numpy.linalg.linalg.det

# Returns specified diagonals of a matrix (or a stack of matrices) ``x``.
numpy.linalg.linalg.diagonal

# Compute the eigenvalues and right eigenvectors of a square array.
numpy.linalg.linalg.eig

# Return the eigenvalues and eigenvectors of a complex Hermitian
numpy.linalg.linalg.eigh

# Compute the eigenvalues of a general matrix.
numpy.linalg.linalg.eigvals

# Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
numpy.linalg.linalg.eigvalsh

# Compute the inverse of a matrix.
numpy.linalg.linalg.inv

# Return the least-squares solution to a linear matrix equation.
numpy.linalg.linalg.lstsq

# Computes the matrix product.
numpy.linalg.linalg.matmul

# Computes the matrix norm of a matrix (or a stack of matrices) ``x``.
numpy.linalg.linalg.matrix_norm

# Raise a square matrix to the (integer) power `n`.
numpy.linalg.linalg.matrix_power

# Return matrix rank of array using SVD method
numpy.linalg.linalg.matrix_rank

# Transposes a matrix (or a stack of matrices) ``x``.
numpy.linalg.linalg.matrix_transpose

# Compute the dot product of two or more arrays in a single function call,
numpy.linalg.linalg.multi_dot

# Matrix or vector norm.
numpy.linalg.linalg.norm

# Compute the outer product of two vectors.
numpy.linalg.linalg.outer

# Compute the (Moore-Penrose) pseudo-inverse of a matrix.
numpy.linalg.linalg.pinv

# Compute the qr factorization of a matrix.
numpy.linalg.linalg.qr

# Compute the sign and (natural) logarithm of the determinant of an array.
numpy.linalg.linalg.slogdet

# Solve a linear matrix equation, or system of linear scalar equations.
numpy.linalg.linalg.solve

# Singular Value Decomposition.
numpy.linalg.linalg.svd

# Returns the singular values of a matrix (or a stack of matrices) ``x``.
numpy.linalg.linalg.svdvals

# Compute tensor dot product along specified axes.
numpy.linalg.linalg.tensordot

# Compute the 'inverse' of an N-dimensional array.
numpy.linalg.linalg.tensorinv

# Solve the tensor equation ``a x = b`` for x.
numpy.linalg.linalg.tensorsolve

# Returns the sum along the specified diagonals of a matrix
numpy.linalg.linalg.trace

# Computes the vector dot product.
numpy.linalg.linalg.vecdot

# Computes the vector norm of a vector (or batch of vectors) ``x``.
numpy.linalg.linalg.vector_norm

# Class for masked array related errors.
numpy.ma.core.MAError

# Class for mask related errors.
numpy.ma.core.MaskError

# Boolean type (True or False), stored as a byte.
numpy.ma.core.MaskType

# An array class with possibly masked values.
numpy.ma.core.MaskedArray

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.abs

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.absolute

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.add

# all(self, axis=None, out=None, keepdims=<no value>)
numpy.ma.core.all

# Returns True if two arrays are element-wise equal within a tolerance.
numpy.ma.core.allclose

# Return True if all entries of a and b are equal, using
numpy.ma.core.allequal

# Reduce `target` along the given `axis`.
numpy.ma.core.alltrue

# Return the maximum of an array or maximum along an axis.
numpy.ma.core.amax

# Return the minimum of an array or minimum along an axis.
numpy.ma.core.amin

# Return the angle of the complex argument.
numpy.ma.core.angle

# anom(self, axis=None, dtype=None)
numpy.ma.core.anom

# anom(self, axis=None, dtype=None)
numpy.ma.core.anomalies

# any(self, axis=None, out=None, keepdims=<no value>)
numpy.ma.core.any

# Append values to the end of an array.
numpy.ma.core.append

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
numpy.ma.core.arange

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arccos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arccosh

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arcsin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arcsinh

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arctan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arctan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.arctanh

# argmax(self, axis=None, fill_value=None, out=None)
numpy.ma.core.argmax

# argmin(self, axis=None, fill_value=None, out=None)
numpy.ma.core.argmin

# Return an ndarray of indices that sort the array along the
numpy.ma.core.argsort

# Round an array to the given number of decimals.
numpy.ma.core.around

# An array class with possibly masked values.
numpy.ma.core.array

# Convert the input to a masked array, conserving subclasses.
numpy.ma.core.asanyarray

# Convert the input to a masked array of the given data-type.
numpy.ma.core.asarray

# bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.bitwise_and

# bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.bitwise_or

# bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.bitwise_xor

# Boolean type (True or False), stored as a byte.
numpy.ma.core.bool_

# ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.ceil

# Use an index array to construct a new array from a list of choices.
numpy.ma.core.choose

# Clip (limit) the values in an array.
numpy.ma.core.clip

# Return the common filling value of two masked arrays, if any.
numpy.ma.core.common_fill_value

# compress(self, condition, axis=None, out=None)
numpy.ma.core.compress

# Return all the non-masked data as a 1-D array.
numpy.ma.core.compressed

# Concatenate a sequence of arrays along the given axis.
numpy.ma.core.concatenate

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.conjugate

# Returns the discrete, linear convolution of two one-dimensional sequences.
numpy.ma.core.convolve

# copy(self, *args, **params)
numpy.ma.core.copy

# Cross-correlation of two 1-dimensional sequences.
numpy.ma.core.correlate

# cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.cos

# cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.cosh

# count(self, axis=None, keepdims=<no value>)
numpy.ma.core.count

# cumprod(self, axis=None, dtype=None, out=None)
numpy.ma.core.cumprod

# cumsum(self, axis=None, dtype=None, out=None)
numpy.ma.core.cumsum

# Return the default fill value for the argument object.
numpy.ma.core.default_fill_value

# Extract a diagonal or construct a diagonal array.
numpy.ma.core.diag

# diagonal(self, *args, **params)
numpy.ma.core.diagonal

# Calculate the n-th discrete difference along the given axis.
numpy.ma.core.diff

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.divide

# empty(shape, dtype=float, order='C', *, device=None, like=None)
numpy.ma.core.empty

# empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *,
numpy.ma.core.empty_like

# equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.equal

# exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.exp

# Expand the shape of an array.
numpy.ma.core.expand_dims

# fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.fabs

# Return input as an `~numpy.ndarray`, with masked values replaced by
numpy.ma.core.filled

# Return input with invalid data masked and replaced by a fill value.
numpy.ma.core.fix_invalid

# Returns a completely flattened version of the mask, where nested fields
numpy.ma.core.flatten_mask

# Flatten a structured array.
numpy.ma.core.flatten_structured_array

# floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.floor

# floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.floor_divide

# fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.fmod

# frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)
numpy.ma.core.frombuffer

# Build a masked array from a suitable flexible-type array.
numpy.ma.core.fromflex

# fromfunction(function, shape, **dtype)
numpy.ma.core.fromfunction

# Return the data of a masked array as an ndarray.
numpy.ma.core.getdata

# Return the mask of a masked array, or nomask.
numpy.ma.core.getmask

# Return the mask of a masked array, or full boolean array of False.
numpy.ma.core.getmaskarray

# greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.greater

# greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.greater_equal

# harden_mask(self)
numpy.ma.core.harden_mask

# hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.hypot

# identity(n, dtype=None)
numpy.ma.core.identity

# ids(self)
numpy.ma.core.ids

# indices(dimensions, dtype=<class 'int'>, sparse=False)
numpy.ma.core.indices

# inner(a, b, /)
numpy.ma.core.inner

# inner(a, b, /)
numpy.ma.core.innerproduct

# Test whether input is an instance of MaskedArray.
numpy.ma.core.isMA

# Test whether input is an instance of MaskedArray.
numpy.ma.core.isMaskedArray

# Return True if m is a valid, standard mask.
numpy.ma.core.is_mask

# Determine whether input has masked values.
numpy.ma.core.is_masked

# Test whether input is an instance of MaskedArray.
numpy.ma.core.isarray

# Shift the bits of an integer to the left.
numpy.ma.core.left_shift

# less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.less

# less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.less_equal

# log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.log

# log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.log10

# log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.log2

# logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.logical_and

# logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.logical_not

# logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.logical_or

# logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.logical_xor

# Create a boolean mask from an array.
numpy.ma.core.make_mask

# Construct a dtype description list from a given dtype.
numpy.ma.core.make_mask_descr

# Return a boolean mask of the given shape, filled with False.
numpy.ma.core.make_mask_none

# Combine two masks with the ``logical_or`` operator.
numpy.ma.core.mask_or

numpy.ma.core.masked

# An array class with possibly masked values.
numpy.ma.core.masked_array

# Mask an array where equal to a given value.
numpy.ma.core.masked_equal

# Mask an array where greater than a given value.
numpy.ma.core.masked_greater

# Mask an array where greater than or equal to a given value.
numpy.ma.core.masked_greater_equal

# Mask an array inside a given interval.
numpy.ma.core.masked_inside

# Mask an array where invalid values occur (NaNs or infs).
numpy.ma.core.masked_invalid

# Mask an array where less than a given value.
numpy.ma.core.masked_less

# Mask an array where less than or equal to a given value.
numpy.ma.core.masked_less_equal

# Mask an array where *not* equal to a given value.
numpy.ma.core.masked_not_equal

# Mask the array `x` where the data are exactly equal to value.
numpy.ma.core.masked_object

# Mask an array outside a given interval.
numpy.ma.core.masked_outside

# Handle the string used to represent missing data in a masked array.
numpy.ma.core.masked_print_option

numpy.ma.core.masked_singleton

# Mask using floating point equality.
numpy.ma.core.masked_values

# Mask an array where a condition is met.
numpy.ma.core.masked_where

# Return the maximum along a given axis.
numpy.ma.core.max

# maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.maximum

# Return the minimum value that can be represented by the dtype of an object.
numpy.ma.core.maximum_fill_value

# mean(self, axis=None, dtype=None, out=None, keepdims=<no value>)
numpy.ma.core.mean

# Return the minimum along a given axis.
numpy.ma.core.min

# minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.minimum

# Return the maximum value that can be represented by the dtype of an object.
numpy.ma.core.minimum_fill_value

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.mod

# multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.multiply

# Fake a 'void' object to use for masked array with structured dtypes.
numpy.ma.core.mvoid

# Return the number of dimensions of an array.
numpy.ma.core.ndim

# negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.negative

# Boolean type (True or False), stored as a byte.
numpy.ma.core.nomask

# nonzero(self)
numpy.ma.core.nonzero

# not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.not_equal

# ones(shape, dtype=None, order='C')
numpy.ma.core.ones

# Return an array of ones with the same shape and type as a given array.
numpy.ma.core.ones_like

# Compute the outer product of two vectors.
numpy.ma.core.outer

# Compute the outer product of two vectors.
numpy.ma.core.outerproduct

# Returns element-wise base array raised to power from second array.
numpy.ma.core.power

# prod(self, axis=None, dtype=None, out=None, keepdims=<no value>)
numpy.ma.core.prod

# product(self, axis=None, dtype=None, out=None, keepdims=<no value>)
numpy.ma.core.product

# Return (maximum - minimum) along the given dimension
numpy.ma.core.ptp

# Set storage-indexed locations to corresponding values.
numpy.ma.core.put

# Changes elements of an array based on conditional and input values.
numpy.ma.core.putmask

# ravel(self, order='C')
numpy.ma.core.ravel

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.remainder

# repeat(self, *args, **params)
numpy.ma.core.repeat

# Returns an array containing the same data with a new shape.
numpy.ma.core.reshape

# Return a new masked array with the specified size and shape.
numpy.ma.core.resize

# Shift the bits of an integer to the right.
numpy.ma.core.right_shift

# Return a copy of a, rounded to 'decimals' places.
numpy.ma.core.round

# Return a copy of a, rounded to 'decimals' places.
numpy.ma.core.round_

# Set the filling value of a, if a is a masked array.
numpy.ma.core.set_fill_value

# Return the shape of an array.
numpy.ma.core.shape

# sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.sin

# sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.sinh

# Return the number of elements along a given axis.
numpy.ma.core.size

# soften_mask(self)
numpy.ma.core.soften_mask

# Reduce `target` along the given `axis`.
numpy.ma.core.sometrue

# Return a sorted copy of the masked array.
numpy.ma.core.sort

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.sqrt

# Remove axes of length one from `a`.
numpy.ma.core.squeeze

# std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, mean=<no value>)
numpy.ma.core.std

# subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.subtract

# sum(self, axis=None, dtype=None, out=None, keepdims=<no value>)
numpy.ma.core.sum

# swapaxes(self, *args, **params)
numpy.ma.core.swapaxes

numpy.ma.core.take

# tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.tan

# tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.tanh

# trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None)
numpy.ma.core.trace

# Permute the dimensions of an array.
numpy.ma.core.transpose

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.ma.core.true_divide

# var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=<no value>, mean=<no value>)
numpy.ma.core.var

# Return a masked array with elements from `x` or `y`, depending on condition.
numpy.ma.core.where

# zeros(shape, dtype=float, order='C', *, like=None)
numpy.ma.core.zeros

# Return an array of zeros with the same shape and type as a given array.
numpy.ma.core.zeros_like

# Apply a function to 1-D slices along the given axis.
numpy.ma.extras.apply_along_axis

# Apply a function repeatedly over multiple axes.
numpy.ma.extras.apply_over_axes

# Convert inputs to arrays with at least one dimension.
numpy.ma.extras.atleast_1d

# View inputs as arrays with at least two dimensions.
numpy.ma.extras.atleast_2d

# View inputs as arrays with at least three dimensions.
numpy.ma.extras.atleast_3d

# Return the weighted average of array over the given axis.
numpy.ma.extras.average

# Returns a list of slices corresponding to the masked clumps of a 1-D array.
numpy.ma.extras.clump_masked

# Return list of slices corresponding to the unmasked clumps of a 1-D array.
numpy.ma.extras.clump_unmasked

# Stack 1-D arrays as columns into a 2-D array.
numpy.ma.extras.column_stack

# Suppress whole columns of a 2-D array that contain masked values.
numpy.ma.extras.compress_cols

# Suppress slices from multiple dimensions which contain masked values.
numpy.ma.extras.compress_nd

# Suppress the rows and/or columns of a 2-D array that contain
numpy.ma.extras.compress_rowcols

# Suppress whole rows of a 2-D array that contain masked values.
numpy.ma.extras.compress_rows

# Return Pearson product-moment correlation coefficients.
numpy.ma.extras.corrcoef

# Count the number of masked elements along the given axis.
numpy.ma.extras.count_masked

# Estimate the covariance matrix.
numpy.ma.extras.cov

# Create a two-dimensional array with the flattened input as a diagonal.
numpy.ma.extras.diagflat

# Return the dot product of two arrays.
numpy.ma.extras.dot

# Stack arrays in sequence depth wise (along third axis).
numpy.ma.extras.dstack

# Compute the differences between consecutive elements of an array.
numpy.ma.extras.ediff1d

# Find contiguous unmasked data in a masked array.
numpy.ma.extras.flatnotmasked_contiguous

# Find the indices of the first and last unmasked values.
numpy.ma.extras.flatnotmasked_edges

# Split an array into multiple sub-arrays horizontally (column-wise).
numpy.ma.extras.hsplit

# Stack arrays in sequence horizontally (column wise).
numpy.ma.extras.hstack

# Test whether each element of an array is also present in a second
numpy.ma.extras.in1d

# Returns the unique elements common to both arrays.
numpy.ma.extras.intersect1d

# Calculates `element in test_elements`, broadcasting over
numpy.ma.extras.isin

# Mask columns of a 2D array that contain masked values.
numpy.ma.extras.mask_cols

# Mask rows and/or columns of a 2D array that contain masked values.
numpy.ma.extras.mask_rowcols

# Mask rows of a 2D array that contain masked values.
numpy.ma.extras.mask_rows

# Empty masked array with all elements masked.
numpy.ma.extras.masked_all

# Empty masked array with the properties of an existing array.
numpy.ma.extras.masked_all_like

# Compute the median along the specified axis.
numpy.ma.extras.median

# Translate slice objects to concatenation along the first axis.
numpy.ma.extras.mr_

# Multidimensional index iterator.
numpy.ma.extras.ndenumerate

# Find contiguous unmasked data in a masked array along the given axis.
numpy.ma.extras.notmasked_contiguous

# Find the indices of the first and last unmasked values along an axis.
numpy.ma.extras.notmasked_edges

# Least squares polynomial fit.
numpy.ma.extras.polyfit

# Stack arrays in sequence vertically (row wise).
numpy.ma.extras.row_stack

# Set difference of 1D arrays with unique elements.
numpy.ma.extras.setdiff1d

# Set exclusive-or of 1-D arrays with unique elements.
numpy.ma.extras.setxor1d

# Join a sequence of arrays along a new axis.
numpy.ma.extras.stack

# Union of two arrays.
numpy.ma.extras.union1d

# Finds the unique elements of an array.
numpy.ma.extras.unique

# Generate a Vandermonde matrix.
numpy.ma.extras.vander

# Stack arrays in sequence vertically (row wise).
numpy.ma.extras.vstack

# Attributes
numpy.ma.mrecords.MaskedRecords

# Adds a new field to the masked record array
numpy.ma.mrecords.addfield

# Creates a mrecarray from a (flat) list of masked arrays.
numpy.ma.mrecords.fromarrays

# Creates a MaskedRecords from a list of records.
numpy.ma.mrecords.fromrecords

# Creates a mrecarray from data stored in the file `filename`.
numpy.ma.mrecords.fromtextfile

# Attributes
numpy.ma.mrecords.mrecarray

# A class whose instances are single test cases.
numpy.ma.testutils.TestCase

# Returns True if a and b are equal up to decimal places.
numpy.ma.testutils.almost

# Returns true if all components of a and b are equal to given tolerances.
numpy.ma.testutils.approx

# Assert that works in release mode.
numpy.ma.testutils.assert_

# Raises an AssertionError if two objects are not equal up to desired
numpy.ma.testutils.assert_allclose

# Asserts that two items are almost equal.
numpy.ma.testutils.assert_almost_equal

# Checks the equality of two masked arrays, up to given number odecimals.
numpy.ma.testutils.assert_array_almost_equal

# Compare two arrays relatively to their spacing.
numpy.ma.testutils.assert_array_almost_equal_nulp

# Checks the equality of two masked arrays, up to given number odecimals.
numpy.ma.testutils.assert_array_approx_equal

# Asserts that comparison between two masked arrays is satisfied.
numpy.ma.testutils.assert_array_compare

# Checks the elementwise equality of two masked arrays.
numpy.ma.testutils.assert_array_equal

# Checks that x is smaller than y elementwise.
numpy.ma.testutils.assert_array_less

# Asserts that two items are almost equal.
numpy.ma.testutils.assert_close

# Asserts that two items are equal.
numpy.ma.testutils.assert_equal

# Asserts that two records are equal.
numpy.ma.testutils.assert_equal_records

# Asserts the equality of two masks.
numpy.ma.testutils.assert_mask_equal

# Raises an assertion error if two items are equal.
numpy.ma.testutils.assert_not_equal

# assert_raises(exception_class, callable, *args, **kwargs)
numpy.ma.testutils.assert_raises

# Raises an assertion error if two masked arrays are not equal elementwise.
numpy.ma.testutils.fail_if_array_equal

# Boolean type (True or False), stored as a byte.
numpy.matlib.False_

# Built-in immutable sequence.
numpy.matlib.ScalarType

# Boolean type (True or False), stored as a byte.
numpy.matlib.True_

# Get the array API inspection namespace for NumPy.
numpy.matlib.__array_namespace_info__

# str(object='') -> str
numpy.matlib.__version__

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.abs

# absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.absolute

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.acos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.acosh

# add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.add

# Test whether all array elements along a given axis evaluate to True.
numpy.matlib.all

# Returns True if two arrays are element-wise equal within a tolerance.
numpy.matlib.allclose

# Return the maximum of an array or maximum along an axis.
numpy.matlib.amax

# Return the minimum of an array or minimum along an axis.
numpy.matlib.amin

# Return the angle of the complex argument.
numpy.matlib.angle

# Test whether any array element along a given axis evaluates to True.
numpy.matlib.any

# Append values to the end of an array.
numpy.matlib.append

# Apply a function to 1-D slices along the given axis.
numpy.matlib.apply_along_axis

# Apply a function repeatedly over multiple axes.
numpy.matlib.apply_over_axes

# arange([start,] stop[, step,], dtype=None, *, device=None, like=None)
numpy.matlib.arange

# arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arccos

# arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arccosh

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arcsin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arcsinh

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arctan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arctan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.arctanh

# Returns the indices of the maximum values along an axis.
numpy.matlib.argmax

# Returns the indices of the minimum values along an axis.
numpy.matlib.argmin

# Perform an indirect partition along the given axis using the
numpy.matlib.argpartition

# Returns the indices that would sort an array.
numpy.matlib.argsort

# Find the indices of array elements that are non-zero, grouped by element.
numpy.matlib.argwhere

# Round an array to the given number of decimals.
numpy.matlib.around

# array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,
numpy.matlib.array

# Return a string representation of an array.
numpy.matlib.array2string

# True if two arrays have the same shape and elements, False otherwise.
numpy.matlib.array_equal

# Returns True if input arrays are shape consistent and all elements equal.
numpy.matlib.array_equiv

# Return the string representation of an array.
numpy.matlib.array_repr

# Split an array into multiple sub-arrays.
numpy.matlib.array_split

# Return a string representation of the data in an array.
numpy.matlib.array_str

# asanyarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.matlib.asanyarray

# asarray(a, dtype=None, order=None, *, device=None, copy=None, like=None)
numpy.matlib.asarray

# Convert the input to an array, checking for NaNs or Infs.
numpy.matlib.asarray_chkfinite

# ascontiguousarray(a, dtype=None, *, like=None)
numpy.matlib.ascontiguousarray

# asfortranarray(a, dtype=None, *, like=None)
numpy.matlib.asfortranarray

# arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.asin

# arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.asinh

# Interpret the input as a matrix.
numpy.matlib.asmatrix

# Copies an array to a specified data type.
numpy.matlib.astype

# arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.atan

# arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.atan2

# arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.atanh

# Convert inputs to arrays with at least one dimension.
numpy.matlib.atleast_1d

# View inputs as arrays with at least two dimensions.
numpy.matlib.atleast_2d

# View inputs as arrays with at least three dimensions.
numpy.matlib.atleast_3d

# Compute the weighted average along the specified axis.
numpy.matlib.average

# Return the Bartlett window.
numpy.matlib.bartlett

# Return a string representation of a number in the given base system.
numpy.matlib.base_repr

# Return the binary representation of the input number as a string.
numpy.matlib.binary_repr

# bincount(x, /, weights=None, minlength=0)
numpy.matlib.bincount

# bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_and

# bitwise_count(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_count

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_invert

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_left_shift

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_not

# bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_or

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_right_shift

# bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.bitwise_xor

# Return the Blackman window.
numpy.matlib.blackman

# Assemble an nd-array from nested lists of blocks.
numpy.matlib.block

# Build a matrix object from a string, nested sequence, or array.
numpy.matlib.bmat

# Boolean type (True or False), stored as a byte.
numpy.matlib.bool

# Boolean type (True or False), stored as a byte.
numpy.matlib.bool_

# Produce an object that mimics broadcasting.
numpy.matlib.broadcast

# Broadcast any number of arrays against each other.
numpy.matlib.broadcast_arrays

# Broadcast the input shapes into a single shape.
numpy.matlib.broadcast_shapes

# Broadcast an array to a new shape.
numpy.matlib.broadcast_to

# busday_count(
numpy.matlib.busday_count

# busday_offset(
numpy.matlib.busday_offset

# busdaycalendar(weekmask='1111100', holidays=None)
numpy.matlib.busdaycalendar

# Signed integer type, compatible with C ``char``.
numpy.matlib.byte

# A byte string.
numpy.matlib.bytes_

# Translates slice objects to concatenation along the second axis.
numpy.matlib.c_

# can_cast(from_, to, casting='safe')
numpy.matlib.can_cast

# cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.cbrt

# Complex number type composed of two double-precision floating-point
numpy.matlib.cdouble

# ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.ceil

# This module contains a set of functions for vectorized string
numpy.matlib.char

# Abstract base class of all character string scalar types.
numpy.matlib.character

# Construct an array from an index array and a list of arrays to choose from.
numpy.matlib.choose

# Clip (limit) the values in an array.
numpy.matlib.clip

# Complex number type composed of two extended-precision floating-point
numpy.matlib.clongdouble

# Stack 1-D arrays as columns into a 2-D array.
numpy.matlib.column_stack

# Return a scalar type which is common to the input arrays.
numpy.matlib.common_type

# Complex number type composed of two double-precision floating-point
numpy.matlib.complex128

# Complex number type composed of two extended-precision floating-point
numpy.matlib.complex256

# Complex number type composed of two single-precision floating-point
numpy.matlib.complex64

# Abstract base class of all complex number scalar types that are made up of
numpy.matlib.complexfloating

# Return selected slices of an array along given axis.
numpy.matlib.compress

# concatenate(
numpy.matlib.concat

# concatenate(
numpy.matlib.concatenate

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.conj

# conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.conjugate

# Returns the discrete, linear convolution of two one-dimensional sequences.
numpy.matlib.convolve

# Return an array copy of the given object.
numpy.matlib.copy

# copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.copysign

# copyto(dst, src, casting='same_kind', where=True)
numpy.matlib.copyto

# The `numpy.core` submodule exists solely for backward compatibility
numpy.matlib.core

# Return Pearson product-moment correlation coefficients.
numpy.matlib.corrcoef

# Cross-correlation of two 1-dimensional sequences.
numpy.matlib.correlate

# cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.cos

# cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.cosh

# Counts the number of non-zero values in the array ``a``.
numpy.matlib.count_nonzero

# Estimate a covariance matrix, given data and weights.
numpy.matlib.cov

# Return the cross product of two (arrays of) vectors.
numpy.matlib.cross

# Complex number type composed of two single-precision floating-point
numpy.matlib.csingle

# ============================
numpy.matlib.ctypeslib

# Return the cumulative product of elements along a given axis.
numpy.matlib.cumprod

# Return the cumulative sum of the elements along a given axis.
numpy.matlib.cumsum

# Return the cumulative product of elements along a given axis.
numpy.matlib.cumulative_prod

# Return the cumulative sum of the elements along a given axis.
numpy.matlib.cumulative_sum

# If created from a 64-bit integer, it represents an offset from
numpy.matlib.datetime64

# datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
numpy.matlib.datetime_as_string

# datetime_data(dtype, /)
numpy.matlib.datetime_data

# deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.deg2rad

# degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.degrees

# Return a new array with sub-arrays along an axis deleted. For a one
numpy.matlib.delete

# Extract a diagonal or construct a diagonal array.
numpy.matlib.diag

# Return the indices to access the main diagonal of an array.
numpy.matlib.diag_indices

# Return the indices to access the main diagonal of an n-dimensional array.
numpy.matlib.diag_indices_from

# Create a two-dimensional array with the flattened input as a diagonal.
numpy.matlib.diagflat

# Return specified diagonals.
numpy.matlib.diagonal

# Calculate the n-th discrete difference along the given axis.
numpy.matlib.diff

# Return the indices of the bins to which each value in input array belongs.
numpy.matlib.digitize

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.divide

# divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.divmod

# dot(a, b, out=None)
numpy.matlib.dot

# Double-precision floating-point number type, compatible with Python
numpy.matlib.double

# Split array into multiple sub-arrays along the 3rd axis (depth).
numpy.matlib.dsplit

# Stack arrays in sequence depth wise (along third axis).
numpy.matlib.dstack

# dtype(dtype, align=False, copy=False, [metadata])
numpy.matlib.dtype

# This module is home to specific dtypes related functionality and their classes.
numpy.matlib.dtypes

# Convert a string or number to a floating-point number, if possible.
numpy.matlib.e

# The differences between consecutive elements of an array.
numpy.matlib.ediff1d

# einsum(subscripts, *operands, out=None, dtype=None, order='K',
numpy.matlib.einsum

# einsum_path(subscripts, *operands, optimize='greedy')
numpy.matlib.einsum_path

# Wrapper functions to more user-friendly calling of certain math functions
numpy.matlib.emath

# Return a new matrix of given shape and type, without initializing entries.
numpy.matlib.empty

# empty_like(prototype, dtype=None, order='K', subok=True, shape=None, *,
numpy.matlib.empty_like

# equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.equal

# errstate(**kwargs)
numpy.matlib.errstate

# Convert a string or number to a floating-point number, if possible.
numpy.matlib.euler_gamma

# Exceptions and Warnings
numpy.matlib.exceptions

# exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.exp

# exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.exp2

# Expand the shape of an array.
numpy.matlib.expand_dims

# expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.expm1

# Return the elements of an array that satisfy some condition.
numpy.matlib.extract

# Return a matrix with ones on the diagonal and zeros elsewhere.
numpy.matlib.eye

# Fortran to Python Interface Generator.
numpy.matlib.f2py

# fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.fabs

# Discrete Fourier Transform
numpy.matlib.fft

# Fill the main diagonal of the given array of any dimensionality.
numpy.matlib.fill_diagonal

# finfo(dtype)
numpy.matlib.finfo

# Round to nearest integer towards zero.
numpy.matlib.fix

# Flat iterator object to iterate over arrays.
numpy.matlib.flatiter

# Return indices that are non-zero in the flattened version of a.
numpy.matlib.flatnonzero

# Abstract base class of all scalar types without predefined length.
numpy.matlib.flexible

# Reverse the order of elements in an array along the given axis.
numpy.matlib.flip

# Reverse the order of elements along axis 1 (left/right).
numpy.matlib.fliplr

# Reverse the order of elements along axis 0 (up/down).
numpy.matlib.flipud

# Extended-precision floating-point number type, compatible with C
numpy.matlib.float128

# Half-precision floating-point number type.
numpy.matlib.float16

# Single-precision floating-point number type, compatible with C ``float``.
numpy.matlib.float32

# Double-precision floating-point number type, compatible with Python
numpy.matlib.float64

# float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.float_power

# Abstract base class of all floating-point scalar types.
numpy.matlib.floating

# floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.floor

# floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.floor_divide

# fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.fmax

# fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.fmin

# fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.fmod

# Format a floating-point scalar as a decimal string in positional notation.
numpy.matlib.format_float_positional

# Format a floating-point scalar as a decimal string in scientific notation.
numpy.matlib.format_float_scientific

# frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.frexp

# from_dlpack(x, /, *, device=None, copy=None)
numpy.matlib.from_dlpack

# frombuffer(buffer, dtype=float, count=-1, offset=0, *, like=None)
numpy.matlib.frombuffer

# fromfile(file, dtype=float, count=-1, sep='', offset=0, *, like=None)
numpy.matlib.fromfile

# Construct an array by executing a function over each coordinate.
numpy.matlib.fromfunction

# fromiter(iter, dtype, count=-1, *, like=None)
numpy.matlib.fromiter

# frompyfunc(func, /, nin, nout, *[, identity])
numpy.matlib.frompyfunc

# Construct an array from a text file, using regular expression parsing.
numpy.matlib.fromregex

# fromstring(string, dtype=float, count=-1, *, sep, like=None)
numpy.matlib.fromstring

# Return a new array of given shape and type, filled with `fill_value`.
numpy.matlib.full

# Return a full array with the same shape and type as a given array.
numpy.matlib.full_like

# gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.gcd

# Base class for numpy scalar types.
numpy.matlib.generic

# Load data from a text file, with missing values handled as specified.
numpy.matlib.genfromtxt

# Return numbers spaced evenly on a log scale (a geometric progression).
numpy.matlib.geomspace

# Return the directory that contains the NumPy \*.h header files.
numpy.matlib.get_include

# Return the current print options.
numpy.matlib.get_printoptions

# Return the size of the buffer used in ufuncs.
numpy.matlib.getbufsize

# Get the current way of handling floating-point errors.
numpy.matlib.geterr

# Return the current callback function used on floating-point errors.
numpy.matlib.geterrcall

# Return the gradient of an N-dimensional array.
numpy.matlib.gradient

# greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.greater

# greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.greater_equal

# Half-precision floating-point number type.
numpy.matlib.half

# Return the Hamming window.
numpy.matlib.hamming

# Return the Hanning window.
numpy.matlib.hanning

# heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.heaviside

# Compute the histogram of a dataset.
numpy.matlib.histogram

# Compute the bi-dimensional histogram of two data samples.
numpy.matlib.histogram2d

# Function to calculate only the edges of the bins used by the `histogram`
numpy.matlib.histogram_bin_edges

# Compute the multidimensional histogram of some data.
numpy.matlib.histogramdd

# Split an array into multiple sub-arrays horizontally (column-wise).
numpy.matlib.hsplit

# Stack arrays in sequence horizontally (column wise).
numpy.matlib.hstack

# hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.hypot

# Modified Bessel function of the first kind, order 0.
numpy.matlib.i0

# Returns the square identity matrix of given size.
numpy.matlib.identity

# iinfo(type)
numpy.matlib.iinfo

# Return the imaginary part of the complex argument.
numpy.matlib.imag

# Test whether each element of a 1-D array is also present in a second array.
numpy.matlib.in1d

# A nicer way to build up index tuples for arrays.
numpy.matlib.index_exp

# Return an array representing the indices of a grid.
numpy.matlib.indices

# Abstract base class of all numeric scalar types with a (potentially)
numpy.matlib.inexact

# Convert a string or number to a floating-point number, if possible.
numpy.matlib.inf

# Get help information for an array, function, class, or module.
numpy.matlib.info

# inner(a, b, /)
numpy.matlib.inner

# Insert values along the given axis before the given indices.
numpy.matlib.insert

# Signed integer type, compatible with C ``short``.
numpy.matlib.int16

# Signed integer type, compatible with C ``int``.
numpy.matlib.int32

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.int64

# Signed integer type, compatible with C ``char``.
numpy.matlib.int8

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.int_

# Signed integer type, compatible with C ``int``.
numpy.matlib.intc

# Abstract base class of all integer scalar types.
numpy.matlib.integer

# One-dimensional linear interpolation for monotonically increasing sample points.
numpy.matlib.interp

# Find the intersection of two arrays.
numpy.matlib.intersect1d

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.intp

# invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.invert

# is_busday(
numpy.matlib.is_busday

# Returns a boolean array where two arrays are element-wise equal within a
numpy.matlib.isclose

# Returns a bool array, where True if input element is complex.
numpy.matlib.iscomplex

# Check for a complex type or an array of complex numbers.
numpy.matlib.iscomplexobj

# Determine if a provided dtype is of a specified data type ``kind``.
numpy.matlib.isdtype

# isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.isfinite

# Check if the array is Fortran contiguous but *not* C contiguous.
numpy.matlib.isfortran

# Calculates ``element in test_elements``, broadcasting over `element` only.
numpy.matlib.isin

# isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.isinf

# isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.isnan

# isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.isnat

# Test element-wise for negative infinity, return result as bool array.
numpy.matlib.isneginf

# Test element-wise for positive infinity, return result as bool array.
numpy.matlib.isposinf

# Returns a bool array, where True if input element is real.
numpy.matlib.isreal

# Return True if x is a not complex type or an array of complex numbers.
numpy.matlib.isrealobj

# Returns True if the type of `element` is a scalar type.
numpy.matlib.isscalar

# Returns True if first argument is a typecode lower/equal in type hierarchy.
numpy.matlib.issubdtype

# Check whether or not an object can be iterated over.
numpy.matlib.iterable

# Construct an open mesh from multiple sequences.
numpy.matlib.ix_

# Return the Kaiser window.
numpy.matlib.kaiser

# Kronecker product of two arrays.
numpy.matlib.kron

# lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.lcm

# ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.ldexp

# left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.left_shift

# less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.less

# less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.less_equal

# lexsort(keys, axis=-1)
numpy.matlib.lexsort

# ``numpy.lib`` is mostly a space for implementing functions that don't
numpy.matlib.lib

# ``numpy.linalg``
numpy.matlib.linalg

# Return evenly spaced numbers over a specified interval.
numpy.matlib.linspace

# Returns True when the argument is true, False otherwise.
numpy.matlib.little_endian

# Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.
numpy.matlib.load

# Load data from a text file.
numpy.matlib.loadtxt

# log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.log

# log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.log10

# log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.log1p

# log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.log2

# logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.logaddexp

# logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.logaddexp2

# logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.logical_and

# logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.logical_not

# logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.logical_or

# logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.logical_xor

# Return numbers spaced evenly on a log scale.
numpy.matlib.logspace

# Default signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.long

# Extended-precision floating-point number type, compatible with C
numpy.matlib.longdouble

# Signed integer type, compatible with C ``long long``.
numpy.matlib.longlong

# =============
numpy.matlib.ma

# Return the indices to access (n, n) arrays, given a masking function.
numpy.matlib.mask_indices

# matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.matlib.matmul

# matrix(data, dtype=None, copy=True)
numpy.matlib.matrix

# Transposes a matrix (or a stack of matrices) ``x``.
numpy.matlib.matrix_transpose

# matvec(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.matlib.matvec

# Return the maximum of an array or maximum along an axis.
numpy.matlib.max

# maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.maximum

# may_share_memory(a, b, /, max_work=None)
numpy.matlib.may_share_memory

# Compute the arithmetic mean along the specified axis.
numpy.matlib.mean

# Compute the median along the specified axis.
numpy.matlib.median

# Create a memory-map to an array stored in a *binary* file on disk.
numpy.matlib.memmap

# Return a tuple of coordinate matrices from coordinate vectors.
numpy.matlib.meshgrid

# An instance which returns a dense multi-dimensional "meshgrid".
numpy.matlib.mgrid

# Return the minimum of an array or minimum along an axis.
numpy.matlib.min

# min_scalar_type(a, /)
numpy.matlib.min_scalar_type

# minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.minimum

# Return the character for the minimum-size type to which given types can
numpy.matlib.mintypecode

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.mod

# modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.modf

# Move axes of an array to new positions.
numpy.matlib.moveaxis

# multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.multiply

# Convert a string or number to a floating-point number, if possible.
numpy.matlib.nan

# Replace NaN with zero and infinity with large finite numbers (default
numpy.matlib.nan_to_num

# Return the indices of the maximum values in the specified axis ignoring
numpy.matlib.nanargmax

# Return the indices of the minimum values in the specified axis ignoring
numpy.matlib.nanargmin

# Return the cumulative product of array elements over a given axis treating Not a
numpy.matlib.nancumprod

# Return the cumulative sum of array elements over a given axis treating Not a
numpy.matlib.nancumsum

# Return the maximum of an array or maximum along an axis, ignoring any
numpy.matlib.nanmax

# Compute the arithmetic mean along the specified axis, ignoring NaNs.
numpy.matlib.nanmean

# Compute the median along the specified axis, while ignoring NaNs.
numpy.matlib.nanmedian

# Return minimum of an array or minimum along an axis, ignoring any NaNs.
numpy.matlib.nanmin

# Compute the qth percentile of the data along the specified axis,
numpy.matlib.nanpercentile

# Return the product of array elements over a given axis treating Not a
numpy.matlib.nanprod

# Compute the qth quantile of the data along the specified axis,
numpy.matlib.nanquantile

# Compute the standard deviation along the specified axis, while
numpy.matlib.nanstd

# Return the sum of array elements over a given axis treating Not a
numpy.matlib.nansum

# Compute the variance along the specified axis, while ignoring NaNs.
numpy.matlib.nanvar

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.matlib.ndarray

# Multidimensional index iterator.
numpy.matlib.ndenumerate

# Return the number of dimensions of an array.
numpy.matlib.ndim

# An N-dimensional iterator object to index arrays.
numpy.matlib.ndindex

# nditer(op, flags=None, op_flags=None, op_dtypes=None, order='K',
numpy.matlib.nditer

# negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.negative

# nested_iters(op, axes, flags=None, op_flags=None, op_dtypes=None,     order="K", casting="safe", buffersize=0)
numpy.matlib.nested_iters

# The type of the None singleton.
numpy.matlib.newaxis

# nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.nextafter

# Return the indices of the elements that are non-zero.
numpy.matlib.nonzero

# not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.not_equal

# Abstract base class of all numeric scalar types.
numpy.matlib.number

# Any Python object.
numpy.matlib.object_

# An instance which returns an open multi-dimensional "meshgrid".
numpy.matlib.ogrid

# Matrix of ones.
numpy.matlib.ones

# Return an array of ones with the same shape and type as a given array.
numpy.matlib.ones_like

# Compute the outer product of two vectors.
numpy.matlib.outer

# packbits(a, /, axis=None, bitorder='big')
numpy.matlib.packbits

# Pad an array.
numpy.matlib.pad

# Return a partitioned copy of an array.
numpy.matlib.partition

# Compute the q-th percentile of the data along the specified axis.
numpy.matlib.percentile

# Returns an array with axes transposed.
numpy.matlib.permute_dims

# Convert a string or number to a floating-point number, if possible.
numpy.matlib.pi

# Evaluate a piecewise-defined function.
numpy.matlib.piecewise

# Change elements of an array based on conditional and input values.
numpy.matlib.place

# Find the coefficients of a polynomial with the given sequence of roots.
numpy.matlib.poly

# A one-dimensional polynomial class.
numpy.matlib.poly1d

# Find the sum of two polynomials.
numpy.matlib.polyadd

# Return the derivative of the specified order of a polynomial.
numpy.matlib.polyder

# Returns the quotient and remainder of polynomial division.
numpy.matlib.polydiv

# Least squares polynomial fit.
numpy.matlib.polyfit

# Return an antiderivative (indefinite integral) of a polynomial.
numpy.matlib.polyint

# Find the product of two polynomials.
numpy.matlib.polymul

# A sub-package for efficiently dealing with polynomials.
numpy.matlib.polynomial

# Difference (subtraction) of two polynomials.
numpy.matlib.polysub

# Evaluate a polynomial at specific values.
numpy.matlib.polyval

# positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.positive

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.pow

# power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.power

# Context manager for setting print options.
numpy.matlib.printoptions

# Return the product of array elements over a given axis.
numpy.matlib.prod

# promote_types(type1, type2)
numpy.matlib.promote_types

# Range of values (maximum - minimum) along an axis.
numpy.matlib.ptp

# Replaces specified elements of an array with given values.
numpy.matlib.put

# Put values into the destination array by matching 1d index and data slices.
numpy.matlib.put_along_axis

# putmask(a, mask, values)
numpy.matlib.putmask

# Compute the q-th quantile of the data along the specified axis.
numpy.matlib.quantile

# Translates slice objects to concatenation along the first axis.
numpy.matlib.r_

# rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.rad2deg

# radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.radians

# Return a matrix of random values with given shape.
numpy.matlib.rand

# Return a random matrix with data from the "standard normal" distribution.
numpy.matlib.randn

# ========================
numpy.matlib.random

# Return a contiguous flattened array.
numpy.matlib.ravel

# ravel_multi_index(multi_index, dims, mode='raise', order='C')
numpy.matlib.ravel_multi_index

# Return the real part of the complex argument.
numpy.matlib.real

# If input is complex with all imaginary parts close to zero, return
numpy.matlib.real_if_close

# This module contains a set of functions for record arrays.
numpy.matlib.rec

# Construct an ndarray that allows field access using attributes.
numpy.matlib.recarray

# reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.reciprocal

# A data-type scalar that allows field access as attribute lookup.
numpy.matlib.record

# remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.remainder

# Repeat each element of an array after themselves
numpy.matlib.repeat

# Repeat a 0-D to 2-D array or matrix MxN times.
numpy.matlib.repmat

# Return an ndarray of the provided type that satisfies requirements.
numpy.matlib.require

# Gives a new shape to an array without changing its data.
numpy.matlib.reshape

# Return a new array with the specified shape.
numpy.matlib.resize

# result_type(*arrays_and_dtypes)
numpy.matlib.result_type

# right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.right_shift

# rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.rint

# Roll array elements along a given axis.
numpy.matlib.roll

# Roll the specified axis backwards, until it lies in a given position.
numpy.matlib.rollaxis

# Return the roots of a polynomial with coefficients given in p.
numpy.matlib.roots

# Rotate an array by 90 degrees in the plane specified by axes.
numpy.matlib.rot90

# Evenly round to the given number of decimals.
numpy.matlib.round

# Stack arrays in sequence vertically (row wise).
numpy.matlib.row_stack

# A nicer way to build up index tuples for arrays.
numpy.matlib.s_

# Save an array to a binary file in NumPy ``.npy`` format.
numpy.matlib.save

# Save an array to a text file.
numpy.matlib.savetxt

# Save several arrays into a single file in uncompressed ``.npz`` format.
numpy.matlib.savez

# Save several arrays into a single file in compressed ``.npz`` format.
numpy.matlib.savez_compressed

# dict() -> new empty dictionary
numpy.matlib.sctypeDict

# Find indices where elements should be inserted to maintain order.
numpy.matlib.searchsorted

# Return an array drawn from elements in choicelist, depending on conditions.
numpy.matlib.select

# Set printing options.
numpy.matlib.set_printoptions

# Set the size of the buffer used in ufuncs.
numpy.matlib.setbufsize

# Find the set difference of two arrays.
numpy.matlib.setdiff1d

# Set how floating-point errors are handled.
numpy.matlib.seterr

# Set the floating-point error callback function or log object.
numpy.matlib.seterrcall

# Find the set exclusive-or of two arrays.
numpy.matlib.setxor1d

# Return the shape of an array.
numpy.matlib.shape

# shares_memory(a, b, /, max_work=None)
numpy.matlib.shares_memory

# Signed integer type, compatible with C ``short``.
numpy.matlib.short

# Show libraries and system information on which NumPy was built
numpy.matlib.show_config

# Print information about various resources in the system
numpy.matlib.show_runtime

# sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.sign

# signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.signbit

# Abstract base class of all signed integer scalar types.
numpy.matlib.signedinteger

# sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.sin

# Return the normalized sinc function.
numpy.matlib.sinc

# Single-precision floating-point number type, compatible with C ``float``.
numpy.matlib.single

# sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.sinh

# Return the number of elements along a given axis.
numpy.matlib.size

# Return a sorted copy of an array.
numpy.matlib.sort

# Sort a complex array using the real part first, then the imaginary part.
numpy.matlib.sort_complex

# spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.spacing

# Split an array into multiple sub-arrays as views into `ary`.
numpy.matlib.split

# sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.sqrt

# square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.square

# Remove axes of length one from `a`.
numpy.matlib.squeeze

# Join a sequence of arrays along a new axis.
numpy.matlib.stack

# Compute the standard deviation along the specified axis.
numpy.matlib.std

# A unicode string.
numpy.matlib.str_

# This module contains a set of functions for vectorized string
numpy.matlib.strings

# subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.subtract

# Sum of array elements over a given axis.
numpy.matlib.sum

# Interchange two axes of an array.
numpy.matlib.swapaxes

# Take elements from an array along an axis.
numpy.matlib.take

# Take values from the input array by matching 1d index and data slices.
numpy.matlib.take_along_axis

# tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.tan

# tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.tanh

# Compute tensor dot product along specified axes.
numpy.matlib.tensordot

# Pytest test runner.
numpy.matlib.test

# Common test support for all numpy test scripts.
numpy.matlib.testing

# Construct an array by repeating A the number of times given by reps.
numpy.matlib.tile

# A timedelta stored as a 64-bit integer.
numpy.matlib.timedelta64

# Return the sum along diagonals of the array.
numpy.matlib.trace

# Returns an array with axes transposed.
numpy.matlib.transpose

# Integrate along the given axis using the composite trapezoidal rule.
numpy.matlib.trapezoid

# `trapz` is deprecated in NumPy 2.0.
numpy.matlib.trapz

# An array with ones at and below the given diagonal and zeros elsewhere.
numpy.matlib.tri

# Lower triangle of an array.
numpy.matlib.tril

# Return the indices for the lower-triangle of an (n, m) array.
numpy.matlib.tril_indices

# Return the indices for the lower-triangle of arr.
numpy.matlib.tril_indices_from

# Remove values along a dimension which are zero along all other.
numpy.matlib.trim_zeros

# Upper triangle of an array.
numpy.matlib.triu

# Return the indices for the upper-triangle of an (n, m) array.
numpy.matlib.triu_indices

# Return the indices for the upper-triangle of arr.
numpy.matlib.triu_indices_from

# divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.true_divide

# trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])
numpy.matlib.trunc

# dict() -> new empty dictionary
numpy.matlib.typecodes

# Return a description for the given data type code.
numpy.matlib.typename

# ============================
numpy.matlib.typing

# Unsigned integer type, compatible with C ``unsigned char``.
numpy.matlib.ubyte

# Functions that operate element by element on whole arrays.
numpy.matlib.ufunc

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.uint

# Unsigned integer type, compatible with C ``unsigned short``.
numpy.matlib.uint16

# Unsigned integer type, compatible with C ``unsigned int``.
numpy.matlib.uint32

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.uint64

# Unsigned integer type, compatible with C ``unsigned char``.
numpy.matlib.uint8

# Unsigned integer type, compatible with C ``unsigned int``.
numpy.matlib.uintc

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.uintp

# Unsigned signed integer type, 64bit on 64bit systems and 32bit on 32bit
numpy.matlib.ulong

# Signed integer type, compatible with C ``unsigned long long``.
numpy.matlib.ulonglong

# Find the union of two arrays.
numpy.matlib.union1d

# Find the unique elements of an array.
numpy.matlib.unique

# Find the unique elements of an array, and counts, inverse, and indices.
numpy.matlib.unique_all

# Find the unique elements and counts of an input array `x`.
numpy.matlib.unique_counts

# Find the unique elements of `x` and indices to reconstruct `x`.
numpy.matlib.unique_inverse

# Returns the unique elements of an input array `x`.
numpy.matlib.unique_values

# unpackbits(a, /, axis=None, count=None, bitorder='big')
numpy.matlib.unpackbits

# unravel_index(indices, shape, order='C')
numpy.matlib.unravel_index

# Abstract base class of all unsigned integer scalar types.
numpy.matlib.unsignedinteger

# Split an array into a sequence of arrays along the given axis.
numpy.matlib.unstack

# Unwrap by taking the complement of large deltas with respect to the period.
numpy.matlib.unwrap

# Unsigned integer type, compatible with C ``unsigned short``.
numpy.matlib.ushort

# Generate a Vandermonde matrix.
numpy.matlib.vander

# Compute the variance along the specified axis.
numpy.matlib.var

# vdot(a, b, /)
numpy.matlib.vdot

# vecdot(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.matlib.vecdot

# vecmat(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, axes, axis])
numpy.matlib.vecmat

# vectorize(pyfunc=np._NoValue, otypes=None, doc=None, excluded=None,
numpy.matlib.vectorize

# np.void(length_or_data, /, dtype=None)
numpy.matlib.void

# Split an array into multiple sub-arrays vertically (row-wise).
numpy.matlib.vsplit

# Stack arrays in sequence vertically (row wise).
numpy.matlib.vstack

# where(condition, [x, y], /)
numpy.matlib.where

# Return a matrix of given shape and type, filled with zeros.
numpy.matlib.zeros

# Return an array of zeros with the same shape and type as a given array.
numpy.matlib.zeros_like

# Interpret the input as a matrix.
numpy.matrixlib.defmatrix.asmatrix

# Build a matrix object from a string, nested sequence, or array.
numpy.matrixlib.defmatrix.bmat

# matrix(data, dtype=None, copy=True)
numpy.matrixlib.defmatrix.matrix

# An abstract base class for immutable series classes.
numpy.polynomial._polybase.ABCPolyBase

# A Chebyshev series class.
numpy.polynomial.chebyshev.Chebyshev

# Convert a Chebyshev series to a polynomial.
numpy.polynomial.chebyshev.cheb2poly

# Add one Chebyshev series to another.
numpy.polynomial.chebyshev.chebadd

# Return the scaled companion matrix of c.
numpy.polynomial.chebyshev.chebcompanion

# Differentiate a Chebyshev series.
numpy.polynomial.chebyshev.chebder

# Divide one Chebyshev series by another.
numpy.polynomial.chebyshev.chebdiv

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.chebyshev.chebdomain

# Least squares fit of Chebyshev series to data.
numpy.polynomial.chebyshev.chebfit

# Generate a Chebyshev series with given roots.
numpy.polynomial.chebyshev.chebfromroots

# Gauss-Chebyshev quadrature.
numpy.polynomial.chebyshev.chebgauss

# Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.
numpy.polynomial.chebyshev.chebgrid2d

# Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.
numpy.polynomial.chebyshev.chebgrid3d

# Integrate a Chebyshev series.
numpy.polynomial.chebyshev.chebint

# Interpolate a function at the Chebyshev points of the first kind.
numpy.polynomial.chebyshev.chebinterpolate

# Chebyshev series whose graph is a straight line.
numpy.polynomial.chebyshev.chebline

# Multiply one Chebyshev series by another.
numpy.polynomial.chebyshev.chebmul

# Multiply a Chebyshev series by x.
numpy.polynomial.chebyshev.chebmulx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.chebyshev.chebone

# Raise a Chebyshev series to a power.
numpy.polynomial.chebyshev.chebpow

# Chebyshev points of the first kind.
numpy.polynomial.chebyshev.chebpts1

# Chebyshev points of the second kind.
numpy.polynomial.chebyshev.chebpts2

# Compute the roots of a Chebyshev series.
numpy.polynomial.chebyshev.chebroots

# Subtract one Chebyshev series from another.
numpy.polynomial.chebyshev.chebsub

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.chebyshev.chebtrim

# Evaluate a Chebyshev series at points x.
numpy.polynomial.chebyshev.chebval

# Evaluate a 2-D Chebyshev series at points (x, y).
numpy.polynomial.chebyshev.chebval2d

# Evaluate a 3-D Chebyshev series at points (x, y, z).
numpy.polynomial.chebyshev.chebval3d

# Pseudo-Vandermonde matrix of given degree.
numpy.polynomial.chebyshev.chebvander

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.chebyshev.chebvander2d

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.chebyshev.chebvander3d

# The weight function of the Chebyshev polynomials.
numpy.polynomial.chebyshev.chebweight

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.chebyshev.chebx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.chebyshev.chebzero

# Convert a polynomial to a Chebyshev series.
numpy.polynomial.chebyshev.poly2cheb

# An Hermite series class.
numpy.polynomial.hermite.Hermite

# Convert a Hermite series to a polynomial.
numpy.polynomial.hermite.herm2poly

# Add one Hermite series to another.
numpy.polynomial.hermite.hermadd

# Return the scaled companion matrix of c.
numpy.polynomial.hermite.hermcompanion

# Differentiate a Hermite series.
numpy.polynomial.hermite.hermder

# Divide one Hermite series by another.
numpy.polynomial.hermite.hermdiv

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite.hermdomain

# Least squares fit of Hermite series to data.
numpy.polynomial.hermite.hermfit

# Generate a Hermite series with given roots.
numpy.polynomial.hermite.hermfromroots

# Gauss-Hermite quadrature.
numpy.polynomial.hermite.hermgauss

# Evaluate a 2-D Hermite series on the Cartesian product of x and y.
numpy.polynomial.hermite.hermgrid2d

# Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.
numpy.polynomial.hermite.hermgrid3d

# Integrate a Hermite series.
numpy.polynomial.hermite.hermint

# Hermite series whose graph is a straight line.
numpy.polynomial.hermite.hermline

# Multiply one Hermite series by another.
numpy.polynomial.hermite.hermmul

# Multiply a Hermite series by x.
numpy.polynomial.hermite.hermmulx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite.hermone

# Raise a Hermite series to a power.
numpy.polynomial.hermite.hermpow

# Compute the roots of a Hermite series.
numpy.polynomial.hermite.hermroots

# Subtract one Hermite series from another.
numpy.polynomial.hermite.hermsub

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.hermite.hermtrim

# Evaluate an Hermite series at points x.
numpy.polynomial.hermite.hermval

# Evaluate a 2-D Hermite series at points (x, y).
numpy.polynomial.hermite.hermval2d

# Evaluate a 3-D Hermite series at points (x, y, z).
numpy.polynomial.hermite.hermval3d

# Pseudo-Vandermonde matrix of given degree.
numpy.polynomial.hermite.hermvander

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.hermite.hermvander2d

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.hermite.hermvander3d

# Weight function of the Hermite polynomials.
numpy.polynomial.hermite.hermweight

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite.hermx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite.hermzero

# poly2herm(pol)
numpy.polynomial.hermite.poly2herm

# An HermiteE series class.
numpy.polynomial.hermite_e.HermiteE

# Convert a Hermite series to a polynomial.
numpy.polynomial.hermite_e.herme2poly

# Add one Hermite series to another.
numpy.polynomial.hermite_e.hermeadd

# Return the scaled companion matrix of c.
numpy.polynomial.hermite_e.hermecompanion

# Differentiate a Hermite_e series.
numpy.polynomial.hermite_e.hermeder

# Divide one Hermite series by another.
numpy.polynomial.hermite_e.hermediv

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite_e.hermedomain

# Least squares fit of Hermite series to data.
numpy.polynomial.hermite_e.hermefit

# Generate a HermiteE series with given roots.
numpy.polynomial.hermite_e.hermefromroots

# Gauss-HermiteE quadrature.
numpy.polynomial.hermite_e.hermegauss

# Evaluate a 2-D HermiteE series on the Cartesian product of x and y.
numpy.polynomial.hermite_e.hermegrid2d

# Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.
numpy.polynomial.hermite_e.hermegrid3d

# Integrate a Hermite_e series.
numpy.polynomial.hermite_e.hermeint

# Hermite series whose graph is a straight line.
numpy.polynomial.hermite_e.hermeline

# Multiply one Hermite series by another.
numpy.polynomial.hermite_e.hermemul

# Multiply a Hermite series by x.
numpy.polynomial.hermite_e.hermemulx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite_e.hermeone

# Raise a Hermite series to a power.
numpy.polynomial.hermite_e.hermepow

# Compute the roots of a HermiteE series.
numpy.polynomial.hermite_e.hermeroots

# Subtract one Hermite series from another.
numpy.polynomial.hermite_e.hermesub

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.hermite_e.hermetrim

# Evaluate an HermiteE series at points x.
numpy.polynomial.hermite_e.hermeval

# Evaluate a 2-D HermiteE series at points (x, y).
numpy.polynomial.hermite_e.hermeval2d

# Evaluate a 3-D Hermite_e series at points (x, y, z).
numpy.polynomial.hermite_e.hermeval3d

# Pseudo-Vandermonde matrix of given degree.
numpy.polynomial.hermite_e.hermevander

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.hermite_e.hermevander2d

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.hermite_e.hermevander3d

# Weight function of the Hermite_e polynomials.
numpy.polynomial.hermite_e.hermeweight

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite_e.hermex

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.hermite_e.hermezero

# poly2herme(pol)
numpy.polynomial.hermite_e.poly2herme

# A Laguerre series class.
numpy.polynomial.laguerre.Laguerre

# Convert a Laguerre series to a polynomial.
numpy.polynomial.laguerre.lag2poly

# Add one Laguerre series to another.
numpy.polynomial.laguerre.lagadd

# Return the companion matrix of c.
numpy.polynomial.laguerre.lagcompanion

# Differentiate a Laguerre series.
numpy.polynomial.laguerre.lagder

# Divide one Laguerre series by another.
numpy.polynomial.laguerre.lagdiv

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.laguerre.lagdomain

# Least squares fit of Laguerre series to data.
numpy.polynomial.laguerre.lagfit

# Generate a Laguerre series with given roots.
numpy.polynomial.laguerre.lagfromroots

# Gauss-Laguerre quadrature.
numpy.polynomial.laguerre.laggauss

# Evaluate a 2-D Laguerre series on the Cartesian product of x and y.
numpy.polynomial.laguerre.laggrid2d

# Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.
numpy.polynomial.laguerre.laggrid3d

# Integrate a Laguerre series.
numpy.polynomial.laguerre.lagint

# Laguerre series whose graph is a straight line.
numpy.polynomial.laguerre.lagline

# Multiply one Laguerre series by another.
numpy.polynomial.laguerre.lagmul

# Multiply a Laguerre series by x.
numpy.polynomial.laguerre.lagmulx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.laguerre.lagone

# Raise a Laguerre series to a power.
numpy.polynomial.laguerre.lagpow

# Compute the roots of a Laguerre series.
numpy.polynomial.laguerre.lagroots

# Subtract one Laguerre series from another.
numpy.polynomial.laguerre.lagsub

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.laguerre.lagtrim

# Evaluate a Laguerre series at points x.
numpy.polynomial.laguerre.lagval

# Evaluate a 2-D Laguerre series at points (x, y).
numpy.polynomial.laguerre.lagval2d

# Evaluate a 3-D Laguerre series at points (x, y, z).
numpy.polynomial.laguerre.lagval3d

# Pseudo-Vandermonde matrix of given degree.
numpy.polynomial.laguerre.lagvander

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.laguerre.lagvander2d

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.laguerre.lagvander3d

# Weight function of the Laguerre polynomials.
numpy.polynomial.laguerre.lagweight

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.laguerre.lagx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.laguerre.lagzero

# poly2lag(pol)
numpy.polynomial.laguerre.poly2lag

# A Legendre series class.
numpy.polynomial.legendre.Legendre

# Convert a Legendre series to a polynomial.
numpy.polynomial.legendre.leg2poly

# Add one Legendre series to another.
numpy.polynomial.legendre.legadd

# Return the scaled companion matrix of c.
numpy.polynomial.legendre.legcompanion

# Differentiate a Legendre series.
numpy.polynomial.legendre.legder

# Divide one Legendre series by another.
numpy.polynomial.legendre.legdiv

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.legendre.legdomain

# Least squares fit of Legendre series to data.
numpy.polynomial.legendre.legfit

# Generate a Legendre series with given roots.
numpy.polynomial.legendre.legfromroots

# Gauss-Legendre quadrature.
numpy.polynomial.legendre.leggauss

# Evaluate a 2-D Legendre series on the Cartesian product of x and y.
numpy.polynomial.legendre.leggrid2d

# Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.
numpy.polynomial.legendre.leggrid3d

# Integrate a Legendre series.
numpy.polynomial.legendre.legint

# Legendre series whose graph is a straight line.
numpy.polynomial.legendre.legline

# Multiply one Legendre series by another.
numpy.polynomial.legendre.legmul

# Multiply a Legendre series by x.
numpy.polynomial.legendre.legmulx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.legendre.legone

# Raise a Legendre series to a power.
numpy.polynomial.legendre.legpow

# Compute the roots of a Legendre series.
numpy.polynomial.legendre.legroots

# Subtract one Legendre series from another.
numpy.polynomial.legendre.legsub

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.legendre.legtrim

# Evaluate a Legendre series at points x.
numpy.polynomial.legendre.legval

# Evaluate a 2-D Legendre series at points (x, y).
numpy.polynomial.legendre.legval2d

# Evaluate a 3-D Legendre series at points (x, y, z).
numpy.polynomial.legendre.legval3d

# Pseudo-Vandermonde matrix of given degree.
numpy.polynomial.legendre.legvander

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.legendre.legvander2d

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.legendre.legvander3d

# Weight function of the Legendre polynomials.
numpy.polynomial.legendre.legweight

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.legendre.legx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.legendre.legzero

# Convert a polynomial to a Legendre series.
numpy.polynomial.legendre.poly2leg

# A power series class.
numpy.polynomial.polynomial.Polynomial

# Add one polynomial to another.
numpy.polynomial.polynomial.polyadd

# Return the companion matrix of c.
numpy.polynomial.polynomial.polycompanion

# Differentiate a polynomial.
numpy.polynomial.polynomial.polyder

# Divide one polynomial by another.
numpy.polynomial.polynomial.polydiv

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.polynomial.polydomain

# Least-squares fit of a polynomial to data.
numpy.polynomial.polynomial.polyfit

# Generate a monic polynomial with given roots.
numpy.polynomial.polynomial.polyfromroots

# Evaluate a 2-D polynomial on the Cartesian product of x and y.
numpy.polynomial.polynomial.polygrid2d

# Evaluate a 3-D polynomial on the Cartesian product of x, y and z.
numpy.polynomial.polynomial.polygrid3d

# Integrate a polynomial.
numpy.polynomial.polynomial.polyint

# Returns an array representing a linear polynomial.
numpy.polynomial.polynomial.polyline

# Multiply one polynomial by another.
numpy.polynomial.polynomial.polymul

# Multiply a polynomial by x.
numpy.polynomial.polynomial.polymulx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.polynomial.polyone

# Raise a polynomial to a power.
numpy.polynomial.polynomial.polypow

# Compute the roots of a polynomial.
numpy.polynomial.polynomial.polyroots

# Subtract one polynomial from another.
numpy.polynomial.polynomial.polysub

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.polynomial.polytrim

# Evaluate a polynomial at points x.
numpy.polynomial.polynomial.polyval

# Evaluate a 2-D polynomial at points (x, y).
numpy.polynomial.polynomial.polyval2d

# Evaluate a 3-D polynomial at points (x, y, z).
numpy.polynomial.polynomial.polyval3d

# Evaluate a polynomial specified by its roots at points x.
numpy.polynomial.polynomial.polyvalfromroots

# Vandermonde matrix of given degree.
numpy.polynomial.polynomial.polyvander

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.polynomial.polyvander2d

# Pseudo-Vandermonde matrix of given degrees.
numpy.polynomial.polynomial.polyvander3d

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.polynomial.polyx

# ndarray(shape, dtype=float, buffer=None, offset=0,
numpy.polynomial.polynomial.polyzero

# Return argument as a list of 1-d arrays.
numpy.polynomial.polyutils.as_series

numpy.polynomial.polyutils.format_float

# Return a domain suitable for given abscissae.
numpy.polynomial.polyutils.getdomain

# Apply linear map to input points.
numpy.polynomial.polyutils.mapdomain

# Linear map parameters between domains.
numpy.polynomial.polyutils.mapparms

# Remove "small" "trailing" coefficients from a polynomial.
numpy.polynomial.polyutils.trimcoef

# Remove small Poly series coefficients.
numpy.polynomial.polyutils.trimseq

# interface(state_address, state, next_uint64, next_uint32, next_double, bit_generator)
numpy.random._common.interface

# Generator(bit_generator)
numpy.random._generator.Generator

# MT19937(seed=None)
numpy.random._generator.MT19937

# PCG64(seed=None)
numpy.random._generator.PCG64

# All the operations on a read-only sequence.
numpy.random._generator.Sequence

# default_rng(seed=None)
numpy.random._generator.default_rng

# normalize_axis_index(axis, ndim, msg_prefix=None)
numpy.random._generator.normalize_axis_index

# NumPy
numpy.random._generator.np

# Operator interface.
numpy.random._generator.operator

# Python part of the warnings subsystem.
numpy.random._generator.warnings

# MT19937(seed=None)
numpy.random._mt19937.MT19937

# PCG64(seed=None)
numpy.random._pcg64.PCG64

# Philox(seed=None, counter=None, key=None)
numpy.random._philox.Philox

# BitGenerator(seed=None)
numpy.random._pickle.BitGenerator

# dict() -> new empty dictionary
numpy.random._pickle.BitGenerators

# Generator(bit_generator)
numpy.random._pickle.Generator

# MT19937(seed=None)
numpy.random._pickle.MT19937

# PCG64(seed=None)
numpy.random._pickle.PCG64

# PCG64DXSM(seed=None)
numpy.random._pickle.PCG64DXSM

# Philox(seed=None, counter=None, key=None)
numpy.random._pickle.Philox

# RandomState(seed=None)
numpy.random._pickle.RandomState

# SFC64(seed=None)
numpy.random._pickle.SFC64

# SFC64(seed=None)
numpy.random._sfc64.SFC64

# BitGenerator(seed=None)
numpy.random.bit_generator.BitGenerator

# SeedSequence(entropy=None, *, spawn_key=(), pool_size=4)
numpy.random.bit_generator.SeedSequence

# RandomState(seed=None)
numpy.random.mtrand.RandomState

# beta(a, b, size=None)
numpy.random.mtrand.beta

# binomial(n, p, size=None)
numpy.random.mtrand.binomial

# bytes(length)
numpy.random.mtrand.bytes

# chisquare(df, size=None)
numpy.random.mtrand.chisquare

# choice(a, size=None, replace=True, p=None)
numpy.random.mtrand.choice

# dirichlet(alpha, size=None)
numpy.random.mtrand.dirichlet

# exponential(scale=1.0, size=None)
numpy.random.mtrand.exponential

# f(dfnum, dfden, size=None)
numpy.random.mtrand.f

# gamma(shape, scale=1.0, size=None)
numpy.random.mtrand.gamma

# geometric(p, size=None)
numpy.random.mtrand.geometric

# Returns the singleton RandomState's bit generator
numpy.random.mtrand.get_bit_generator

# get_state(legacy=True)
numpy.random.mtrand.get_state

# gumbel(loc=0.0, scale=1.0, size=None)
numpy.random.mtrand.gumbel

# hypergeometric(ngood, nbad, nsample, size=None)
numpy.random.mtrand.hypergeometric

# laplace(loc=0.0, scale=1.0, size=None)
numpy.random.mtrand.laplace

# logistic(loc=0.0, scale=1.0, size=None)
numpy.random.mtrand.logistic

# lognormal(mean=0.0, sigma=1.0, size=None)
numpy.random.mtrand.lognormal

# logseries(p, size=None)
numpy.random.mtrand.logseries

# multinomial(n, pvals, size=None)
numpy.random.mtrand.multinomial

# multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)
numpy.random.mtrand.multivariate_normal

# negative_binomial(n, p, size=None)
numpy.random.mtrand.negative_binomial

# noncentral_chisquare(df, nonc, size=None)
numpy.random.mtrand.noncentral_chisquare

# noncentral_f(dfnum, dfden, nonc, size=None)
numpy.random.mtrand.noncentral_f

# normal(loc=0.0, scale=1.0, size=None)
numpy.random.mtrand.normal

# pareto(a, size=None)
numpy.random.mtrand.pareto

# permutation(x)
numpy.random.mtrand.permutation

# poisson(lam=1.0, size=None)
numpy.random.mtrand.poisson

# power(a, size=None)
numpy.random.mtrand.power

# rand(d0, d1, ..., dn)
numpy.random.mtrand.rand

# randint(low, high=None, size=None, dtype=int)
numpy.random.mtrand.randint

# randn(d0, d1, ..., dn)
numpy.random.mtrand.randn

# random(size=None)
numpy.random.mtrand.random

# random_integers(low, high=None, size=None)
numpy.random.mtrand.random_integers

# random_sample(size=None)
numpy.random.mtrand.random_sample

# This is an alias of `random_sample`. See `random_sample`  for the complete
numpy.random.mtrand.ranf

# rayleigh(scale=1.0, size=None)
numpy.random.mtrand.rayleigh

# This is an alias of `random_sample`. See `random_sample`  for the complete
numpy.random.mtrand.sample

# seed(seed=None)
numpy.random.mtrand.seed

# Sets the singleton RandomState's bit generator
numpy.random.mtrand.set_bit_generator

# set_state(state)
numpy.random.mtrand.set_state

# shuffle(x)
numpy.random.mtrand.shuffle

# standard_cauchy(size=None)
numpy.random.mtrand.standard_cauchy

# standard_exponential(size=None)
numpy.random.mtrand.standard_exponential

# standard_gamma(shape, size=None)
numpy.random.mtrand.standard_gamma

# standard_normal(size=None)
numpy.random.mtrand.standard_normal

# standard_t(df, size=None)
numpy.random.mtrand.standard_t

# triangular(left, mode, right, size=None)
numpy.random.mtrand.triangular

# uniform(low=0.0, high=1.0, size=None)
numpy.random.mtrand.uniform

# vonmises(mu, kappa, size=None)
numpy.random.mtrand.vonmises

# wald(mean, scale, size=None)
numpy.random.mtrand.wald

# weibull(a, size=None)
numpy.random.mtrand.weibull

# zipf(a, size=None)
numpy.random.mtrand.zipf

# Build and imports a c-extension module `modname` from a list of function
numpy.testing._private.extbuild.build_and_import_extension

# Build an extension module and return the filename of the resulting
numpy.testing._private.extbuild.compile_extension_module

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.BLAS_SUPPORTS_FPE

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.HAS_LAPACK64

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.HAS_REFCOUNT

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_64BIT

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_EDITABLE

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_INSTALLED

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_MUSL

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_PYPY

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_PYSTON

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.IS_WASM

# Ignoring this exception due to disabled feature
numpy.testing._private.utils.IgnoreException

# Raise this exception to mark a test as a known failing test.
numpy.testing._private.utils.KnownFailureException

# Returns True when the argument is true, False otherwise.
numpy.testing._private.utils.NOGIL_BUILD

# Path subclass for non-Windows systems.
numpy.testing._private.utils.NUMPY_ROOT

# Raise this exception in a test to skip it.
numpy.testing._private.utils.SkipTest

# Assert that works in release mode.
numpy.testing._private.utils.assert_

# Raises an AssertionError if two objects are not equal up to desired
numpy.testing._private.utils.assert_allclose

# Raises an AssertionError if two items are not equal up to desired
numpy.testing._private.utils.assert_almost_equal

# Raises an AssertionError if two items are not equal up to significant
numpy.testing._private.utils.assert_approx_equal

# Raises an AssertionError if two objects are not equal up to desired
numpy.testing._private.utils.assert_array_almost_equal

# Compare two arrays relatively to their spacing.
numpy.testing._private.utils.assert_array_almost_equal_nulp

numpy.testing._private.utils.assert_array_compare

# Raises an AssertionError if two array_like objects are not equal.
numpy.testing._private.utils.assert_array_equal

# Raises an AssertionError if two array_like objects are not ordered by less
numpy.testing._private.utils.assert_array_less

# Check that all items of arrays differ in at most N Units in the Last Place.
numpy.testing._private.utils.assert_array_max_ulp

# Raises an AssertionError if two objects are not equal.
numpy.testing._private.utils.assert_equal

# Fail if the given callable produces any reference cycles.
numpy.testing._private.utils.assert_no_gc_cycles

# Fail if the given callable produces any warnings.
numpy.testing._private.utils.assert_no_warnings

# assert_raises(exception_class, callable, *args, **kwargs)
numpy.testing._private.utils.assert_raises

# assert_raises_regex(exception_class, expected_regexp, callable, *args,
numpy.testing._private.utils.assert_raises_regex

# Test if two strings are equal.
numpy.testing._private.utils.assert_string_equal

# Fail unless the given callable throws the specified warning.
numpy.testing._private.utils.assert_warns

# Break reference cycles by calling gc.collect
numpy.testing._private.utils.break_cycles

numpy.testing._private.utils.build_err_msg

# gh-22982
numpy.testing._private.utils.check_support_sve

# Context manager that resets warning registry for catching warnings
numpy.testing._private.utils.clear_and_catch_warnings

# Apply a decorator to all methods in a class matching a regular expression.
numpy.testing._private.utils.decorate_methods

# Return number of jiffies elapsed.
numpy.testing._private.utils.jiffies

# Return elapsed time for executing code in the namespace of the caller.
numpy.testing._private.utils.measure

# Return virtual memory size in bytes of the running python.
numpy.testing._private.utils.memusage

# Test if two objects are equal, and print an error message if test fails.
numpy.testing._private.utils.print_assert_equal

# Runs a function many times in parallel
numpy.testing._private.utils.run_threaded

# Run doctests found in the given file.
numpy.testing._private.utils.rundocs

numpy.testing._private.utils.runstring

# Context manager and decorator doing much the same as
numpy.testing._private.utils.suppress_warnings

# Context manager to provide a temporary test folder.
numpy.testing._private.utils.tempdir

# Context manager for temporary files.
numpy.testing._private.utils.temppath

# int([x]) -> integer
numpy.testing._private.utils.verbose

# Determine if a Numpy function can be overridden via `__array_function__`
numpy.testing.overrides.allows_array_function_override

# Determine if a function can be overridden via `__array_ufunc__`
numpy.testing.overrides.allows_array_ufunc_override

# List all numpy functions overridable via `__array_function__`
numpy.testing.overrides.get_overridable_numpy_array_functions

# List all numpy ufuncs overridable via `__array_ufunc__`
numpy.testing.overrides.get_overridable_numpy_ufuncs

numpy.testing.print_coercion_tables.GenericObject

# Returns a new subclass of tuple with named fields.
numpy.testing.print_coercion_tables.namedtuple

# NumPy
numpy.testing.print_coercion_tables.np

# Return the scalar dtype or NumPy equivalent of Python type of an object.
numpy.testing.print_coercion_tables.obj2sctype

numpy.testing.print_coercion_tables.print_cancast_table

numpy.testing.print_coercion_tables.print_coercion_table

# Prints new casts, the values given are default "can-cast" values, not
numpy.testing.print_coercion_tables.print_new_cast_table

# str(object='') -> str
numpy.version.full_version

# str(object='') -> str
numpy.version.git_revision

# Returns True when the argument is true, False otherwise.
numpy.version.release

# str(object='') -> str
numpy.version.short_version

# str(object='') -> str
numpy.version.version

